Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/.classpath
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/.classpath
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/.classpath	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/.classpath	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/project.properties
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/project.properties	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/project.properties	(版本 25821)
+# This file is automatically generated by Android Tools.
+# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
+#
+# This file must be checked in Version Control Systems.
+#
+# To customize properties used by the Ant build system edit
+# "ant.properties", and override values to adapt the script to your
+# project structure.
+#
+# To enable ProGuard to shrink and obfuscate your code, uncomment this (available properties: sdk.dir, user.home):
+#proguard.config=${sdk.dir}/tools/proguard/proguard-android.txt:proguard-project.txt
+# Project target.
+target=android-8
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/.project
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/.project
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/.project	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/.project	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/Android.mk
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/Android.mk	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/Android.mk	(版本 25821)
+#LiuMing@Prd.SysAPP.Settings, 2013/03/18, Add for invalid for 13009&13039
+ifneq ($(OPPO_WIFI_DIRECT_SUPPORT), no)
+#endif /*VENDOR_EDIT*/
+LOCAL_PATH:= $(call my-dir)
+include $(CLEAR_VARS)
+#LOCAL_MODULE_TAGS := user
+LOCAL_MODULE_TAGS := optional
+# Only compile source java files in this apk.
+LOCAL_SRC_FILES := $(call all-java-files-under, src)
+LOCAL_SRC_FILES += src/com/oppo/wifidirect/IDataService.aidl
+LOCAL_PACKAGE_NAME := WifiDirectFileTransfer
+LOCAL_CERTIFICATE := platform
+#LOCAL_SDK_VERSION := current
+include $(BUILD_PACKAGE)
+# Use the following include to make our test apk.
+include $(call all-makefiles-under,$(LOCAL_PATH))
+#ifdef VENDOR_EDIT 
+#LiuMing@Prd.SysAPP.Settings, 2013/03/18, Add for invalid for 13009&13039
+endif
+#endif /*VENDOR_EDIT*/
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/AndroidManifest.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/AndroidManifest.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/AndroidManifest.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/AndroidManifest.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/AcceptDialog.java
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/AcceptDialog.java	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/AcceptDialog.java	(版本 25821)
+package com.oppo.wifidirect;
+import com.oppo.wifidirect.R;
+import com.oppo.wifidirect.IDataService;
+import android.app.AlertDialog;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.ComponentName;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.ServiceConnection;
+import android.os.Binder;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.IBinder;
+import android.provider.Settings;
+import android.view.View;
+import android.widget.TextView;
+import android.util.Log;
+import com.android.internal.app.AlertActivity;
+import com.android.internal.app.AlertController;
+public class AcceptDialog extends AlertActivity implements 
+        DialogInterface.OnClickListener {
+    private final String ACTION_IPO_SHUTDOWN = "android.intent.action.ACTION_SHUTDOWN_IPO";
+    private final String ACTION_SS_STATE_CHANGED = "android.intent.action.SERVICE_STATE";
+    private final String ACTION_ACCEPT_FILE = "android.oppo.wifidirect.dataservice";
+    public final static int ACCEPTFILE = 0;
+    public final static int REJECTFILE = 1;
+    private String fileNames;
+    private Handler mTimeoutDialogHandler;
+    private final int dialogTimeout = 10;
+    private AlertDialog mAcceptDialog;
+    private IDataService mDataService;
+    private boolean mIsBound = false;
+    private final String tag = "AcceptDialog";
+    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+            Log.d(tag, "onReceive : " + action);
+            if (ACTION_IPO_SHUTDOWN.equals(action)) {
+                finish();
+            } else if (ACTION_SS_STATE_CHANGED.equals(action)) {
+                if (Settings.System.getInt(context.getContentResolver(),
+                        Settings.System.AIRPLANE_MODE_ON, 0) != 0) {
+                    finish();
+                }
+            }
+        }
+    };
+    private Runnable dialogAutoDismissRunnable = new Runnable() {
+        @Override
+        public void run() {
+            //reject to accept file
+            sendResultBroadCast(REJECTFILE);
+            finish();
+        }
+    };
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        super.setFinishOnTouchOutside(false);
+        fileNames = getIntent().getExtras().getString("FILENAMES");
+        mTimeoutDialogHandler = new Handler();
+        mTimeoutDialogHandler.postDelayed(dialogAutoDismissRunnable, dialogTimeout);
+        // Set up the "dialog"
+        final AlertController.AlertParams p = mAlertParams;
+        p.mIconId = android.R.drawable.ic_dialog_alert;
+        p.mTitle = getString(R.string.accept_dialog_title);
+        p.mView = createView();
+        p.mPositiveButtonText = getString(R.string.accept_dialog_positive_button_text);
+        p.mPositiveButtonListener = this;
+        p.mNegativeButtonText = getString(R.string.accept_dialog_negative_button_text);
+        p.mNegativeButtonListener = this;
+        setupAlert();
+        IntentFilter intentFilter = new IntentFilter();
+        intentFilter.addAction(ACTION_IPO_SHUTDOWN);
+        intentFilter.addAction(ACTION_SS_STATE_CHANGED);
+        registerReceiver(mReceiver, intentFilter);
+        doBindService();
+    }
+    private View createView() {
+        View view = getLayoutInflater().inflate(R.layout.confirm_dialog, null);
+        TextView contentView = (TextView) view.findViewById(R.id.content);
+        contentView.setText(fileNames);
+        return view;
+    }
+    public void onClick(DialogInterface dialog, int which) {
+        Log.d(tag, "onClick which=" + which);
+        switch (which) {
+        case DialogInterface.BUTTON_POSITIVE:
+            onUserPositive();
+            finish();
+            break;
+        case DialogInterface.BUTTON_NEGATIVE:
+            onUserNegative();
+            finish();
+            break;
+        default:
+            Log.d(tag, "onClick(): which=" + which);
+            break;
+        }
+    }
+    private void onUserPositive() {
+        mTimeoutDialogHandler.removeCallbacks(dialogAutoDismissRunnable);
+        /*
+        if(mDataService.receiveFile()) {
+            sendResultBroadCast(ACCEPTFILE);
+        } else {
+            Log.e(tag,"aidl create new acceptThread fail!");
+            sendResultBroadCast(REJECTFILE);
+        }*/
+    }
+    private void onUserNegative() {
+        mTimeoutDialogHandler.removeCallbacks(dialogAutoDismissRunnable);
+        sendResultBroadCast(REJECTFILE);
+    }
+    private void sendResultBroadCast(int accepted) {
+        Intent mIntent = new Intent(ACTION_ACCEPT_FILE);
+        mIntent.putExtra("accepted", accepted);
+        sendBroadcast(mIntent);
+    }
+    protected void onDestroy() {
+        Log.d(tag, "onDestroy");
+        super.onDestroy();
+        doUnbindService();
+        unregisterReceiver(mReceiver);
+    }
+    private ServiceConnection mConnection = new ServiceConnection() {
+        public void onServiceConnected(ComponentName className, IBinder service) {
+            mDataService = IDataService.Stub.asInterface(service);
+        }
+        public void onServiceDisconnected(ComponentName className) {
+            mDataService = null;
+        }
+    };
+    private void doBindService() {
+        bindService(new Intent(AcceptDialog.this, 
+                DataService.class), mConnection, Context.BIND_AUTO_CREATE);
+        mIsBound = true;
+    }
+    private void doUnbindService() {
+        if (mIsBound) {
+            unbindService(mConnection);
+            mIsBound = false;
+        }
+    }
+}
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/ControlService.java
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/ControlService.java	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/ControlService.java	(版本 25821)
+package com.oppo.wifidirect;
+import com.oppo.wifidirect.R;
+import com.oppo.wifidirect.IDataService;
+import com.oppo.wifidirect.DataService.CommandListener;
+import com.oppo.wifidirect.util.TaskQueue;
+import com.oppo.wifidirect.util.WifiP2pNamedTask;
+//import con.oppo.wifidirect.DataService.ReceiveCommandListener;
+import android.app.Service; 
+import android.app.AlertDialog;
+import android.app.AlertDialog.Builder;
+import android.content.BroadcastReceiver;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.ServiceConnection;
+import android.os.Binder;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.IBinder;
+import android.os.Looper;
+import android.os.Message;
+import android.os.Messenger;
+import android.os.RemoteException;
+import android.util.Log;
+import com.android.internal.util.AsyncChannel;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.net.InetSocketAddress;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.UUID;
+import android.net.Uri;
+//#ifdef VENDOR_EDIT
+//kecheng.Shang@SysApp.BT, 2013/05/05, Add for 
+import java.util.ArrayList;  
+//#endif /* VENDOR_EDIT */
+public class ControlService extends Service {
+    private ServerSocket mServerSocket;
+    private Socket mSocket;
+    private DataOutputStream sendStream;
+    private DataInputStream receiveStream;
+    private ControlThread mControlThread;
+    //dialog area
+    private final String ACTION_ACCEPT_FILE = "android.oppo.wifidirect.dataservice";
+    //localservice bind
+    private IDataService mDataService;
+    private boolean mIsBound = false;
+    private AsyncChannel mReplyChannel = new AsyncChannel();
+    private int groupRole = -1;
+    private int dataRole;
+    private String address;
+    private int mServiceStartId;
+    //remote bind for ui
+    /*private Messenger mControlMessager;
+    private Handler mControlServiceHandler;*/
+    /**
+     *CTRL-EVENT-SENDFILE-a.txt_b.txt_c.mp3
+     *
+    */
+    private static final String EVENT_PREFIX_STR = "CTRL-EVENT-";
+    private static final int EVENT_PREFIX_LEN_STR = EVENT_PREFIX_STR.length();
+    private static final String SENDFILE_STR = "SENDFILE";
+    //sendhandler command
+    private static final int SEND_HANDLER_FILE_SEND = 1;
+    private static final int SEND_HANDLER_FILE_SEND_RESPONSE = 2;
+    //service is ok broadcast
+    private final String CONTROL_SERVICE_IS_READY_ACTION = "wifi_p2p_control_service_is_ready";
+    ControlChannel mControlChannel = new ControlChannel();
+    private final int P2P_SEND_FILE_REQUEST = 1;
+    private final int P2P_SEND_FILE_RESPONSE_SUCCESS = 2;
+    private final int P2P_SEND_FILE_RESPONSE_FAIL = 3;
+    private final int P2P_RECEIVE_FILE_REQUEST = 4;
+    private final int P2P_RECEIVE_FILE_RESPONSE_SUCCESS = 5;
+    private final int P2P_RECEIVE_FILE_RESPONSE_FAIL = 6;
+    private final static String tag = "ControlService";
+    private TaskQueue mSendTaskQueue;
+    private TaskQueue mReceiveTaskQueue;
+    @Override
+    public void onCreate() {
+        super.onCreate(); 
+        Log.d(tag,"onCreate");
+        //430mControlServiceHandler = new ControlServiceHandler();
+        //430mControlMessager = new Messenger(mControlServiceHandler);
+        mSendTaskQueue = new TaskQueue();
+        mReceiveTaskQueue = new TaskQueue();
+        doBindService();
+    }
+    @Override  
+    public IBinder onBind(Intent intent) {   
+        Log.d(tag,"onBind");
+        //430return mControlServiceBinder;  
+        return null;
+    } 
+    @Override
+    public int onStartCommand(Intent intent, int flags, int startId) {
+        if (intent != null) {
+            mServiceStartId = startId;
+            String command = intent.getStringExtra("command");
+            if(command.equals("start")) {
+                Log.w(tag, "onStartCommand start");
+                groupRole = intent.getExtras().getInt("groupRole");
+                Log.d(tag,"groupRole " + groupRole);
+                if(groupRole == 1) {
+                    //client
+                    address = intent.getExtras().getString("address");
+                } else {
+                    //server
+                    address = "0.0.0.0";
+                }
+                mControlThread = new ControlThread(groupRole, address);
+                mControlThread.start();
+                Log.d(tag, "onStartCommand wakeup mSendTaskQueue");
+            } else if(command.equals("stop")) {
+                Log.w(tag, "onStartCommand stop");
+                releaseSocket();
+                mSendTaskQueue.close();
+			    mSendTaskQueue = null;
+                mReceiveTaskQueue.close();
+                mReceiveTaskQueue = null;
+                stopSelf(mServiceStartId);
+            } else if(command.equals("pause")) {
+                Log.w(tag, "onStartCommand pause \nclear the queue");
+			    mSendTaskQueue.cancelPendingTasks();
+                mSendTaskQueue.holdTaskQueue();
+                mReceiveTaskQueue.cancelPendingTasks();
+                mReceiveTaskQueue.holdTaskQueue();
+                if(mControlThread != null) {
+                    mControlThread.interrupt();
+                    mControlThread = null;
+                }
+            } else if(command.equals("sendpath")) {
+                Log.w(tag, "onStartCommand sendpath");
+            //#ifndef VENDOR_EDIT
+            //kecheng.Shang@SysApp.BT, 2013/05/04, Modify for 
+            /*
+            */
+            //#else /* VENDOR_EDIT */
+               // if()
+                ArrayList<Uri> mUris  = intent.getParcelableArrayListExtra("uris");
+                if(mUris.size()== 0){
+                    Log.w(tag, "mUris size = 0");
+                }
+            //#endif /* VENDOR_EDIT */
+                Log.w(tag, "mUris size ="+mUris.size());
+                addInTaskQueueForSend(mUris);
+            }
+        } else {
+            Log.e(tag,"warning! intent == null!!!");
+        }
+        return START_STICKY;
+    }
+    class ControlThread extends Thread {
+        private int groupRole;
+        private String address;
+        public ControlThread(int groupRole, String address) {
+            this.groupRole = groupRole;
+            this.address = address;
+        }
+        @Override
+    	public void run() {
+            try {
+                Log.d(tag,"ControlThread begin");
+                switch(groupRole) {
+                    case 0:
+                        Log.e(tag,"address " + address + " groupRole " + groupRole);
+                        mServerSocket = new ServerSocket(8899);
+                        mSocket = mServerSocket.accept();
+                        mServerSocket.close();
+                        Log.e(tag,"+++++server connected +++++++");
+                        break;
+                    case 1:
+                        Log.e(tag,"address " + address + " groupRole " + groupRole);
+                        mSocket = new Socket(address,8899);
+                        Log.e(tag,"+++++client connected +++++++");
+                        break;
+                }
+                sendStream = new DataOutputStream(mSocket.getOutputStream()); 
+                //ControlChannel mControlChannel = new ControlChannel();
+                receiveStream = new DataInputStream(mSocket.getInputStream());
+                //wake up task
+                mSendTaskQueue.wakeUpTaskQueue();
+                mReceiveTaskQueue.wakeUpTaskQueue();
+    			String s = "";
+    			while (!Thread.interrupted()) {
+                    Log.e(tag,"...............");
+                    //test
+                    /*
+                    Thread.sleep(100);
+                    Message msg = new Message();
+                    msg.what = SEND_HANDLER_FILE_SEND;
+                    mSendHandler.sendMessage(msg);
+                    */
+                    //test
+    				s = receiveStream.readUTF();
+    				Log.d(tag,"client say: " + s);
+                    if("a".equals(s)) {
+                        addInTaskQueueForReceive();
+                    } else if("b".equals(s)) {
+                        //wake up task
+                        Log.d(tag,"get b wake up task");
+                        mSendTaskQueue.wakeUpTaskQueue();
+                    }
+    				/*
+    				if(s.startsWith(EVENT_PREFIX_STR)) {
+                        String eventName = s.substring(EVENT_PREFIX_LEN_STR);
+                        if(eventName.startsWith(SENDFILE_STR)) {
+                            String[] eventSplit = eventName.split("-");
+                            String[] fileNames = eventSplit[1].split("_");
+                            String dialogMsg = fileNamesToString(fileNames);
+                            showAcceptDialog(dialogMsg);
+                        }					
+    				}*/
+    			}
+                Log.d(tag,"ControlThread end");
+            }  catch(Exception e) {
+                e.printStackTrace();
+                Log.e(tag,"ControlThread Exception");
+            } finally {
+                releaseSocket();
+            }
+        }
+    }
+    private String fileNamesToString(String[] fileNames) {
+        StringBuffer sb = new StringBuffer();
+        for(String fileName : fileNames) {
+            sb.append(fileName + "\n");
+        }
+        return sb.toString();
+    }
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+        doUnbindService();
+        Log.d(tag,"onDestroy");
+    }
+    private void showAcceptDialog(String msg) {
+        Intent mIntent = new Intent(this, AcceptDialog.class);
+        mIntent.putExtra("FILENAMES",msg);
+        startActivity(mIntent);
+        //now receive broadcast to ack accept or reject
+    }
+    /*
+    private IControlService.Stub mControlServiceBinder = new IControlService.Stub() {   
+        public Messenger getMessenger() {
+            return mControlMessager;
+        }
+    };*/
+    private void releaseSocket() {
+        try {
+            if(mControlThread != null) {
+                mControlThread.interrupt();
+                mControlThread = null;
+            }
+            if(sendStream != null) {
+                sendStream.close();
+                sendStream = null;
+            }
+            if(receiveStream != null) {
+                receiveStream.close();
+                receiveStream = null;
+            }
+            if(mSocket != null) {
+                mSocket.close();
+            }
+            if(mServerSocket != null) {
+                mServerSocket.close();
+                mServerSocket = null;
+            }
+        } catch(Exception e) {
+            e.printStackTrace();
+            Log.e(tag,"releaseSocket Exception");
+        }
+    }
+    private ServiceConnection mConnection = new ServiceConnection() {
+        public void onServiceConnected(ComponentName className, IBinder service) {
+            mDataService = IDataService.Stub.asInterface(service);
+            connectToDataService();
+        }
+        public void onServiceDisconnected(ComponentName className) {
+            mDataService = null;
+        }
+    };
+    private void connectToDataService() {
+        try {
+            Messenger mMessenger = mDataService.getMessenger();
+            mControlChannel.mAsyncChannel.connectSync(this, mControlChannel.mHandler, mMessenger); 
+            Log.e(tag,"mAsyncChannel connect To DataService is ok");
+        } catch(RemoteException e) {
+            e.printStackTrace();
+        }
+    }
+    private String generateRandomPin() {
+        String randomUUID = UUID.randomUUID().toString();
+        return randomUUID.substring(0, 8);
+    }
+    private void doBindService() {
+        Log.e(tag,"doBindService");
+        if(!mIsBound) {
+           bindService(new Intent(ControlService.this, 
+                DataService.class), mConnection, Context.BIND_AUTO_CREATE); 
+           mIsBound = true;
+           Log.e(tag,"bind indeed");
+        }
+    }
+    private void doUnbindService() {
+        if (mIsBound) {
+            unbindService(mConnection);
+            mIsBound = false;
+        }
+    }
+    //430
+    /*
+    private class ControlServiceHandler extends Handler {
+        @Override
+        public void handleMessage(Message message) {
+            switch(message.what) {
+                case P2P_SEND_FILE_REQUEST:
+                    Log.e(tag, "+++++++++++++++++ get UI msg " + (String)message.obj);
+                    //String mPin = generateRandomPin();
+                    addInTaskQueueForSend((String)message.obj);
+                    //sendFile((String)message.obj);
+                    break;
+                default:
+                    Log.d(tag, "Ignored " + message);
+                    break;
+            }
+        }
+    }*/
+//#ifndef VENDOR_EDIT
+//kecheng.Shang@SysApp.BT, 2013/05/04, Modify for 
+/*
+*/
+//#else /* VENDOR_EDIT */
+//#endif /* VENDOR_EDIT */
+    //insert send file task into queue
+    private void addInTaskQueueForSend( ArrayList<Uri> uris) {
+        mSendTaskQueue.execute(new SendTask(uris, generateRandomPin()));
+    }
+    //insert receive file task into queue
+    private void addInTaskQueueForReceive() {
+        mReceiveTaskQueue.execute(new ReceiveTask());
+    }
+    private class SendTask implements WifiP2pNamedTask {
+        private ArrayList<Uri> paths;
+        private String pin;
+        private int mPin;
+        public SendTask(ArrayList<Uri> path, String pin) {
+            this.paths = path;
+            this.pin = pin;
+        }
+        @Override
+    	public void run() {
+    	    Log.i(tag,"SEND_TASK BEGIN " + pin+ "\nsendFile paths " + paths);
+            Message msg = Message.obtain();
+            msg.what = P2P_SEND_FILE_REQUEST;
+            msg.arg2 = mControlChannel.putListener(new DataService.CommandListener() {
+                            public void onSuccess(){
+                                Log.e(tag,"SendCommandListener onSuccess"); 
+                                try {
+                                    sendStream.writeUTF("a");
+        			                sendStream.flush();
+                                    Log.d(tag, "SendTask hold the task queue " + mPin);
+                                }catch(Exception e) {
+                                    Log.e(tag, "SendTask Exception" + Log.getStackTraceString(e));
+                                }
+    			                mSendTaskQueue.holdTaskQueue();
+                            }
+                            public void onFailure(int reason) {
+                            }
+                        });
+            Log.e(tag,"msg.arg2 " + msg.arg2);
+            mPin = msg.arg2;
+            msg.obj = paths;
+            mControlChannel.mAsyncChannel.sendMessage(msg);
+            Log.i(tag,"SEND_TASK END " + pin);
+        }
+        public String getName() {
+            return ("SendTask " + pin);
+        }
+    }
+    private class ReceiveTask implements WifiP2pNamedTask {
+        @Override
+    	public void run() {
+    	    Log.d(tag,"ReceiveTask run");
+            Message msg = Message.obtain();
+            msg.what = P2P_RECEIVE_FILE_REQUEST;
+            msg.arg2 = mControlChannel.putListener(new DataService.CommandListener() {
+                            public void onSuccess(){
+                                Log.e(tag,"ReceiveCommandListener onSuccess");
+                                try {
+                                    sendStream.writeUTF("b");
+			                        sendStream.flush(); 
+                                }catch(Exception e) {
+                                    Log.e(tag,"receive task Exception " + Log.getStackTraceString(e));
+                                }
+                            }
+                            public void onFailure(int reason) {
+                            }
+                        });
+            mControlChannel.mAsyncChannel.sendMessage(msg);
+            Log.e(tag,"ReceiveTask run end");
+        }
+        public String getName() {
+            return "ReceiveTask";
+        }
+    }
+    public class ControlChannel {
+        ControlChannel() {
+            mAsyncChannel = new AsyncChannel();
+            mHandler = new P2pControlHandler();
+        }
+        private final static int INVALID_LISTENER_KEY = 0;
+        private HashMap<Integer, Object> mListenerMap = new HashMap<Integer, Object>();
+        private Object mListenerMapLock = new Object();
+        private int mListenerKey = 0;
+        private AsyncChannel mAsyncChannel;
+        private P2pControlHandler mHandler;
+        class P2pControlHandler extends Handler {
+            @Override
+            public void handleMessage(Message message) {
+                Object listener = getListener(message.arg2);
+                switch (message.what) {
+                    case AsyncChannel.CMD_CHANNEL_DISCONNECTED:
+                        break;
+                    case P2P_SEND_FILE_RESPONSE_SUCCESS:
+                        //from DataService.mReplyChannel get Receive thread is ready \
+                        //sendHandler to receive Device
+                        ((CommandListener)listener).onSuccess();
+                        Log.d(tag, "P2P_SEND_FILE_RESPONSE");
+                        break;
+                    case P2P_RECEIVE_FILE_RESPONSE_SUCCESS:
+                        //
+                        ((CommandListener)listener).onSuccess();
+                        Log.d(tag, "P2P_RECEIVE_FILE_RESPONSE");
+                        break;
+                   default:
+                        Log.d(tag, "Ignored " + message);
+                        break;
+                }
+            }
+        }
+        private int putListener(Object listener) {
+            if (listener == null) return INVALID_LISTENER_KEY;
+            int key;
+            synchronized (mListenerMapLock) {
+                do {
+                    key = mListenerKey++;
+                } while (key == INVALID_LISTENER_KEY);
+                mListenerMap.put(key, listener);
+            }
+            return key;
+        }
+        private Object getListener(int key) {
+            if (key == INVALID_LISTENER_KEY) return null;
+            synchronized (mListenerMapLock) {
+                return mListenerMap.remove(key);
+            }
+        }
+    }
+}
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/share/OppTransferInfo.java
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/share/OppTransferInfo.java	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/share/OppTransferInfo.java	(版本 25821)
+/************************************************************************************
+** File: - ..\mediatek\source\packages\Bluetooth\profiles\opp\src\com\mediatek\bluetooth\opp\mmi\OppTransferInfo.java
+** VENDOR_EDIT
+** Copyright (C), 2008-2012, OPPO Mobile Comm Corp., Ltd
+** 
+** Description: 
+**      bluetooth Opp Transfer Information
+** 
+** Version: 0.1
+** Date created: 16:43:39,06/12/2011
+** Author: Jiehong.Tang@CommSrv.BT
+** 
+** --------------------------- Revision History: --------------------------------
+** 	<author>	<data>			<desc>
+** 
+************************************************************************************/
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+package com.oppo.wifidirect.share;
+//import com.mediatek.bluetooth.share.WifiDirectShareTask;
+//import com.mediatek.bluetooth.share.WifiDirectShareTask.WifiDirectShareTaskMetaData;
+/**
+ * This is currently used by Application codes. This class stores information
+ * about a single OBEX transfer (operation)
+ */
+public class OppTransferInfo {
+    int mID;
+    public WifiDirectShareTask.Direction mDirection;
+    public int mTotalBytes;
+    public int mCurrentBytes;
+    public int mState;
+    public Long mTimeStamp;
+    public String mDestAddr; // bt address
+    public String mFileName;
+    public String mFileType;
+    public String mFileUri; // the uri of the transferring file, related to the URI
+    public String mDeviceName; // bt device name
+	public static boolean isStatusSuccess(int status){
+		return (status == WifiDirectShareTask.STATE_SUCCESS);
+	}
+	public static boolean isStatusCompleted(int status)
+	{
+		if(status == WifiDirectShareTask.STATE_SUCCESS 
+		|| status == WifiDirectShareTask.STATE_FAILURE 
+		|| status == WifiDirectShareTask.STATE_ABORTED
+		|| status == WifiDirectShareTask.STATE_REJECTED
+		|| status == WifiDirectShareTask.STATUS_FORBIDDEN){
+			return true;
+		}else{
+			return false;
+		}
+	}
+	public static boolean isStatusError(int status){
+		if(status == WifiDirectShareTask.STATE_FAILURE 
+		|| status == WifiDirectShareTask.STATE_ABORTED
+		|| status == WifiDirectShareTask.STATE_REJECTED
+		|| status == WifiDirectShareTask.STATUS_FORBIDDEN){
+			return true;
+		}else{
+			return false;
+		}
+	}
+	public static boolean isStatusFinishedTransfer(int status){
+		return (status == WifiDirectShareTask.STATE_SUCCESS || status == WifiDirectShareTask.STATE_REMOVED);
+	}
+	public static final String WHERE_SUCCESS =  "(" + WifiDirectShareTaskMetaData.TASK_STATE + " == " + WifiDirectShareTask.STATE_SUCCESS + ")";
+	public static final String WHERE_ONGOING  =  "(" + WifiDirectShareTaskMetaData.TASK_STATE + " == " + WifiDirectShareTask.STATE_ONGOING + ")";
+	public static final String WHERE_PENDING =  "(" + WifiDirectShareTaskMetaData.TASK_STATE + " == " + WifiDirectShareTask.STATE_PENDING + ")";
+	public static final String WHERE_FAILED =  "(" + WifiDirectShareTaskMetaData.TASK_STATE + " == " + WifiDirectShareTask.STATE_FAILURE  								
+												+ " OR " + WifiDirectShareTaskMetaData.TASK_STATE + " == " + WifiDirectShareTask.STATE_ABORTED  
+								 				+ " OR " + WifiDirectShareTaskMetaData.TASK_STATE + " == " + WifiDirectShareTask.STATE_REJECTED 
+								 				+ " OR " + WifiDirectShareTaskMetaData.TASK_STATE + " == " + WifiDirectShareTask.STATUS_FORBIDDEN + ")";
+	public static final String WHERE_INBOUND =  "(" + WifiDirectShareTaskMetaData.TASK_TYPE + " == " + WifiDirectShareTask.TYPE_OPPS_PUSH
+                   									 + " OR "  + WifiDirectShareTaskMetaData.TASK_TYPE + " == " + WifiDirectShareTask.TYPE_OPPC_PULL + ")";
+    public static final String WHERE_OUTBOUND = "(" + WifiDirectShareTaskMetaData.TASK_TYPE + " == " + WifiDirectShareTask.TYPE_OPPS_PULL
+                    							+ " OR "  + WifiDirectShareTaskMetaData.TASK_TYPE + " == " + WifiDirectShareTask.TYPE_OPPC_PUSH + ")";
+    // int mScanned;
+}
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/share/WifiDirectShareTask.java
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/share/WifiDirectShareTask.java	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/share/WifiDirectShareTask.java	(版本 25821)
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+package com.oppo.wifidirect.share;
+import android.content.ContentValues;
+import android.database.Cursor;
+import android.net.Uri;
+import android.provider.BaseColumns;
+import java.util.Map.Entry;
+import java.util.Set;
+/**
+ * TODO [OPP] total / done will be received from update event, need to keep in db ?
+ */
+public class WifiDirectShareTask {
+    public static final int ID_NULL = -519;
+    public static final int TYPE_OPPC_GROUP_START = 0;
+    public static final int TYPE_OPPC_PUSH = TYPE_OPPC_GROUP_START + 1;
+    public static final int TYPE_OPPC_PULL = TYPE_OPPC_GROUP_START + 2;
+//#ifdef VENDOR_EDIT
+//wenjie.Liu@Prd.SysApp.PowerManager, 2013/01/24, Add for :OppcPush
+	public static final int TYPE_OPPC_EXCHANGE	= TYPE_OPPC_GROUP_START + 3;    
+//#endif /* VENDOR_EDIT */
+    public static final int TYPE_OPPC_GROUP_END = TYPE_OPPC_GROUP_START + 9;
+    public static final int TYPE_OPPS_GROUP_START = 10;
+    public static final int TYPE_OPPS_PUSH = TYPE_OPPS_GROUP_START + 1;
+    public static final int TYPE_OPPS_PULL = TYPE_OPPS_GROUP_START + 2;
+//#ifdef VENDOR_EDIT
+//wenjie.Liu@Prd.SysApp.PowerManager, 2013/01/24, Add for :OppsPush
+	public static final int TYPE_OPPS_EXCHANGE	= TYPE_OPPS_GROUP_START + 3;    
+//#endif /* VENDOR_EDIT */
+    public static final int TYPE_OPPS_GROUP_END = TYPE_OPPS_GROUP_START + 9;
+    public static final int TYPE_BIPI_GROUP_START = 20;
+    public static final int TYPE_BIPI_PUSH = TYPE_BIPI_GROUP_START + 1;
+    public static final int TYPE_BIPI_GROUP_END = TYPE_BIPI_GROUP_START + 9;
+    public static final int TYPE_BIPR_GROUP_START = 30;
+    public static final int TYPE_BIPR_PUSH = TYPE_BIPR_GROUP_START + 1;
+    public static final int TYPE_BIPR_GROUP_END = TYPE_BIPR_GROUP_START + 9;
+    public static final int STATE_PENDING = 1; // initial: user confirmed
+    public static final int STATE_REJECTING = 2; // temp: rejecting => rejected
+    public static final int STATE_ABORTING = 3;// temp: aborting => aborted
+    public static final int STATE_ONGOING = 4; // temp: ongoing => failure /
+    // success
+    public static final int STATE_REJECTED = 5; // finish - rejected
+    public static final int STATE_ABORTED = 6; // finish - aborted
+    public static final int STATE_FAILURE = 7; // finish - failure
+    public static final int STATE_SUCCESS = 8; // finish - success
+    public static final int STATE_CLEARED = 9; // cleared - cleared by user
+//#ifdef VENDOR_EDIT
+//wenjie.Liu@Prd.SysApp.PowerManager, 2013/01/24, Add for :transfort state
+    public static final int	STATE_ERROR_SDCARD_FULL = 10 ;	//failed for SD card full
+	public static final int	STATUS_FORBIDDEN		= 97;	//Forbidden - operation is understood but refused
+	public static final int	STATE_DELETED			= 98;	//ongoing but aborted--so it will be deleted
+	public static final int	STATE_REMOVED			= 99;	//success, but removed by user
+//#endif /* VENDOR_EDIT */
+    /**
+     * Select Condition
+     */
+    // finished task: SUCCESS or FAILURE
+    public static final String SC_FINISHED_TASK = WifiDirectShareTaskMetaData.TASK_STATE + " in ("
+            + WifiDirectShareTask.STATE_SUCCESS + "," + WifiDirectShareTask.STATE_FAILURE + ")";
+    // incoming task: server-push + client-pull
+    public static final String SC_INCOMING_TASK = WifiDirectShareTaskMetaData.TASK_TYPE + " in ("
+            + WifiDirectShareTask.TYPE_OPPS_PUSH + "," + WifiDirectShareTask.TYPE_OPPC_PULL + ","
+            + WifiDirectShareTask.TYPE_BIPR_PUSH + ")";
+    // outgoing task: server-pull + client-push
+    public static final String SC_OUTGOING_TASK = WifiDirectShareTaskMetaData.TASK_TYPE + " in ("
+            + WifiDirectShareTask.TYPE_OPPC_PUSH + "," + WifiDirectShareTask.TYPE_OPPS_PULL + ","
+            + WifiDirectShareTask.TYPE_BIPI_PUSH + ")";
+    /**
+     * Bluetooth Share Task Metadata
+ //#ifndef VENDOR_EDIT
+ //kecheng.Shang@SysApp.BT, 2013/05/03, Remove for 
+ /*
+    public interface WifiDirectShareTaskMetaData extends BaseColumns {
+        String TABLE_NAME = "share_tasks";
+        Uri CONTENT_URI = Uri.parse("content://" + WifiDirectShareProvider.AUTHORITY + "/" + TABLE_NAME);
+        String CONTENT_TYPE = "vnd.android.cursor.dir/vnd.WifiDirect.share.task";
+        String CONTENT_ITEM_TYPE = "vnd.android.cursor.item/vnd.WifiDirect.share.task";
+        String DEFAULT_SORT_ORDER = "modified DESC";
+        // metadata
+        String TASK_TYPE = "type";
+        String TASK_STATE = "state";
+        String TASK_RESULT = "result";
+        // request
+        String TASK_OBJECT_NAME = "name";
+        String TASK_OBJECT_URI = "uri";
+        String TASK_OBJECT_FILE = "data";
+        String TASK_MIMETYPE = "mime";
+        String TASK_PEER_NAME = "peer_name";
+        String TASK_PEER_ADDR = "peer_addr";
+        // progress
+        String TASK_TOTAL_BYTES = "total";
+        String TASK_DONE_BYTES = "done";
+        // timestamp
+        String TASK_CREATION_DATE = "creation";
+        String TASK_MODIFIED_DATE = "modified";
+        String TASK_IS_HANDOVER = "ishandover";
+    }
+    */
+    //#endif /* VENDOR_EDIT */
+    public Uri getTaskUri() {
+        if (this.mId == ID_NULL) {
+            throw new IllegalStateException("null id task can't get uri");
+        } else {
+            return Uri.withAppendedPath(WifiDirectShareTaskMetaData.CONTENT_URI, Integer.toString(this.mId));
+        }
+    }
+    // metadata
+    private int mId = ID_NULL;
+    private int mType;
+    private int mState;
+    private String mResult;
+    private String mData;
+    private boolean mIsHandover;
+    // request
+    private String mObjectName;
+    private String mObjectUri;
+    private String mMimeType;
+    private String mPeerName;
+   // private String mPeerAddr;
+    // progress
+    private long mTotalBytes;
+    private long mDoneBytes;
+    // timestamp
+    private long mCreationDate = 0;
+    private long mModifiedDate = 0;
+    public WifiDirectShareTask(int type) {
+        this.mType = type;
+    }
+    public WifiDirectShareTask(Cursor cursor) {
+        this.mId = cursor.getInt(cursor.getColumnIndexOrThrow(WifiDirectShareTaskMetaData._ID));
+        this.mType = cursor.getInt(cursor.getColumnIndexOrThrow(WifiDirectShareTaskMetaData.TASK_TYPE));
+        this.mState = cursor.getInt(cursor.getColumnIndexOrThrow(WifiDirectShareTaskMetaData.TASK_STATE));
+      //  this.mResult = cursor.getString(cursor.getColumnIndexOrThrow(WifiDirectShareTaskMetaData.TASK_RESULT));
+        this.mObjectName = cursor.getString(cursor.getColumnIndexOrThrow(WifiDirectShareTaskMetaData.TASK_OBJECT_NAME));
+      //  this.mObjectUri = cursor.getString(cursor.getColumnIndexOrThrow(WifiDirectShareTaskMetaData.TASK_OBJECT_URI));
+        this.mData = cursor.getString(cursor.getColumnIndexOrThrow(WifiDirectShareTaskMetaData.TASK_OBJECT_FILE));
+        this.mMimeType = cursor.getString(cursor.getColumnIndexOrThrow(WifiDirectShareTaskMetaData.TASK_MIMETYPE));
+      //  this.mPeerName = cursor.getString(cursor.getColumnIndexOrThrow(WifiDirectShareTaskMetaData.TASK_PEER_NAME));
+ //       this.mPeerAddr = cursor.getString(cursor.getColumnIndexOrThrow(WifiDirectShareTaskMetaData.TASK_PEER_ADDR));
+        this.mTotalBytes = cursor.getLong(cursor.getColumnIndexOrThrow(WifiDirectShareTaskMetaData.TASK_TOTAL_BYTES));
+      //  this.mDoneBytes = cursor.getLong(cursor.getColumnIndexOrThrow(WifiDirectShareTaskMetaData.TASK_DONE_BYTES));
+       // this.mCreationDate = cursor.getLong(cursor.getColumnIndexOrThrow(WifiDirectShareTaskMetaData.TASK_CREATION_DATE));
+        this.mModifiedDate = cursor.getLong(cursor.getColumnIndexOrThrow(WifiDirectShareTaskMetaData.TASK_MODIFIED_DATE));
+       // this.mIsHandover = (cursor.getLong(cursor.getColumnIndexOrThrow(WifiDirectShareTaskMetaData.TASK_IS_HANDOVER)) == 1);  
+    }
+    /**
+     * create ContentValues for ContentProvider operations
+     *
+     * @return
+     */
+    public ContentValues getContentValues() {
+        ContentValues values = new ContentValues();
+        // existing record
+        if (this.mId != ID_NULL) {
+            values.put(WifiDirectShareTaskMetaData._ID, this.mId);
+        }
+        if (this.mCreationDate != 0) {
+            values.put(WifiDirectShareTaskMetaData.TASK_CREATION_DATE, this.mCreationDate);
+        }
+        if (this.mModifiedDate != 0) {
+            values.put(WifiDirectShareTaskMetaData.TASK_MODIFIED_DATE, this.mModifiedDate);
+        }
+        values.put(WifiDirectShareTaskMetaData.TASK_TYPE, this.mType);
+        values.put(WifiDirectShareTaskMetaData.TASK_STATE, this.mState);
+        values.put(WifiDirectShareTaskMetaData.TASK_RESULT, this.mResult);
+   //     values.put(WifiDirectShareTaskMetaData.TASK_IS_HANDOVER, (this.mIsHandover == true)?1:0);
+        values.put(WifiDirectShareTaskMetaData.TASK_OBJECT_NAME, this.mObjectName);
+        values.put(WifiDirectShareTaskMetaData.TASK_OBJECT_URI, this.mObjectUri);
+        values.put(WifiDirectShareTaskMetaData.TASK_OBJECT_FILE, this.mData);
+        values.put(WifiDirectShareTaskMetaData.TASK_MIMETYPE, this.mMimeType);
+        values.put(WifiDirectShareTaskMetaData.TASK_PEER_NAME, this.mPeerName);
+  //      values.put(WifiDirectShareTaskMetaData.TASK_PEER_ADDR, this.mPeerAddr);
+        values.put(WifiDirectShareTaskMetaData.TASK_TOTAL_BYTES, this.mTotalBytes);
+        values.put(WifiDirectShareTaskMetaData.TASK_DONE_BYTES, this.mDoneBytes);
+        return values;
+    }
+    public String getPrintableString() {
+        StringBuilder res = new StringBuilder();
+        ContentValues cv = this.getContentValues();
+        Set<Entry<String, Object>> set = cv.valueSet();
+        for (Entry<String, Object> e : set) {
+            res.append("[").append(e.getKey()).append("=").append(e.getValue()).append("]");
+        }
+        return res.toString();
+    }
+    public boolean isOppcTask() {
+        return (TYPE_OPPC_GROUP_START < this.mType && this.mType < TYPE_OPPC_GROUP_END);
+    }
+    public boolean isOppsTask() {
+        return (TYPE_OPPS_GROUP_START < this.mType && this.mType < TYPE_OPPS_GROUP_END);
+    }
+//#ifndef VENDOR_EDIT
+//wenjie.Liu@Prd.SysApp.PowerManager, 2013/01/24, Modify for : extend Direction
+/*
+    public static enum Direction {
+        in, out
+    };
+*/
+//#else /* VENDOR_EDIT */
+    public static enum Direction {
+        in, out, ex
+    };    
+//#endif /* VENDOR_EDIT */
+    public Direction getDirection() {
+        switch (this.mType) {
+            case WifiDirectShareTask.TYPE_OPPC_PULL:
+            case WifiDirectShareTask.TYPE_OPPS_PUSH:
+            case WifiDirectShareTask.TYPE_BIPR_PUSH:
+                return Direction.in; // R.drawable.bluetooth_opp_pull_anim0;
+            case WifiDirectShareTask.TYPE_OPPC_PUSH:
+            case WifiDirectShareTask.TYPE_OPPS_PULL:
+            case WifiDirectShareTask.TYPE_BIPI_PUSH:
+                return Direction.out; // R.drawable.bluetooth_opp_push_anim0;
+            //#ifndef VENDOR_EDIT
+            //wenjie.Liu@Prd.SysApp.PowerManager, 2013/01/24, Modify for : extend Direction
+            /*
+            default:
+                return Direction.out;            
+            */
+            //#else /* VENDOR_EDIT */
+			case WifiDirectShareTask.TYPE_OPPC_EXCHANGE:
+			case WifiDirectShareTask.TYPE_OPPS_EXCHANGE:
+			default:
+    			return Direction.ex; // TODO [OPP] need exchange icon                
+            //#endif /* VENDOR_EDIT */
+        }
+    }
+    /**********************************************************************************************************
+     * Getter / Setter
+     **********************************************************************************************************/
+    public boolean isHandover() {
+        return mIsHandover;
+    }
+    public void setHandover(boolean isHandover) {
+        this.mIsHandover = isHandover;
+    }
+    public int getState() {
+        return this.mState;
+    }
+    public void setState(int state) {
+        this.mState = state;
+    }
+    public String getResult() {
+        return this.mResult;
+    }
+    public void setResult(String result) {
+        this.mResult = result;
+    }
+    public String getObjectName() {
+        return this.mObjectName;
+    }
+    public void setObjectName(String objectName) {
+        this.mObjectName = objectName;
+    }
+    public String getObjectUri() {
+        return this.mObjectUri;
+    }
+    public void setObjectUri(String objectUri) {
+        this.mObjectUri = objectUri;
+    }
+    public String getMimeType() {
+        return this.mMimeType;
+    }
+    public void setMimeType(String mimeType) {
+        if (mimeType != null) {
+            // MIME type matching in the Android framework is case-sensitive
+            // (unlike formal RFC MIME types).
+            // As a result, you should always specify MIME types using lowercase
+            // letters.
+            this.mMimeType = mimeType.toLowerCase();
+        } else {
+            this.mMimeType = mimeType;
+        }
+    }
+    public String getPeerName() {
+        return this.mPeerName;
+    }
+    public void setPeerName(String peerName) {
+        this.mPeerName = peerName;
+    }
+   // public String getPeerAddr() {
+   //     return this.mPeerAddr;
+   // }
+    //public void setPeerAddr(String peerAddr) {
+    //    this.mPeerAddr = peerAddr;
+    //}
+    public long getTotalBytes() {
+        return this.mTotalBytes;
+    }
+    public void setTotalBytes(long totalBytes) {
+        this.mTotalBytes = totalBytes;
+    }
+    public long getDoneBytes() {
+        return this.mDoneBytes;
+    }
+    public void setDoneBytes(long doneBytes) {
+        this.mDoneBytes = doneBytes;
+    }
+    public long getCreationDate() {
+        return this.mCreationDate;
+    }
+    public void setCreationDate(long creationDate) {
+        this.mCreationDate = creationDate;
+    }
+    public long getModifiedDate() {
+        return this.mModifiedDate;
+    }
+    public void setModifiedDate(long modifiedDate) {
+        this.mModifiedDate = modifiedDate;
+    }
+    public int getId() {
+        return this.mId;
+    }
+    public void setId(int id) {
+        this.mId = id;
+    }
+    public int getType() {
+        return this.mType;
+    }
+    public String getData() {
+        return this.mData;
+    }
+    public void setData(String data) {
+        this.mData = data;
+    }
+//#ifdef VENDOR_EDIT
+//wenjie.Liu@Prd.SysApp.PowerManager, 2013/01/24, Add for :check Opp Direction
+	public static Direction checkDirection(int type){
+		switch( type ){
+			case WifiDirectShareTask.TYPE_OPPC_PULL:
+			case WifiDirectShareTask.TYPE_OPPS_PUSH:
+				return Direction.in; //R.drawable.bluetooth_opp_pull_anim0;
+			case WifiDirectShareTask.TYPE_OPPC_PUSH:
+			case WifiDirectShareTask.TYPE_OPPS_PULL:
+				return Direction.out; //R.drawable.bluetooth_opp_push_anim0;
+			case WifiDirectShareTask.TYPE_OPPC_EXCHANGE:
+			case WifiDirectShareTask.TYPE_OPPS_EXCHANGE:
+			default:
+				return Direction.ex; // TODO [OPP] need exchange icon
+		}
+	}    
+//#endif /* VENDOR_EDIT */    
+}
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/share/OppTransferActivity.java
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/share/OppTransferActivity.java	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/share/OppTransferActivity.java	(版本 25821)
+/************************************************************************************
+** File: - ..\mediatek\source\packages\Bluetooth\profiles\opp\src\com\mediatek\bluetooth\opp\mmi\OppTransferActivity.java
+** VENDOR_EDIT
+** Copyright (C), 2008-2012, OPPO Mobile Comm Corp., Ltd
+** 
+** Description: 
+**      android bluetooth opp transfer activity
+** 
+** Version: 0.1
+** Date created: 15:44:24,18/08/2011
+** Author: Jiehong.Tang@CommSrv.BT
+** 
+** --------------------------- Revision History: --------------------------------
+** 	<author>	<data>			<desc>
+** 
+************************************************************************************/
+/*
+ * Copyright (c) 2008-2009, Motorola, Inc.
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * - Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * - Neither the name of the Motorola, Inc. nor the names of its contributors
+ * may be used to endorse or promote products derived from this software
+ * without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package com.oppo.wifidirect.share;
+import com.oppo.wifidirect.R;
+//import android.bluetooth.BluetoothAdapter;
+//import android.bluetooth.BluetoothDevice;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.Handler;
+import android.util.Log;
+import android.view.View;
+import android.widget.TextView;
+import android.widget.Toast;
+import android.database.ContentObserver;
+import android.widget.ProgressBar;
+import com.android.internal.app.AlertActivity;
+import com.android.internal.app.AlertController;
+import android.app.NotificationManager;
+import android.text.format.Formatter;
+import android.provider.Settings;
+//import com.oppo.os.OppoEnvironment;
+import android.os.Environment;
+import android.content.ContentResolver;
+import android.database.Cursor;
+//import com.mediatek.bluetooth.share.BluetoothShareTask;
+//import com.mediatek.bluetooth.share.BluetoothShareTask.BluetoothShareTaskMetaData;
+//import com.mediatek.bluetooth.opp.adp.OppManager;
+//import com.mediatek.bluetooth.opp.adp.OppConstants;
+/**
+ * Handle all transfer related dialogs: -Ongoing transfer -Receiving one file
+ * dialog -Sending one file dialog -sending multiple files dialog -Complete
+ * transfer -receive -receive success, will trigger corresponding handler
+ * -receive fail dialog -send -send success dialog -send fail dialog -Other
+ * dialogs - - DIALOG_RECEIVE_ONGOING will transition to
+ * DIALOG_RECEIVE_COMPLETE_SUCCESS or DIALOG_RECEIVE_COMPLETE_FAIL
+ * DIALOG_SEND_ONGOING will transition to DIALOG_SEND_COMPLETE_SUCCESS or
+ * DIALOG_SEND_COMPLETE_FAIL
+ */
+public class OppTransferActivity extends AlertActivity implements
+        DialogInterface.OnClickListener {
+    private Uri mUri;
+private static final String TAG = "OppTransferActivity";
+    // ongoing transfer-0 complete transfer-1
+    boolean mIsComplete;
+    private OppTransferInfo mTransInfo;
+    private ProgressBar mProgressTransfer;
+    private TextView mPercentView;
+    private AlertController.AlertParams mPara;
+    private View mView = null;
+    private TextView mLine1View, mLine2View, mLine3View, mLine5View, mLine_DirView;
+    private int mWhichDialog;
+   // private BluetoothAdapter mAdapter;
+    // Dialogs definition:
+    // Receive progress dialog
+    //public static final int DIALOG_RECEIVE_ONGOING = 0;
+    // Receive complete and success dialog
+    public static final int DIALOG_RECEIVE_COMPLETE_SUCCESS = 1;
+    // Receive complete and fail dialog: will display some fail reason
+    public static final int DIALOG_RECEIVE_COMPLETE_FAIL = 2;
+    // Send progress dialog
+    //public static final int DIALOG_SEND_ONGOING = 3;
+    // Send complete and success dialog
+    public static final int DIALOG_SEND_COMPLETE_SUCCESS = 4;
+    // Send complete and fail dialog: will let user retry
+    public static final int DIALOG_SEND_COMPLETE_FAIL = 5;
+    /** Observer to get notified when the content observer's data changes */
+    //private BluetoothTransferContentObserver mObserver;
+    // do not update button during activity creating, only update when db
+    // changes after activity created
+    private boolean mNeedUpdateButton = false;
+	// add for bug 206957
+	public static OppTransferInfo mSendAgainInfo = null;
+    //private class BluetoothTransferContentObserver extends ContentObserver {
+    //    public BluetoothTransferContentObserver() {
+    //        super(new Handler());
+    //    }
+    //    @Override
+    //    public void onChange(boolean selfChange) {
+    //        OppLog.i("received db changes.");
+    //        mNeedUpdateButton = true;
+    //        updateProgressbar();
+    //    }
+    //}
+    public static final String PHONE_ROOT = Environment.getExternalStorageDirectory().getPath();
+    public static final String MEMORY_CARD_ROOT = Environment.getExternalStorageDirectory().getPath();
+     private static final String SAVE_PATH = "save_path";
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        Intent intent = getIntent();
+        mUri = intent.getData();
+        mTransInfo = new OppTransferInfo();
+        mTransInfo = queryRecord(this, mUri);
+        if (mTransInfo == null || mTransInfo.mID == 0) {
+            Log.e(TAG,"Error: Can not get data from db");
+            finish();
+            return;
+        }
+        mIsComplete = true;
+        displayWhichDialog();
+        // update progress bar for ongoing transfer
+        //if (!mIsComplete) {
+        //    mObserver = new BluetoothTransferContentObserver();
+        //    getContentResolver().registerContentObserver(BluetoothShareTaskMetaData.CONTENT_URI, true,
+        //            mObserver);
+        //}
+      //  mAdapter = BluetoothAdapter.getDefaultAdapter();
+        // Set up the "dialog"
+        setUpDialog();
+		//if (mWhichDialog != DIALOG_SEND_ONGOING && mWhichDialog != DIALOG_RECEIVE_ONGOING) {
+	      removeSelectedRecord(mUri); 
+	    //}
+    }
+    @Override
+    protected void onDestroy() {
+        Log.d(TAG,"onDestroy()");
+      //  if (mObserver != null) {
+      //      getContentResolver().unregisterContentObserver(mObserver);
+      //  }
+        super.onDestroy();
+    }
+    private void displayWhichDialog() {
+        boolean isSuccess = OppTransferInfo.isStatusSuccess(mTransInfo.mState);
+        boolean isComplete = OppTransferInfo.isStatusCompleted(mTransInfo.mState);
+        if (mTransInfo.mDirection == WifiDirectShareTask.Direction.in) {
+            //if (isComplete == true) {
+                if (isSuccess == true) {
+                    // should not go here
+                    mWhichDialog = DIALOG_RECEIVE_COMPLETE_SUCCESS;
+                } else if (isSuccess == false) {
+                    mWhichDialog = DIALOG_RECEIVE_COMPLETE_FAIL;
+                }
+            //} else if (isComplete == false) {
+            //    mWhichDialog = DIALOG_RECEIVE_ONGOING;
+            //}
+        } else if (mTransInfo.mDirection == WifiDirectShareTask.Direction.out) {
+           // if (isComplete == true) {
+                if (isSuccess == true) {
+                    mWhichDialog = DIALOG_SEND_COMPLETE_SUCCESS;
+                } else if (isSuccess == false) {
+                    mWhichDialog = DIALOG_SEND_COMPLETE_FAIL;
+                }
+           // } else if (isComplete == false) {
+           //     mWhichDialog = DIALOG_SEND_ONGOING;
+           // }
+        }
+       Log.i(TAG," WhichDialog/isComplete/failOrSuccess" + mWhichDialog
+                    + isComplete + isSuccess);
+    }
+    private void setUpDialog() {
+        // final AlertController.AlertParams p = mAlertParams;
+        mPara = mAlertParams;
+        mPara.mIconId = android.R.drawable.ic_dialog_info;
+        mPara.mTitle = getString(R.string.download_title);
+     //   if ((mWhichDialog == DIALOG_RECEIVE_ONGOING) || (mWhichDialog == DIALOG_SEND_ONGOING)) {
+     //       mPara.mPositiveButtonText = getString(R.string.download_ok);
+     //       mPara.mPositiveButtonListener = this;
+     //       mPara.mNegativeButtonText = getString(R.string.download_cancel);
+     //       mPara.mNegativeButtonListener = this;
+     //   } else
+        if (mWhichDialog == DIALOG_RECEIVE_COMPLETE_SUCCESS) {
+            mPara.mPositiveButtonText = getString(R.string.download_succ_ok);
+            mPara.mPositiveButtonListener = this;
+        } else if (mWhichDialog == DIALOG_RECEIVE_COMPLETE_FAIL) {
+            mPara.mIconId = android.R.drawable.ic_dialog_alert;
+            mPara.mPositiveButtonText = getString(R.string.download_fail_ok);
+            mPara.mPositiveButtonListener = this;
+        } else if (mWhichDialog == DIALOG_SEND_COMPLETE_SUCCESS) {
+            mPara.mPositiveButtonText = getString(R.string.upload_succ_ok);
+            mPara.mPositiveButtonListener = this;
+        } else if (mWhichDialog == DIALOG_SEND_COMPLETE_FAIL) {
+            mPara.mIconId = android.R.drawable.ic_dialog_alert;
+            mPara.mPositiveButtonText = getString(R.string.upload_fail_ok);
+            mPara.mPositiveButtonListener = this;
+            mPara.mNegativeButtonText = getString(R.string.upload_fail_cancel);
+            mPara.mNegativeButtonListener = this;
+        }
+        mPara.mView = createView();
+        setupAlert();
+    }
+    private View createView() {
+	    Log.d(TAG , "createView mNeedUpdateButton ="  + mNeedUpdateButton);
+        mView = getLayoutInflater().inflate(R.layout.file_transfer, null);
+        mProgressTransfer = (ProgressBar)mView.findViewById(R.id.progress_transfer);
+        mPercentView = (TextView)mView.findViewById(R.id.progress_percent);
+        customizeViewContent();
+        // no need update button when activity creating
+        mNeedUpdateButton = false;
+        updateProgressbar();
+        return mView;
+    }
+    /**
+     * customize the content of view
+     */
+    private void customizeViewContent() {
+        String tmp;
+        if (/*mWhichDialog == DIALOG_RECEIVE_ONGOING*/
+                 mWhichDialog == DIALOG_RECEIVE_COMPLETE_SUCCESS) {
+            mLine1View = (TextView)mView.findViewById(R.id.line1_view);
+            tmp = getString(R.string.download_line1, mTransInfo.mDeviceName);
+            mLine1View.setText(tmp);
+            //OPPO LanceYao modify for notification 
+            mLine_DirView = (TextView)mView.findViewById(R.id.line_dir_view);
+			Log.e(TAG,"Error: mTransInfo.mFileName " + mTransInfo.mFileName);
+            tmp = mTransInfo.mFileName.substring(0, mTransInfo.mFileName.lastIndexOf("/"));
+            if (tmp.startsWith(MEMORY_CARD_ROOT)) {
+                tmp = tmp.replaceFirst(MEMORY_CARD_ROOT,
+                    getResources().getString(R.string.bluetooth_save_path_card));
+            } else if (tmp.startsWith(PHONE_ROOT)) {
+                tmp = tmp.replaceFirst(PHONE_ROOT,
+                    getResources().getString(R.string.bluetooth_save_path_phone));
+            }
+            mLine_DirView.setText(getString(R.string.file_save_path, tmp));
+            mLine2View = (TextView)mView.findViewById(R.id.line2_view);
+            tmp = mTransInfo.mFileName.substring(mTransInfo.mFileName.lastIndexOf("/") + 1,
+                mTransInfo.mFileName.length());
+            mLine2View.setText(getString(R.string.download_line2, tmp));
+            //OPPO LanceYao add end
+            mLine3View = (TextView)mView.findViewById(R.id.line3_view);
+            tmp = getString(R.string.download_line3, Formatter.formatFileSize(this,
+                    mTransInfo.mTotalBytes));
+            mLine3View.setText(tmp);
+            mLine5View = (TextView)mView.findViewById(R.id.line5_view);
+           // if (mWhichDialog == DIALOG_RECEIVE_ONGOING) {
+           //     tmp = getString(R.string.download_line5);
+           // } else
+            if (mWhichDialog == DIALOG_RECEIVE_COMPLETE_SUCCESS) {
+                tmp = getString(R.string.download_succ_line5);
+            }
+            mLine5View.setText(tmp);
+        } else if (/*mWhichDialog == DIALOG_SEND_ONGOING*/
+                 mWhichDialog == DIALOG_SEND_COMPLETE_SUCCESS) {
+            mLine1View = (TextView)mView.findViewById(R.id.line1_view);
+            //tmp = getString(R.string.upload_line1, mTransInfo.mDeviceName);
+            tmp= "";
+            mLine1View.setText(tmp);
+            mLine2View = (TextView)mView.findViewById(R.id.line2_view);
+            tmp = getString(R.string.download_line2, mTransInfo.mFileName);
+            mLine2View.setText(tmp);
+            mLine3View = (TextView)mView.findViewById(R.id.line3_view);
+            tmp = getString(R.string.upload_line3, mTransInfo.mFileType, Formatter.formatFileSize(
+                    this, mTransInfo.mTotalBytes));
+            mLine3View.setText(tmp);
+            //#ifdef VENDOR_EDIT
+            //Jiehong.Tang@CommSrv.BT, 2012/01/09, Add for remove file type in dialog
+            mLine3View.setVisibility(View.GONE);   
+            //#endif /* VENDOR_EDIT */
+            mLine_DirView = (TextView)mView.findViewById(R.id.line_dir_view);
+            mLine_DirView.setVisibility(View.GONE);
+            mLine5View = (TextView)mView.findViewById(R.id.line5_view);
+          //  if (mWhichDialog == DIALOG_SEND_ONGOING) {
+          //      tmp = getString(R.string.upload_line5);
+          //  } else
+          if (mWhichDialog == DIALOG_SEND_COMPLETE_SUCCESS) {
+              tmp = getString(R.string.upload_succ_line5);
+            }
+            mLine5View.setText(tmp);
+        } else if (mWhichDialog == DIALOG_RECEIVE_COMPLETE_FAIL) {
+           // if (mTransInfo.mState == WifiDirectShareTask.STATE_ERROR_SDCARD_FULL) {
+           //     mLine1View = (TextView)mView.findViewById(R.id.line1_view);
+            //#ifndef VENDOR_EDIT
+            //Jiehong.Tang@CommSrv.BT, 2012/01/09, Modify for bug 237363       
+				/*android code*/      
+                // tmp = getString(R.string.bt_sm_2_1, mTransInfo.mDeviceName);
+				/*oppo code */  
+				//#else
+           //       ContentResolver contentResolver = this.getContentResolver();
+           //       String tmpPath = Settings.Secure.getString(contentResolver, SAVE_PATH);
+           //       if(tmpPath.equals("Phone")){
+           //           tmp = getString(R.string.bt_sm_2_1_phone, mTransInfo.mDeviceName);
+           //       }else if(tmpPath.equals("Card")){
+           //           tmp = getString(R.string.bt_sm_2_1, mTransInfo.mDeviceName);
+           //       }else{
+		   //		       tmp = this.getString(R.string.status_unknown_error);
+           //            Log.w(TAG,"SD memory full,but not Card not Phone");    
+           //       }                                            
+            //#endif /* VENDOR_EDIT */
+           //     mLine1View.setText(tmp);
+           //     mLine2View = (TextView)mView.findViewById(R.id.line2_view);
+           //     tmp = getString(R.string.download_fail_line2, mTransInfo.mFileName);
+           //     mLine2View.setText(tmp);
+           //     mLine3View = (TextView)mView.findViewById(R.id.line3_view);
+           //     tmp = getString(R.string.bt_sm_2_2, Formatter.formatFileSize(this,
+           //             mTransInfo.mTotalBytes));
+           //     mLine3View.setText(tmp);
+           // } else {
+                mLine1View = (TextView)mView.findViewById(R.id.line1_view);
+                tmp = getString(R.string.download_fail_line1);
+                mLine1View.setText(tmp);
+                mLine2View = (TextView)mView.findViewById(R.id.line2_view);
+				if(mTransInfo.mFileName.contains("/")){
+					tmp = mTransInfo.mFileName.substring(mTransInfo.mFileName.lastIndexOf("/")+1);
+				}else{
+					tmp = mTransInfo.mFileName;
+				}
+                mLine2View.setText(getString(R.string.download_fail_line2, tmp));
+                mLine3View = (TextView)mView.findViewById(R.id.line3_view);
+                tmp = getString(R.string.download_fail_line3, getStatusDescription(this, mTransInfo.mState));
+                mLine3View.setText(tmp);
+         //   }
+            mLine_DirView = (TextView)mView.findViewById(R.id.line_dir_view);
+            mLine_DirView.setVisibility(View.GONE);
+            mLine5View = (TextView)mView.findViewById(R.id.line5_view);
+            mLine5View.setVisibility(View.GONE);
+        } else if (mWhichDialog == DIALOG_SEND_COMPLETE_FAIL) {
+            mLine1View = (TextView)mView.findViewById(R.id.line1_view);
+            tmp = getString(R.string.upload_fail_line1, mTransInfo.mDeviceName);
+            mLine1View.setText(tmp);
+            mLine2View = (TextView)mView.findViewById(R.id.line2_view);
+            tmp = getString(R.string.upload_fail_line1_2, mTransInfo.mFileName);
+            mLine2View.setText(tmp);
+            mLine3View = (TextView)mView.findViewById(R.id.line3_view);
+            tmp = getString(R.string.download_fail_line3, getStatusDescription(
+                    this, mTransInfo.mState));
+            mLine3View.setText(tmp);
+            mLine5View = (TextView)mView.findViewById(R.id.line5_view);
+            mLine5View.setVisibility(View.GONE);
+            mLine_DirView = (TextView)mView.findViewById(R.id.line_dir_view);
+            mLine_DirView.setVisibility(View.GONE);
+        }
+        if (OppTransferInfo.isStatusError(mTransInfo.mState)) {
+            mProgressTransfer.setVisibility(View.GONE);
+            mPercentView.setVisibility(View.GONE);
+        }
+    }
+    public void onClick(DialogInterface dialog, int which) {
+        switch (which) {
+            case DialogInterface.BUTTON_POSITIVE:
+                if (mWhichDialog == DIALOG_RECEIVE_COMPLETE_SUCCESS) {
+                    // "Open" - open receive file
+                   OppHistoryActivity.openReceivedFile(this, mTransInfo.mFileName,
+                            mTransInfo.mFileType, mTransInfo.mTimeStamp, mUri);
+                    // clear correspondent notification item
+                   // ((NotificationManager)getSystemService(NOTIFICATION_SERVICE))
+                   //         .cancel(mTransInfo.mID);
+                } else if (mWhichDialog == DIALOG_SEND_COMPLETE_FAIL) {
+					//if(!mAdapter.isEnabled() && mSendAgainInfo == null)
+					//{
+					//	((NotificationManager)getSystemService(NOTIFICATION_SERVICE))
+                    //        .cancel(mTransInfo.mID);
+					//	mSendAgainInfo = mTransInfo;
+					//	mAdapter.enable();
+					//}
+					//else if(mSendAgainInfo != null)
+					//{
+					//	Toast.makeText(this, this.getString(R.string.ErrorTooManyRequests), 
+					//		Toast.LENGTH_SHORT).show();
+					//	return;
+					//}
+					//else
+					//{
+					//	((NotificationManager)getSystemService(NOTIFICATION_SERVICE))
+                    //        .cancel(mTransInfo.mID);
+					//	 OppTransferUtility.retryTransfer(this, mTransInfo); 
+					//}
+					//#ifdef VENDOR_EDIT
+					//Jiehong.Tang@CommSrv.BT 20110921 add for bug 274615
+					//if(mTransInfo.mDestAddr == null){
+					//	OppLog.e("transfer address is null!");
+					//	return;
+					//}
+					//#endif /*VENDOR_EDIT*/
+                    //BluetoothDevice remoteDevice = mAdapter.getRemoteDevice(mTransInfo.mDestAddr);
+                    // Display toast message
+                    Toast.makeText(
+                            this,
+                            this.getString(R.string.bt_toast_4), Toast.LENGTH_SHORT)
+                            .show();
+                } else if (mWhichDialog == DIALOG_SEND_COMPLETE_SUCCESS) {
+                   // ((NotificationManager)getSystemService(NOTIFICATION_SERVICE))
+                   //         .cancel(mTransInfo.mID);
+                }
+                break;
+            case DialogInterface.BUTTON_NEGATIVE:
+              //  if (mWhichDialog == DIALOG_RECEIVE_ONGOING || mWhichDialog == DIALOG_SEND_ONGOING) {
+                    // "Stop" button
+				//	onTaskCancel(mUri);
+					//#ifdef VENDOR_EDIT
+					//Jiehong.Tang@CommSrv.BT, 2012/01/27, Add for bug 214808
+				//	if(null == mTransInfo)
+				//	{
+					//	break;
+				//	}
+					//#endif /* VENDOR_EDIT */
+                 //  String msg = "";
+                //    if (mWhichDialog == DIALOG_RECEIVE_ONGOING) {
+                 //       msg = getString(R.string.bt_toast_3, mTransInfo.mDeviceName);
+                //    } else if (mWhichDialog == DIALOG_SEND_ONGOING) {
+                //        msg = getString(R.string.bt_toast_6, mTransInfo.mDeviceName);
+                //    }
+                //    Toast.makeText(this, msg, Toast.LENGTH_SHORT).show();
+                //    ((NotificationManager)getSystemService(NOTIFICATION_SERVICE))
+                //            .cancel(mTransInfo.mID);
+                //} else 
+                if (mWhichDialog == DIALOG_SEND_COMPLETE_FAIL) {
+                }
+                break;
+        }
+        finish();
+    }
+    /**
+     * Update progress bar per data got from content provider
+     */
+    private void updateProgressbar() {
+    //    mTransInfo = queryRecord(this, mUri);
+    //    if (mTransInfo == null || mTransInfo.mID == 0) {
+    //        Log.e(TAG,"Error: Can not get data from db");
+    //        return;
+    //    }
+    //    if (mTransInfo.mTotalBytes == 0) {
+    //        // if Max and progress both equal 0, the progress display 100%.
+    //        // Below is to fix it.
+    //        mProgressTransfer.setMax(100);
+    //    } else {
+    //        mProgressTransfer.setMax(mTransInfo.mTotalBytes);
+    //    }
+	//	Log.e(TAG,"onCreate mTransInfo mTotalBytes " + mTransInfo.mTotalBytes+ "mCurrentBytes" + mTransInfo.mCurrentBytes);
+    //    mProgressTransfer.setProgress(mTransInfo.mCurrentBytes);
+//#ifndef VENDOR_EDIT
+//wenjie.Liu@Prd.SysApp.PowerManager, 2013/03/20, Modify for 
+/*
+        mPercentView.setText(OppTransferUtility.formatProgressText(mTransInfo.mTotalBytes,
+                mTransInfo.mCurrentBytes));
+*/
+//#else /* VENDOR_EDIT */
+      //  if (true == OppTransferInfo.isStatusSuccess(mTransInfo.mState)) {
+      //      //show 100% ,OppService.java onObjectChange() mUpdateDbUri dont to update DateBase syn
+      //      mProgressTransfer.setProgress(mTransInfo.mTotalBytes);
+      //      mPercentView.setText(OppTransferUtility.formatProgressText(mTransInfo.mCurrentBytes,
+      //              mTransInfo.mCurrentBytes));    
+      //  } else {        
+      //      mPercentView.setText(OppTransferUtility.formatProgressText(mTransInfo.mTotalBytes,
+      //              mTransInfo.mCurrentBytes));    
+      //  }
+//#endif /* VENDOR_EDIT */
+        // Handle the case when DIALOG_RECEIVE_ONGOING evolve to
+        // DIALOG_RECEIVE_COMPLETE_SUCCESS/DIALOG_RECEIVE_COMPLETE_FAIL
+        // Handle the case when DIALOG_SEND_ONGOING evolve to
+        // DIALOG_SEND_COMPLETE_SUCCESS/DIALOG_SEND_COMPLETE_FAIL
+	//	Log.e(TAG,"updateProgressbar() mIsComplete = " + mIsComplete+ " ; mNeedUpdateButton = " + mNeedUpdateButton);
+	//	Log.e(TAG,"updateProgressbar() OppTransferInfo.isStatusCompleted(mTransInfo.mState) = " + OppTransferInfo.isStatusCompleted(mTransInfo.mState));
+      //  if (!mIsComplete && OppTransferInfo.isStatusCompleted(mTransInfo.mState)
+      //          && mNeedUpdateButton) {
+      //      displayWhichDialog();
+      //      updateButton();
+      //      customizeViewContent();
+      //  }
+    }
+    /**
+     * Update button when one transfer goto complete from ongoing
+     */
+   // private void updateButton() {
+   //     if (mWhichDialog == DIALOG_RECEIVE_COMPLETE_SUCCESS) {
+   //         mAlert.getButton(DialogInterface.BUTTON_NEGATIVE).setVisibility(View.GONE);
+   //         mAlert.getButton(DialogInterface.BUTTON_POSITIVE).setText(
+   //                 getString(R.string.download_succ_ok));
+   //     } else if (mWhichDialog == DIALOG_RECEIVE_COMPLETE_FAIL) {
+   //         mAlert.setIcon(android.R.drawable.ic_dialog_alert);
+   //         mAlert.getButton(DialogInterface.BUTTON_NEGATIVE).setVisibility(View.GONE);
+   //         mAlert.getButton(DialogInterface.BUTTON_POSITIVE).setText(
+   //                 getString(R.string.download_fail_ok));
+   //     } else if (mWhichDialog == DIALOG_SEND_COMPLETE_SUCCESS) {
+   //         mAlert.getButton(DialogInterface.BUTTON_NEGATIVE).setVisibility(View.GONE);
+   //         mAlert.getButton(DialogInterface.BUTTON_POSITIVE).setText(
+   //                 getString(R.string.upload_succ_ok));
+   //     } else if (mWhichDialog == DIALOG_SEND_COMPLETE_FAIL) {
+   //         mAlert.setIcon(android.R.drawable.ic_dialog_alert);
+   //         mAlert.getButton(DialogInterface.BUTTON_POSITIVE).setText(
+   //                 getString(R.string.upload_fail_ok));
+   //         mAlert.getButton(DialogInterface.BUTTON_NEGATIVE).setText(
+   //                 getString(R.string.upload_fail_cancel));
+   //     }
+   // }
+	private void removeSelectedRecord(Uri uri){
+		if(mUri == null){
+			return;
+		}
+		//remove the record from db
+       // OppManager oppManager = OppManager.getInstance(this);
+		OppHistoryActivity.removeSingleRecord(uri, mTransInfo.mDirection,this);
+	}
+	//private void onTaskCancel(Uri uri){
+	//	OppLog.d( "cancel task - uri[" + uri + "]" );
+		// send abort request to OppManager
+	//	OppManager.getInstance( this ).oppAbortTask( uri );
+	//}
+	public static  OppTransferInfo queryRecord(Context context, Uri uri) {
+      //  BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
+        OppTransferInfo info = new OppTransferInfo();
+        Cursor cursor = context.getContentResolver().query(uri, null, null, null, null);
+        if (cursor != null) {
+            if (cursor.moveToFirst()) {
+                info.mID = cursor.getInt(cursor.getColumnIndexOrThrow(WifiDirectShareTaskMetaData._ID));
+                info.mState = cursor.getInt(cursor.getColumnIndexOrThrow(WifiDirectShareTaskMetaData.TASK_STATE));
+                info.mDirection = WifiDirectShareTask.checkDirection(cursor.getInt(cursor
+                        .getColumnIndexOrThrow(WifiDirectShareTaskMetaData.TASK_TYPE)));
+                info.mTotalBytes = cursor.getInt(cursor
+                        .getColumnIndexOrThrow(WifiDirectShareTaskMetaData.TASK_TOTAL_BYTES));
+               // info.mCurrentBytes = cursor.getInt(cursor
+                        //.getColumnIndexOrThrow(BluetoothShareTaskMetaData.TASK_DONE_BYTES));
+                info.mTimeStamp = cursor.getLong(cursor
+                        .getColumnIndexOrThrow(WifiDirectShareTaskMetaData.TASK_MODIFIED_DATE));
+               // info.mDestAddr = cursor.getString(cursor
+                        //.getColumnIndexOrThrow(BluetoothShareTaskMetaData.TASK_PEER_ADDR));
+				if(info.mDirection == WifiDirectShareTask.Direction.in){
+                	info.mFileName = cursor.getString(cursor
+                        .getColumnIndexOrThrow(WifiDirectShareTaskMetaData.TASK_OBJECT_FILE));
+					if (info.mFileName == null) {
+						info.mFileName = cursor.getString(cursor
+                        .getColumnIndexOrThrow(WifiDirectShareTaskMetaData.TASK_OBJECT_NAME));
+					}
+				}else{
+					info.mFileName = cursor.getString(cursor
+                        .getColumnIndexOrThrow(WifiDirectShareTaskMetaData.TASK_OBJECT_NAME));
+				}
+                if (info.mFileName == null) {
+                    info.mFileName = context.getString(R.string.unknown_file);
+                }
+                info.mFileUri = cursor.getString(cursor.getColumnIndexOrThrow(WifiDirectShareTaskMetaData.TASK_OBJECT_URI));
+				try{
+	                if (info.mFileUri != null) {
+	                    Uri u = Uri.parse(info.mFileUri);
+	                    info.mFileType = context.getContentResolver().getType(u);
+	                } else {
+	                    Uri u = Uri.parse(info.mFileName);
+	                    info.mFileType = context.getContentResolver().getType(u);
+	                }
+				}catch(Exception e){
+				}
+                if (info.mFileType == null) {
+                    info.mFileType = cursor.getString(cursor
+                            .getColumnIndexOrThrow(WifiDirectShareTaskMetaData.TASK_MIMETYPE));
+                }
+               // info.mDeviceName = cursor.getString(cursor
+               //         .getColumnIndexOrThrow(WifiDirectShareTaskMetaData.TASK_PEER_NAME));
+               Log.d(TAG,"Get data from db: name " + info.mFileName + " type " + info.mFileType );
+            }
+            cursor.close();
+        } else {
+            info = null;
+            Log.d(TAG,"BluetoothOppManager Error: not got data from db for uri:" + uri);
+        }
+        return info;
+    }
+private static String getStatusDescription(Context mContext, int statusCode) {
+        String ret;
+        if (statusCode == WifiDirectShareTask.STATE_PENDING) {
+            ret = mContext.getString(R.string.status_pending);
+        } else if (statusCode == WifiDirectShareTask.STATE_ONGOING) {
+            ret = mContext.getString(R.string.status_running);
+        } else if (statusCode == WifiDirectShareTask.STATE_SUCCESS) {
+            ret = mContext.getString(R.string.status_success);
+        } else if (statusCode == WifiDirectShareTask.STATE_REJECTED) {
+            ret = mContext.getString(R.string.status_canceled);
+        } else if (statusCode == WifiDirectShareTask.STATE_ABORTED) {
+            ret = mContext.getString(R.string.status_canceled);
+        } else if (statusCode == WifiDirectShareTask.STATUS_FORBIDDEN) {
+            ret = mContext.getString(R.string.status_forbidden);
+        }else {
+            ret = mContext.getString(R.string.status_unknown_error);
+        }
+        return ret;
+    }  
+}
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/share/Utils.java
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/share/Utils.java	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/share/Utils.java	(版本 25821)
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+package com.oppo.wifidirect.share;
+import com.oppo.wifidirect.R;
+import android.content.Context;
+import android.net.Uri;
+//import com.mediatek.bluetooth.R;
+import android.util.Log;
+//import com.mediatek.bluetooth.util.SystemUtils;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.text.SimpleDateFormat;
+import java.util.Calendar;
+import java.util.regex.*;
+import android.util.Patterns;
+//#ifdef VENDOR_EDIT
+//wenjie.Liu@Prd.SysApp.PowerManager, 2013/01/25, Add for : 
+import android.os.Environment;    
+//import com.mediatek.bluetooth.Options;
+import android.os.StatFs;
+import android.os.SystemClock;
+import java.util.Random;
+//#endif /* VENDOR_EDIT */
+/**
+ *
+ */
+public class Utils {
+    private static final SimpleDateFormat TIME_FILENAME_FORMATER = new SimpleDateFormat(
+            "yyyyMMdd_HHmmss");
+    private static final String TAG = "wifi_direct_file_transfer"  ;      
+	public static String getStorageDirectory( Context context ){
+		return SystemUtils.getReceivedFilePath( context );
+		//Environment.getExternalStorageDirectory().getPath() + "/" + Options.DEFAULT_STORAGE_FOLDER;
+	}
+		public static String getStorageDirectory( Context context, String hint ){
+		return SystemUtils.getReceivedFilePath( context, hint);
+		//Environment.getExternalStorageDirectory().getPath() + "/" + Options.DEFAULT_STORAGE_FOLDER;
+	}
+	//#endif VENDOR_EDIT
+    /**
+     * get a valid (can be created) filename for given hint this function will
+     * make all parent dirs for the final file.
+     *
+     * @param context
+     * @param hint
+     * @return
+     */
+    public static String getValidStoragePath(Context context, String hint) {
+        // default: dir + hint (but hint maybe invalid. e.g. "@#$%^? )
+        String storageDirectory = SystemUtils.getReceivedFilePath(context);
+        File dir = new File(storageDirectory);
+        // make sure dir is ready
+        if (!dir.exists()) {
+            dir.mkdirs();
+        }
+        String result = Utils.isValidFilename(dir, hint);
+        // hint is valid
+        if (result != null) {
+            return result;
+        } else {
+            Log.i(TAG ,"invalid filename hint:[" + hint + "]");
+        }
+        // use current date for filename
+        String now = TIME_FILENAME_FORMATER.format(Calendar.getInstance().getTime());
+        int idx = hint.lastIndexOf(".");
+        if (idx > -1) {
+            hint = now + hint.substring(idx);
+            result = Utils.isValidFilename(dir, hint);
+            if (result != null) {
+                return result;
+            }
+        }
+        return storageDirectory + "/" + now;
+    }
+    private static String isValidFilename(File dir, String name) {
+        if (dir == null || name == null) {
+            return null;
+        }
+        File f = new File(dir, name);
+        if (!f.exists()) {
+            try {
+                boolean created = f.createNewFile();
+                if (created) {
+                    f.delete();
+                    if (!f.getParent().equals(dir.getPath())) {
+                        return null;
+                    } else {
+                        return f.getAbsolutePath();
+                    }
+                } else {
+                    return null;
+                }
+            } catch (IOException ex) {
+                return null;
+            }
+        }
+        // if the new file's parent and the given parent is differ then the file
+        // name is wrong
+        if (f.getParent().equals(dir.getPath())) {
+            return f.getAbsolutePath();
+        } else {
+            return null;
+        }
+    }
+	//#ifdef VENDOR_EDIT
+	//Jiehong.Tang@CommSrv.BT, 2012/01/27, Add for storage
+	/**
+	 * get the writable available size of default directory
+	 */
+	/*public static long getStorageAvailableSize(){
+		// storage must be mounted and writable
+		if( Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED) ){
+			String folder = Environment.getExternalStorageDirectory().getPath() + "/" + Options.DEFAULT_STORAGE_FOLDER;
+			File ff = new File( folder );
+			if( !ff.isDirectory() && !ff.mkdirs() ){
+				Log.i( TAG,"setup bluetooth default storage folder fail: " + ff.getPath() );
+				return -1;
+			}
+			StatFs stat = new StatFs( ff.getPath() );
+			// -4 for file system block for new file
+			return ((long)stat.getBlockSize()) * ((long)(stat.getAvailableBlocks()-4));
+		}
+		else {
+			Log.i(TAG, "external storage is no available (not in MEDIA_MOUNTED state)" );
+			return -1;
+		}
+	}
+	*/
+//#ifdef VENDOR_EDIT
+//JiangLin.Ma@Prd.SysApp.BT, 2012/09/12, Add for change file save path
+    public static String generateFileSavePath( Context context, String hint ) {
+    	String filename = null;
+        File base = null;
+        StatFs stat = null;
+		if (hint == null) {
+            // should not happen. It must be pre-rejected
+            return null;
+        }
+        filename = choosefilename(hint);
+		String storageDirectory = Utils.getStorageDirectory( context, filename);
+		//String storageDirectory =SystemUtils.getReceivedFilePath( context );
+        base = new File(storageDirectory);
+        Log.i(TAG,"base path:" + base.getPath());
+        if (!base.isDirectory() && !base.mkdir()) {
+           Log.d(TAG,"Receive File aborted - can't create base directory "
+                        + base.getPath());
+            return null;
+        }
+        String extension = null;
+        int dotIndex = filename.lastIndexOf(".");
+        if (dotIndex < 0) {
+            // should not happen. It must be pre-rejected
+            Log.i(TAG,"no extension");
+            filename = filename;
+        } else {
+            extension = filename.substring(dotIndex);
+            filename = filename.substring(0, dotIndex);
+        }
+        filename = base.getPath() + File.separator + filename;
+        // Generate a unique filename, create the file, return it.
+        String fullfilename = chooseUniquefilename(filename, extension);
+        Log.d(TAG,"Generated received filename " + fullfilename);
+		return fullfilename;
+    }
+//#ifdef VENDOR_EDIT
+//Jiehong.Tang@CommSrv.BT 20120103 add for choose Unique filename
+private static String chooseUniquefilename(String filename, String extension) {
+        String fullfilename = filename + extension;
+        if(null == extension)
+        {
+            fullfilename = filename;
+        }
+        if (!new File(fullfilename).exists()) {
+            return fullfilename;
+        }
+        filename = filename + "-";
+        /*
+         * This number is used to generate partially randomized filenames to
+         * avoid collisions. It starts at 1. The next 9 iterations increment it
+         * by 1 at a time (up to 10). The next 9 iterations increment it by 1 to
+         * 10 (random) at a time. The next 9 iterations increment it by 1 to 100
+         * (random) at a time. ... Up to the point where it increases by
+         * 100000000 at a time. (the maximum value that can be reached is
+         * 1000000000) As soon as a number is reached that generates a filename
+         * that doesn't exist, that filename is used. If the filename coming in
+         * is [base].[ext], the generated filenames are [base]-[sequence].[ext].
+         */
+        Random rnd = new Random(SystemClock.uptimeMillis());
+        int sequence = 1;
+        for (int magnitude = 1; magnitude < 1000000000; magnitude *= 10) {
+            for (int iteration = 0; iteration < 9; ++iteration) {
+                fullfilename = filename + sequence + extension;
+                if(null == extension)
+                {
+                    fullfilename = filename + sequence;
+                }
+                if (!new File(fullfilename).exists()) {
+                    return fullfilename;
+                }
+                Log.d(TAG,"file with sequence number " + sequence + " exists");
+                sequence += rnd.nextInt(magnitude) + 1;
+            }
+        }
+        return null;
+    }
+//#ifdef VENDOR_EDIT
+//Jiehong.Tang@CommSrv.BT, 2012/02/09, Add for get file name for too long path
+      public static String oppochooseUniquefilename(String filename, String extension){
+        return chooseUniquefilename(filename, extension);
+      }  
+//#endif /* VENDOR_EDIT */
+    private static String choosefilename(String hint) {
+        String filename = null;
+        // First, try to use the hint from the application, if there's one
+        if (filename == null && !(hint == null) && !hint.endsWith("/") && !hint.endsWith("\\")) {
+            // Prevent abuse of path backslashes by converting all backlashes '\\' chars
+            // to UNIX-style forward-slashes '/'
+            hint = hint.replace('\\', '/');
+            Log.d(TAG,"getting filename from hint");
+            int index = hint.lastIndexOf('/') + 1;
+            if (index > 0) {
+                filename = hint.substring(index);
+            } else {
+                filename = hint;
+            }
+        }
+        return filename;
+    }
+	//#endif /*VENDOR_EDIT*/
+	public static String getStatusDescription(Context mContext, int statusCode) {
+        String ret;
+        if (statusCode == WifiDirectShareTask.STATE_PENDING) {
+            ret = mContext.getString(R.string.status_pending);
+        } else if (statusCode == WifiDirectShareTask.STATE_ONGOING) {
+            ret = mContext.getString(R.string.status_running);
+        } else if (statusCode == WifiDirectShareTask.STATE_SUCCESS) {
+            ret = mContext.getString(R.string.status_success);
+        } else if (statusCode == WifiDirectShareTask.STATE_REJECTED) {
+            ret = mContext.getString(R.string.status_canceled);
+        } else if (statusCode == WifiDirectShareTask.STATE_ABORTED) {
+            ret = mContext.getString(R.string.status_canceled);
+        } else if (statusCode == WifiDirectShareTask.STATUS_FORBIDDEN) {
+            ret = mContext.getString(R.string.status_forbidden);
+        }else {
+            ret = mContext.getString(R.string.status_unknown_error);
+        }
+        return ret;
+    }
+}
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/share/WifiDirectShareTaskMetaData.java
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/share/WifiDirectShareTaskMetaData.java	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/share/WifiDirectShareTaskMetaData.java	(版本 25821)
+package com.oppo.wifidirect.share;
+import android.provider.BaseColumns;
+import android.net.Uri;
+public interface WifiDirectShareTaskMetaData extends BaseColumns{
+        String TABLE_NAME = "share_tasks";
+        Uri CONTENT_URI = Uri.parse("content://" + WifiDirectShareProvider.AUTHORITY + "/" + TABLE_NAME);
+        String CONTENT_TYPE = "vnd.android.cursor.dir/vnd.WifiDirect.share.task";
+        String CONTENT_ITEM_TYPE = "vnd.android.cursor.item/vnd.WifiDirect.share.task";
+        String DEFAULT_SORT_ORDER = "modified DESC";
+        // metadata
+        String TASK_TYPE = "type";
+        String TASK_STATE = "state";
+        String TASK_RESULT = "result";
+        // request
+        String TASK_OBJECT_NAME = "name";
+        String TASK_OBJECT_URI = "uri";
+        String TASK_OBJECT_FILE = "data";
+        String TASK_MIMETYPE = "mime";
+        String TASK_PEER_NAME = "peer_name";
+        //String TASK_PEER_ADDR = "peer_addr";
+        // progress
+        String TASK_TOTAL_BYTES = "total";
+        String TASK_DONE_BYTES = "done";
+        // timestamp
+        String TASK_CREATION_DATE = "creation";
+        String TASK_MODIFIED_DATE = "modified";
+       // String TASK_IS_HANDOVER = "ishandover";
+    }
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/share/OppTransferAdapter.java
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/share/OppTransferAdapter.java	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/share/OppTransferAdapter.java	(版本 25821)
+/************************************************************************************
+** File: - ..\mediatek\source\packages\Bluetooth\profiles\opp\src\com\mediatek\bluetooth\opp\mmi\OppTransferAdapter.java
+** VENDOR_EDIT
+** Copyright (C), 2008-2012, OPPO Mobile Comm Corp., Ltd
+** 
+** Description: 
+**      bluetooth Opp Transfer Adapter
+** 
+** Version: 0.1
+** Date created: 16:43:39,06/12/2011
+** Author: Jiehong.Tang@CommSrv.BT
+** 
+** --------------------------- Revision History: --------------------------------
+** 	<author>	<data>			<desc>
+** 
+************************************************************************************/
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+package com.oppo.wifidirect.share;
+import com.oppo.wifidirect.R;
+import android.content.Context;
+import android.content.res.Resources;
+import android.database.Cursor;
+import android.text.format.DateUtils;
+import android.text.format.DateFormat;
+import android.text.format.Formatter;
+import android.view.View;
+import android.widget.ImageView;
+import android.widget.ResourceCursorAdapter;
+import android.widget.TextView;
+import java.util.Date;
+import com.oppo.wifidirect.share.WifiDirectShareTask;
+import com.oppo.wifidirect.share.WifiDirectShareTask.Direction;
+import com.oppo.wifidirect.share.WifiDirectShareTaskMetaData;
+import android.util.Log;
+/**
+ * This class is used to represent the data for the transfer history list box.
+ * The only real work done by this class is to construct a custom view for the
+ * line items.
+ */
+public class OppTransferAdapter extends ResourceCursorAdapter {
+    private static final String TAG = " OppTransferAdapter";
+    private Context mContext;
+    public OppTransferAdapter(Context context, int layout, Cursor c) {
+        super(context, layout, c);
+        mContext = context;
+		Log.d( TAG,"OppTransferAdapter start");
+    }
+    @Override
+    public void bindView(View view, Context context, Cursor cursor) {
+		Log.d(TAG , "OppTransferAdapter.bindView()");
+        // Retrieve the icon for this transfer
+        ImageView iv = (ImageView)view.findViewById(R.id.transfer_icon);
+        int status = cursor.getInt(cursor.getColumnIndexOrThrow(WifiDirectShareTaskMetaData.TASK_STATE));
+        int taskType = cursor.getInt(cursor.getColumnIndexOrThrow(WifiDirectShareTaskMetaData.TASK_TYPE));
+        //#ifndef VENDOR_EDIT
+        /**
+          *zhanghaipeng@Plf.CommApp.phone, 2012/10/15 modify for change resource from frameworks layer to local
+          */
+        /*if (status != BluetoothShareTask.STATE_SUCCESS) {
+            iv.setImageResource(android.R.drawable.stat_notify_error);
+        } else {
+            if (BluetoothShareTask.checkDirection(taskType) == BluetoothShareTask.Direction.out) {
+                iv.setImageResource(android.R.drawable.stat_sys_upload_done);
+            } else {
+                iv.setImageResource(android.R.drawable.stat_sys_download_done);
+            }
+        }
+        */
+        //#else /* VENDOR_EDIT */
+        if (status != WifiDirectShareTask.STATE_SUCCESS) {
+            iv.setImageResource(R.drawable.oppo_stat_notify_error);
+        } else {
+            if (WifiDirectShareTask.checkDirection(taskType) == WifiDirectShareTask.Direction.out) {
+                iv.setImageResource(R.drawable.oppo_stat_sys_upload_anim0);
+            } else {
+                iv.setImageResource(R.drawable.oppo_stat_sys_download_anim0);
+            }
+        }
+       //#endif /* VENDOR_EDIT */
+        // Set title
+        TextView tv = (TextView)view.findViewById(R.id.transfer_title);
+        String title = cursor.getString(
+                cursor.getColumnIndexOrThrow(WifiDirectShareTaskMetaData.TASK_OBJECT_NAME));
+        if (title == null) {
+            title = mContext.getString(R.string.unknown_file);
+        }
+        tv.setText(title);
+        // target device
+        tv = (TextView)view.findViewById(R.id.targetdevice);
+        int destinationColumnId = cursor.getColumnIndexOrThrow(WifiDirectShareTaskMetaData.TASK_PEER_NAME);
+        String deviceName = cursor.getString(destinationColumnId);
+        tv.setText(deviceName);
+        // complete text and complete date
+        long totalBytes = cursor.getLong(cursor.getColumnIndexOrThrow(WifiDirectShareTaskMetaData.TASK_TOTAL_BYTES));
+        if (OppTransferInfo.isStatusCompleted(status)) {
+            tv = (TextView)view.findViewById(R.id.complete_text);
+            tv.setVisibility(View.VISIBLE);
+            if (status != WifiDirectShareTask.STATE_SUCCESS ) {
+                tv.setText(Utils.getStatusDescription(context, status));
+            } else {
+                String completeText;
+                if (WifiDirectShareTask.checkDirection(taskType) == WifiDirectShareTask.Direction.in) {
+                    completeText = context.getResources().getString(R.string.download_success, Formatter.formatFileSize(
+                            mContext, totalBytes));
+                } else {
+                    completeText = context.getResources().getString(R.string.upload_success, Formatter.formatFileSize(
+                            mContext, totalBytes));
+                }
+                tv.setText(completeText);
+            }
+            int dateColumnId = cursor.getColumnIndexOrThrow(WifiDirectShareTaskMetaData.TASK_MODIFIED_DATE);
+            long time = cursor.getLong(dateColumnId);
+            Date d = new Date(time);
+            CharSequence str = DateUtils.isToday(time) ? DateFormat.getTimeFormat(mContext).format(
+                    d) : DateFormat.getDateFormat(mContext).format(d);
+            tv = (TextView)view.findViewById(R.id.complete_date);
+            tv.setVisibility(View.VISIBLE);
+            tv.setText(str);
+        }
+    }
+}
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/share/SystemUtils.java
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/share/SystemUtils.java	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/share/SystemUtils.java	(版本 25821)
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein is
+ * confidential and proprietary to MediaTek Inc. and/or its licensors. Without
+ * the prior written permission of MediaTek inc. and/or its licensors, any
+ * reproduction, modification, use or disclosure of MediaTek Software, and
+ * information contained herein, in whole or in part, shall be strictly
+ * prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER
+ * ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
+ * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR
+ * NONINFRINGEMENT. NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH
+ * RESPECT TO THE SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY,
+ * INCORPORATED IN, OR SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES
+ * TO LOOK ONLY TO SUCH THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO.
+ * RECEIVER EXPRESSLY ACKNOWLEDGES THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO
+ * OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES CONTAINED IN MEDIATEK
+ * SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE
+ * RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S
+ * ENTIRE AND CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE
+ * RELEASED HEREUNDER WILL BE, AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE
+ * MEDIATEK SOFTWARE AT ISSUE, OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE
+ * CHARGE PAID BY RECEIVER TO MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek
+ * Software") have been modified by MediaTek Inc. All revisions are subject to
+ * any receiver's applicable license agreements with MediaTek Inc.
+ */
+package com.oppo.wifidirect.share;
+import java.io.File;
+import java.util.ArrayList;
+import java.util.List;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+import android.content.pm.ResolveInfo;
+import android.database.Cursor;
+import android.net.Uri;
+import android.os.Environment;
+import android.os.PowerManager;
+import android.os.StatFs;
+import android.os.Vibrator;
+import android.os.PowerManager.WakeLock;
+import android.os.storage.StorageManager;
+import com.oppo.os.OppoUsbEnvironment;
+////import com.mediatek.activity.MessageActivity;
+////import com.mediatek.bluetooth.BluetoothReceiver;
+////import com.mediatek.bluetooth.Options;
+//import com.oppo.wifidirect.R;
+//#ifdef VENDOR_EDIT
+//wenjie.Liu@Prd.SysApp.PowerManager, 2013/01/24, Add for : receive file auto storage to available directory
+import android.content.res.Resources;
+//import com.mediatek.bluetooth.MimeType;
+//import com.oppo.os.OppoEnvironment;
+import android.content.ContentResolver;
+import android.provider.Settings;  
+import android.util.Log;    
+//#endif /* VENDOR_EDIT */
+public class SystemUtils {
+    private static final String TAG =" Bluetooth SystemUtils ";
+    // constants for file manager operations
+    // private static final Uri FM_CONTENT_URI = Uri.parse( "content://com.mediatek.filemanager.provider" );
+    // private static final String FM_KEY_PATH = "path";
+    private static final String FM_SELECTION = "Received File";
+//#ifdef VENDOR_EDIT
+//wenjie.Liu@Prd.SysApp.PowerManager, 2013/01/24, Add for : receive file auto storage to available directory
+    public static String mRootPath = null;    
+//#endif /* VENDOR_EDIT */
+    private static final String SDCARD = "sdcard";
+    /**
+     * get "Received File" path from file-manager and return default config (/sdcard/bluetooth) if error occurred
+     * 
+     * @param context
+     * @return
+     */
+//#ifndef VENDOR_EDIT
+//wenjie.Liu@Prd.SysApp.PowerManager, 2013/01/24, Remove for : receive file auto storage to available directory
+/*
+    public static String getReceivedFilePath(Context context) {
+*/
+//#endif /* VENDOR_EDIT */     
+        // query file-manager
+        /*
+         * Cursor cursor = context.getContentResolver().query( FM_CONTENT_URI, new String[]{ FM_KEY_PATH }, FM_SELECTION,
+         * null, null ); String result = null; try { // get path from file manager if( cursor != null && cursor.moveToFirst()
+         * ){ result = cursor.getString( cursor.getColumnIndex( FM_KEY_PATH ) ); } // use default setting if error if( result
+         * == null ){ StorageManager sm = (StorageManager)context.getSystemService( Context.STORAGE_SERVICE ); result =
+         * sm.getDefaultPath() + "/" + Options.DEFAULT_STORAGE_FOLDER; } return result; } finally { if( cursor != null )
+         * cursor.close(); }
+         */
+    //#ifndef VENDOR_EDIT
+    //wenjie.Liu@Prd.SysApp.PowerManager, 2013/01/24, Modify for : receive file auto storage to available directory
+    /*
+        // FileManagerProvider is removed, check "Received File" folder directly by file path
+        String result = null;
+        StorageManager sm = (StorageManager) context.getSystemService(Context.STORAGE_SERVICE);
+        result = sm.getDefaultPath() + "/" + FM_SELECTION;
+        File storageDir = new File(result);
+        if (!storageDir.isDirectory()) {
+            result = sm.getDefaultPath() + "/" + Options.DEFAULT_STORAGE_FOLDER;
+        }
+    */
+    //#else /* VENDOR_EDIT */
+	public static String getReceivedFilePath( Context context, String hint ){
+		Log.d(TAG," getReceivedFilePath()" );
+		Resources res = context.getResources();
+		String result = null;
+		int dirId = 0;
+		Log.w(TAG, "systemutils: string name_hint = " + hint );
+		dirId = MimeType.getDirTypeFromExtension(MimeType.getExtensionFromFileName(hint));
+		Log.w(TAG, "systemutils: dir id = " + dirId );
+		try {
+			mRootPath = getReceivedFileRootPath(context);
+			result = mRootPath + "/" + res.getString(dirId);
+			Log.w(TAG,"result path is :" + result);
+			return result;
+		}
+		finally {
+		}    
+    //#endif /* VENDOR_EDIT */
+    }
+//#ifdef VENDOR_EDIT
+//wenjie.Liu@Prd.SysApp.PowerManager, 2013/01/24, Add for :receive file auto storage to available directory    
+	public static String getReceivedFileRootPath( Context context ){
+	    Log.d(TAG, "getReceivedFileRootPath() " );
+	    ContentResolver cr = context.getContentResolver();
+	    String path = Settings.Secure.getString(cr, MimeType.SAVE_PATH);
+        String root_path = null;        
+		Log.w(TAG,"Setting root path is = "+ path);
+        if(null != path ){
+	        if((path.equals(MimeType.MEMORY_CARD)) && (OppoUsbEnvironment.getExternalSdState(context).equals(Environment.MEDIA_MOUNTED)))    
+	        {
+	            root_path = MimeType.MEMORY_CARD_ROOT;
+	        }
+	        else
+	        {
+	            root_path = MimeType.PHONE_ROOT;
+	        }
+	    }
+	    else{
+	    	Log.w(TAG,"Setting root path is null");
+		    if(OppoUsbEnvironment.getInternalSdState(context).equals(Environment.MEDIA_MOUNTED)){
+				root_path = MimeType.PHONE_ROOT;
+			}
+			else{
+				root_path = MimeType.MEMORY_CARD_ROOT;
+			}
+		}
+		return root_path;
+	}
+	public static String getReceivedFilePath(Context context){
+		return getReceivedFilePath(context, null);
+	}
+//#endif /* VENDOR_EDIT */
+/*	
+    public static String getMountPointPath() {
+        String path = StorageManager.getDefaultPath();
+        String ret = null;
+        int idx = path.lastIndexOf(SDCARD);
+        ret = path.substring(0, idx);
+        return ret;
+    }
+*/
+    /**
+     * get the writable available size of default directory
+     */
+    public static long getReceivedFilePathAvailableSize(Context context) {
+        return SystemUtils.getStorageAvailableSize(context, SystemUtils.getReceivedFilePath(context));
+    }
+    /**
+     * get the corresponding external-storage-directory ( "/mnt/sdcard" or "/mnt/sdcard/sdcard2" ) for the specified
+     * filename.
+     * 
+     * @param filename
+     * @return null when no external storage directory matches the filename
+     */
+    public static File getExternalStorageDirectory(Context context, String filename) {
+        String result = null;
+        if (filename != null) {
+            // loop all external storage dir and find out the correct one
+            int currMatch = 0;
+            filename = filename.toLowerCase();
+            StorageManager sm = (StorageManager) context.getSystemService(Context.STORAGE_SERVICE);
+            String[] esds = sm.getVolumePaths();
+            for (String dir : esds) {
+                // check dir and keep the longest one: "/mnt/sdcard/sdcard2" over "/mnt/sdcard"
+                if (filename.startsWith(dir) && dir.length() > currMatch) {
+                    result = dir;
+                    currMatch = dir.length();
+                }
+            }
+        }
+        //if (Options.LL_DEBUG) {
+            Log.d(TAG,"SystemUtils.getExternalStorageDirectory(): [" + filename + "]=>[" + result + "]");
+        //}
+        if (result == null) {
+            return null;
+        }
+        return new File(result);
+    }
+    /**
+     * check whether the external storage for the given filename is under "MOUNTED" state (writable). this function will
+     * exclude "UN-MOUNTING" from the original "MOUNTED" state but we need to call startMonitor() before EJECT event. if the
+     * given filename is not in any external storage directory => return false
+     * 
+     * @param filename
+     * @return
+     */
+    public static boolean isExternalStorageMounted(Context context, String filename) {
+        // map filename to external-storage-directory
+        File storageDir = SystemUtils.getExternalStorageDirectory(context, filename);
+        if (storageDir == null) {
+            Log.w(TAG,"StorageMonitor.isStorageMounted(): can't find stroage dir for[" + filename + "]");
+            return false;
+        }
+        // get storage state from Environment API
+        String storageDirPath = storageDir.getAbsolutePath();
+        StorageManager sm = (StorageManager) context.getSystemService(Context.STORAGE_SERVICE);
+        String state = sm.getVolumeState(storageDirPath);
+      //  if (Options.LL_DEBUG) {
+            Log.d(TAG,"SystemUtils.isExternalStorageMounted(): [" + filename + "]=>[" + state + "]");
+      //  }
+        // when state is mounted, we need to make sure is not under "un-mounting" state
+        if (Environment.MEDIA_MOUNTED.equals(state)) {
+            //if (Options.LL_DEBUG) {
+             //   Log.d(TAG,"SystemUtils.isExternalStorageMounted(): check unmounting[" + storageDirPath + "]["
+             //           + (!BluetoothReceiver.sUnmountingStorageSet.contains(storageDirPath)) + "]");
+            //}
+            return true;
+        }
+        return false;
+    }
+    /**
+     * get the writable available size for the given filename please make sure the directory is already exist.
+     * 
+     * @param filename
+     * @return -1 when no storage is available
+     */
+    public static long getStorageAvailableSize(Context context, String filename) {
+        // check external storage state (if it is)
+        File externalStorage = SystemUtils.getExternalStorageDirectory(context, filename);
+        if (externalStorage != null && !SystemUtils.isExternalStorageMounted(context, filename)) {
+            // a not "MOUNTED" external storage => no available size
+            return -1;
+        }
+        // check storage size
+        File ff = new File(filename);
+        if (!ff.isDirectory()) {
+            Log.d(TAG,"SystemUtils.getStorageAvailableSize(): change to parent folder");
+            ff = ff.getParentFile();
+            if (ff == null)
+                return -1; // no parent folder
+        }
+        StatFs stat = new StatFs(ff.getPath());
+        // -4 for file system block for new file
+        return ((long) stat.getBlockSize()) * ((long) (stat.getAvailableBlocks() - 4));
+    }
+    // private static final int MAX_FILEPATH_LENGTH = 256;
+    private static final int MAX_FILENAME_LENGTH = 255;
+    /**
+     * append '_n' when file exists
+     * 
+     * @param expectedFilePath
+     * @return
+     */
+    public static File createNewFileForSaving(String expectedFilePath) {
+        return SystemUtils.createNewFileForSaving(0, expectedFilePath);
+    }
+    private static File createNewFileForSaving(int level, String expectedFilePath) {
+		int innerLevel = level;
+		String innerFilePath = expectedFilePath;
+		while( true ){
+			// check expected-filename
+			if( innerFilePath== null ){
+				Log.w(TAG,"SystemUtils.createNewFileForSaving(): null expected filename!");
+				return null;
+			}
+			// create default file object for checking
+			File file = new File( innerFilePath );
+			String filename = file.getName();
+			// for normal case performance
+			if( filename.getBytes().length <= MAX_FILENAME_LENGTH && !file.exists() ) {
+				try {
+					file.createNewFile();
+					return file;
+				} catch( Exception ex ) {
+					Log.e(TAG,"create new file error: [" + file + "]", ex);
+					return null;
+				}
+			}
+			// parsing the filename: [basename] + ["_" + counter] + ["." + extension]
+			int extIndex = filename.lastIndexOf('.');
+			int sufIndex = filename.lastIndexOf('_');
+			// extension
+			String extension = (extIndex > -1) ? filename.substring(extIndex) : "";
+			// don't change the original filename
+			if( innerLevel == 0 )
+				sufIndex = -1;
+			// counter
+			if( sufIndex > -1 ) {
+				String counter = (extIndex > -1) ? filename.substring(sufIndex + 1, extIndex) : filename.substring(sufIndex + 1);
+				try {
+					innerLevel = Integer.parseInt( counter );
+				} catch( NumberFormatException ex ) {
+					// no a valid counter string
+					sufIndex = -1;
+				}
+			}
+			// basename
+			String basename;
+			if( sufIndex > -1 ) {
+				basename = filename.substring( 0, sufIndex );
+			} else if( extIndex > -1 ) {
+				basename = filename.substring( 0, extIndex );
+			} else {
+				basename = filename;
+			}
+			// check filename length
+			if( filename.getBytes().length > MAX_FILENAME_LENGTH ) {
+				String suffix = filename.substring( basename.length() );
+				int maxBasename = MAX_FILENAME_LENGTH - suffix.getBytes().length;
+				filename = SystemUtils.trimFilenameWithLength( filename, maxBasename );
+				file = new File( file.getParentFile(), filename + suffix );
+				Log.w(TAG,"filename is too long and be trimed: [" + file + "]");
+			}
+			// check exists  
+			if( file.exists() ) {
+				innerLevel++;
+				StringBuilder buffer = new StringBuilder( filename.length()).append(basename).append('_').append(innerLevel).append( extension );
+				file = new File( file.getParentFile(), buffer.toString() );
+				//return SystemUtils.createNewFileForSaving(level, file.getAbsolutePath());    
+				//change with while loop for stack overflow issue
+				innerFilePath = file.getAbsolutePath();
+				continue;
+			} else {
+				try {
+					file.createNewFile();
+					return file;
+				} catch (Exception ex) {
+					Log.e(TAG,"create new file error: [" + file + "]", ex);
+					return null;
+				}
+			}
+		}
+	}
+    public static String trimFilenameWithLength(String filename, int maxLength) {
+        Log.d(TAG,"SystemUtils.trimFilenameWithLength(): [" + filename + "][" + maxLength + "]");
+        // check parameter
+        if (filename == null)
+            return "";
+        // valid case -> return directly
+        if (filename.getBytes().length <= maxLength) {
+            return filename;
+        }
+        // need to trim filename
+        int currentEnd = filename.length();
+        do {
+            filename = filename.substring(0, --currentEnd);
+        } while (filename.getBytes().length > maxLength);
+        return filename;
+    }
+    /**
+     * open object with appropriate application or display error dialog.
+     * 
+     * @param context
+     * @param filename
+     * @param mimeType
+     * @return
+     */
+	 /*
+    public static Intent getOpenFileIntent(Context context, String filename, String mimeType) {
+        // invalid parameters
+        // if( filename == null || mimeType == null ){
+        if (filename == null) {
+            BtLog.w("invalid parameters for getOpenFileIntent(): filename=" + filename + " mimetype=" + mimeType);
+            return MessageActivity.createIntent(context, context.getString(R.string.bt_share_openfile_title), context
+                    .getString(R.string.bt_share_openfile_message_invalid_param, filename, mimeType), context
+                    .getString(R.string.bt_share_openfile_confirm));
+        }
+        // resource exists
+        File file = new File(filename);
+        if (!file.exists()) {
+            return MessageActivity.createIntent(context, context.getString(R.string.bt_share_openfile_title), context
+                    .getString(R.string.bt_share_openfile_message_resource_not_found, filename), context
+                    .getString(R.string.bt_share_openfile_confirm));
+        }
+        Uri path = Uri.parse(filename);
+        path = (path.getScheme() == null) ? Uri.fromFile(file) : path;
+        if (!isSupportedDataType(context, path, mimeType)) {
+            return MessageActivity.createIntent(context, context.getString(R.string.bt_share_openfile_title), context
+                    .getString(R.string.bt_share_openfile_message_unsupported_type, mimeType), context
+                    .getString(R.string.bt_share_openfile_confirm));
+        } else {
+            Intent intent = new Intent(Intent.ACTION_VIEW);
+            intent.setDataAndType(path, mimeType);
+            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+            return intent;
+        }
+    }
+*/
+    /**
+     * check if the data type is supported by system
+     * 
+     * @param context
+     * @param data
+     * @param mimeType
+     * @return
+     */
+    public static boolean isSupportedDataType(Context context, Uri data, String mimeType) {
+        Intent intent = new Intent(Intent.ACTION_VIEW);
+        intent.setDataAndType(data, mimeType);
+        List<ResolveInfo> list = context.getPackageManager()
+                .queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);
+        if (list.size() == 0) {
+            Log.d(TAG,"cannot find proper Activity to handle Intent: mime[" + mimeType + "], data[" + data + "]");
+            return false;
+        }
+        return true;
+    }
+    /**
+     * Check Bluetooth is allowed to be used under current config Currently not used in app package -> should be used in
+     * Settings (BluetoothAdapter.ACTION_REQUEST_ENABLE)
+     */
+    // public static boolean isBluetoothAllowed( Context context){
+    //
+    // // get content resolver
+    // ContentResolver resolver = context.getContentResolver();
+    //
+    // // check airplane-mode config
+    // boolean isAirplaneModeOn = Settings.System.getInt(resolver, Settings.System.AIRPLANE_MODE_ON, 0) == 1;
+    // if( !isAirplaneModeOn ) return true;
+    //
+    // String airplaneModeRadios = Settings.System.getString(resolver, Settings.System.AIRPLANE_MODE_RADIOS);
+    // boolean isAirplaneSensitive = airplaneModeRadios == null ? true : airplaneModeRadios.contains(
+    // Settings.System.RADIO_BLUETOOTH );
+    // if( !isAirplaneSensitive ) return true;
+    //
+    // String airplaneModeToggleableRadios = Settings.System.getString(resolver,
+    // Settings.System.AIRPLANE_MODE_TOGGLEABLE_RADIOS);
+    // boolean isAirplaneToggleable = airplaneModeToggleableRadios == null ? false :
+    // airplaneModeToggleableRadios.contains(Settings.System.RADIO_BLUETOOTH);
+    // if( isAirplaneToggleable ) return true;
+    //
+    // return false;
+    // }
+    public static void startVibration(Context context, long milliseconds) {
+        Vibrator v = (Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE);
+        if (v == null) {
+            Log.w(TAG,"startVibration error: cna't find VIBRATOR_SERVICE");
+            return;
+        }
+        v.vibrate(milliseconds);
+    }
+    public static void startVibration(Context context, long[] pattern, int repeat) {
+        Vibrator v = (Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE);
+        if (v == null) {
+            Log.w(TAG,"startVibration error: cna't find VIBRATOR_SERVICE");
+            return;
+        }
+        v.vibrate(pattern, repeat);
+    }
+    public static void stopVibration(Context context) {
+        Vibrator v = (Vibrator) context.getSystemService(Context.VIBRATOR_SERVICE);
+        if (v == null) {
+            Log.w(TAG,"stopVibration error: can't find VIBRATOR_SERVICE");
+            return;
+        }
+        v.cancel();
+    }
+    public static void sound(Context context) {
+        // MediaPlayer mp = MediaPlayer.create( context, R.raw.sound_file_1 );
+        // mp.start();
+    }
+    public static void screen(Context context, long milliseconds) {
+        PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
+        WakeLock wl = pm.newWakeLock(PowerManager.SCREEN_BRIGHT_WAKE_LOCK, "SystemUtilsScreenLock");
+        wl.acquire(milliseconds);
+        // wl.release();
+    }
+}
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/share/WifiDirectShareProvider.java
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/share/WifiDirectShareProvider.java	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/share/WifiDirectShareProvider.java	(版本 25821)
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+package com.oppo.wifidirect.share;
+import android.content.ContentProvider;
+import android.content.ContentUris;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.UriMatcher;
+import android.database.Cursor;
+import android.database.SQLException;
+import android.database.sqlite.SQLiteDatabase;
+import android.database.sqlite.SQLiteOpenHelper;
+import android.database.sqlite.SQLiteQueryBuilder;
+import android.net.Uri;
+import android.text.TextUtils;
+//import com.mediatek.bluetooth.opp.mmi.OppLog;
+import android.util.Log;
+//import com.mediatek.bluetooth.share.WifiDirectShareTask.WifiDirectShareTaskMetaData;
+import java.io.File;
+import java.util.HashMap;
+public class WifiDirectShareProvider extends ContentProvider {
+	private static final String TAG = "WifiDirectShareProvider";
+    public static final String AUTHORITY = "com.oppo.provider.wifidirect.share";
+    public static final String DATABASE_NAME = "share.db";
+    public static final int DATABASE_VERSION = 1;
+    // Column projection map
+    private static HashMap<String, String> sProjectionMap = new HashMap<String, String>();
+    static {
+        sProjectionMap.put(WifiDirectShareTaskMetaData._ID, WifiDirectShareTaskMetaData._ID);
+        sProjectionMap.put(WifiDirectShareTaskMetaData.TASK_TYPE, WifiDirectShareTaskMetaData.TASK_TYPE);
+        sProjectionMap.put(WifiDirectShareTaskMetaData.TASK_STATE, WifiDirectShareTaskMetaData.TASK_STATE);
+        sProjectionMap.put(WifiDirectShareTaskMetaData.TASK_RESULT, WifiDirectShareTaskMetaData.TASK_RESULT);
+        sProjectionMap.put(WifiDirectShareTaskMetaData.TASK_OBJECT_NAME, WifiDirectShareTaskMetaData.TASK_OBJECT_NAME);
+        sProjectionMap.put(WifiDirectShareTaskMetaData.TASK_OBJECT_URI, WifiDirectShareTaskMetaData.TASK_OBJECT_URI);
+        sProjectionMap.put(WifiDirectShareTaskMetaData.TASK_OBJECT_FILE, WifiDirectShareTaskMetaData.TASK_OBJECT_FILE);
+        sProjectionMap.put(WifiDirectShareTaskMetaData.TASK_MIMETYPE, WifiDirectShareTaskMetaData.TASK_MIMETYPE);
+        sProjectionMap.put(WifiDirectShareTaskMetaData.TASK_PEER_NAME, WifiDirectShareTaskMetaData.TASK_PEER_NAME);
+       // sProjectionMap.put(WifiDirectShareTaskMetaData.TASK_PEER_ADDR, WifiDirectShareTaskMetaData.TASK_PEER_ADDR);
+        sProjectionMap.put(WifiDirectShareTaskMetaData.TASK_TOTAL_BYTES, WifiDirectShareTaskMetaData.TASK_TOTAL_BYTES);
+        sProjectionMap.put(WifiDirectShareTaskMetaData.TASK_DONE_BYTES, WifiDirectShareTaskMetaData.TASK_DONE_BYTES);
+        sProjectionMap.put(WifiDirectShareTaskMetaData.TASK_CREATION_DATE, WifiDirectShareTaskMetaData.TASK_CREATION_DATE);
+        sProjectionMap.put(WifiDirectShareTaskMetaData.TASK_MODIFIED_DATE, WifiDirectShareTaskMetaData.TASK_MODIFIED_DATE);
+        //sProjectionMap.put(WifiDirectShareTaskMetaData.TASK_IS_HANDOVER, WifiDirectShareTaskMetaData.TASK_IS_HANDOVER);
+    }
+    // Uri Matcher
+    private static final UriMatcher URI_MATCHER;
+    private static final int MULTIPLE_TASK_URI = 1;
+    private static final int SINGLE_TASK_URI = 2;
+//#ifdef VENDOR_EDIT
+//wenjie.Liu@Prd.SysApp.PowerManager, 2013/01/26, Add for :Live Folder   
+	private static final int LIVE_FOLDER_URI = 3;
+//#endif /* VENDOR_EDIT */
+    static {
+        URI_MATCHER = new UriMatcher(UriMatcher.NO_MATCH);
+        URI_MATCHER.addURI(AUTHORITY, WifiDirectShareTaskMetaData.TABLE_NAME, MULTIPLE_TASK_URI);
+        URI_MATCHER.addURI(AUTHORITY, WifiDirectShareTaskMetaData.TABLE_NAME + "/#", SINGLE_TASK_URI);
+//#ifdef VENDOR_EDIT
+//wenjie.Liu@Prd.SysApp.PowerManager, 2013/01/26, Add for :Live Folder   
+		//URI_MATCHER.addURI(AUTHORITY, "live_folders/received", LIVE_FOLDER_URI);
+//#endif /* VENDOR_EDIT */		
+    }
+    private DatabaseHelper mDbHelper;
+    private SQLiteDatabase mDb;
+    @Override
+    public boolean onCreate() {
+        this.mDbHelper = new DatabaseHelper(this.getContext());
+        this.mDb = this.mDbHelper.getWritableDatabase();
+        return true;
+    }
+    @Override
+    public int delete(Uri uri, String selection, String[] selectionArgs) {
+        File dbfile = new File(this.mDb.getPath());
+        if (!dbfile.exists()) {
+            // OppLog.w( "delete: ShareDB is not exist, need create db!");
+            this.mDb.close();
+        }
+        this.mDb = this.mDbHelper.getWritableDatabase();
+        int count;
+        switch (URI_MATCHER.match(uri)) {
+            case MULTIPLE_TASK_URI:
+                count = this.mDb.delete(WifiDirectShareTaskMetaData.TABLE_NAME, selection, selectionArgs);
+                break;
+            case SINGLE_TASK_URI:
+                String rowId = uri.getPathSegments().get(1);
+                count = this.mDb.delete(WifiDirectShareTaskMetaData.TABLE_NAME, WifiDirectShareTaskMetaData._ID + "=" + rowId
+                        + (!TextUtils.isEmpty(selection) ? " AND (" + selection + ')' : ""), selectionArgs);
+                break;
+            default:
+                throw new IllegalArgumentException("Unknown URI " + uri);
+        }
+        this.getContext().getContentResolver().notifyChange(uri, null);
+        return count;
+    }
+    @Override
+    public String getType(Uri uri) {
+        switch (URI_MATCHER.match(uri)) {
+            case MULTIPLE_TASK_URI:
+                return WifiDirectShareTaskMetaData.CONTENT_TYPE;
+            case SINGLE_TASK_URI:
+                return WifiDirectShareTaskMetaData.CONTENT_ITEM_TYPE;
+            default:
+                throw new IllegalArgumentException("Unknown URI " + uri);
+        }
+    }
+    @Override
+    public Uri insert(Uri uri, ContentValues values) {
+        File dbfile = new File(this.mDb.getPath());
+        if (!dbfile.exists()) {
+            // OppLog.w( "insert: ShareDB is not exist, need create db!");
+            this.mDb.close();
+        }
+        if (URI_MATCHER.match(uri) != MULTIPLE_TASK_URI) {
+            throw new IllegalArgumentException("Invalid URI: " + uri);
+        }
+        // required fields x 6
+        if (!values.containsKey(WifiDirectShareTaskMetaData.TASK_TYPE)
+                || !values.containsKey(WifiDirectShareTaskMetaData.TASK_STATE)
+                || !values.containsKey(WifiDirectShareTaskMetaData.TASK_OBJECT_URI)
+                || !values.containsKey(WifiDirectShareTaskMetaData.TASK_MIMETYPE)
+                || !values.containsKey(WifiDirectShareTaskMetaData.TASK_PEER_NAME)
+                //|| !values.containsKey(WifiDirectShareTaskMetaData.TASK_PEER_ADDR)
+                ) {
+            throw new SQLException("insert fail: required property is null, uri: " + uri);
+        }
+        // optional fields x 5
+        if (!values.containsKey(WifiDirectShareTaskMetaData.TASK_OBJECT_NAME)) {
+            values.put(WifiDirectShareTaskMetaData.TASK_OBJECT_NAME, "");
+        }
+        if (!values.containsKey(WifiDirectShareTaskMetaData.TASK_OBJECT_FILE)) {
+            values.put(WifiDirectShareTaskMetaData.TASK_OBJECT_FILE, "");
+        }
+        if (!values.containsKey(WifiDirectShareTaskMetaData.TASK_RESULT)) {
+            values.put(WifiDirectShareTaskMetaData.TASK_RESULT, "");
+        }
+        if (!values.containsKey(WifiDirectShareTaskMetaData.TASK_TOTAL_BYTES)) {
+            values.put(WifiDirectShareTaskMetaData.TASK_TOTAL_BYTES, 0);
+        }
+        if (!values.containsKey(WifiDirectShareTaskMetaData.TASK_DONE_BYTES)) {
+            values.put(WifiDirectShareTaskMetaData.TASK_DONE_BYTES, 0);
+        }
+        //if( !values.containsKey(WifiDirectShareTaskMetaData.TASK_IS_HANDOVER)){
+        //    values.put( WifiDirectShareTaskMetaData.TASK_IS_HANDOVER, 0 );
+        //} 
+        // auto fields
+        if (!values.containsKey(WifiDirectShareTaskMetaData.TASK_CREATION_DATE)) {
+            values.put(WifiDirectShareTaskMetaData.TASK_CREATION_DATE, System.currentTimeMillis());
+        }
+        if (!values.containsKey(WifiDirectShareTaskMetaData.TASK_MODIFIED_DATE)) {
+            values.put(WifiDirectShareTaskMetaData.TASK_MODIFIED_DATE, System.currentTimeMillis());
+        }
+        // insert database
+        this.mDb = this.mDbHelper.getWritableDatabase();
+        long rowId = this.mDb.insert(WifiDirectShareTaskMetaData.TABLE_NAME, null, values);
+        if (rowId != -1) {
+            Uri recordUri = ContentUris.withAppendedId(WifiDirectShareTaskMetaData.CONTENT_URI, rowId);
+            this.getContext().getContentResolver().notifyChange(recordUri, null);
+            return recordUri;
+        } else {
+            //throw new SQLException("failed to do insert row, uri: " + uri);
+            return null;
+        }
+    }
+    @Override
+    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {
+        SQLiteQueryBuilder qb = new SQLiteQueryBuilder();
+        switch (URI_MATCHER.match(uri)) {
+            case MULTIPLE_TASK_URI:
+                qb.setTables(WifiDirectShareTaskMetaData.TABLE_NAME);
+                qb.setProjectionMap(sProjectionMap);
+                break;
+            case SINGLE_TASK_URI:
+                qb.setTables(WifiDirectShareTaskMetaData.TABLE_NAME);
+                qb.setProjectionMap(sProjectionMap);
+                qb.appendWhere(WifiDirectShareTaskMetaData._ID + "=" + uri.getPathSegments().get(1));
+                break;
+            //#ifdef VENDOR_EDIT
+            //wenjie.Liu@Prd.SysApp.PowerManager, 2013/01/25, Add for :Live Folder
+			case LIVE_FOLDER_URI:
+				qb.setTables(WifiDirectShareTaskMetaData.TABLE_NAME);
+				qb.setProjectionMap(sProjectionMap);
+				qb.appendWhere("(" + WifiDirectShareTaskMetaData.TASK_TYPE + " == " + WifiDirectShareTask.TYPE_OPPS_PUSH
+                    + " OR "  + WifiDirectShareTaskMetaData.TASK_TYPE + " == " + WifiDirectShareTask.TYPE_OPPC_PULL + ")"
+                    + " AND " + "(" + WifiDirectShareTaskMetaData.TASK_STATE + " == " + WifiDirectShareTask.STATE_SUCCESS 
+                    + " OR "  + WifiDirectShareTaskMetaData.TASK_STATE + " == " + WifiDirectShareTask.STATE_REMOVED+ ")");
+                sortOrder = "_id DESC, " + sortOrder;
+				break;                
+            //#endif /* VENDOR_EDIT */                
+            default:
+                throw new IllegalArgumentException("Unknown URI " + uri);
+        }
+        String orderBy;
+        if (TextUtils.isEmpty(sortOrder)) {
+            orderBy = WifiDirectShareTaskMetaData.DEFAULT_SORT_ORDER;
+        } else {
+            orderBy = sortOrder;
+        }
+        File dbfile = new File(this.mDb.getPath());
+        if (!dbfile.exists()) {
+             Log.w(TAG,"insert: ShareDB is not exist, need create db!");
+            this.mDb.close();
+        }
+        this.mDb = this.mDbHelper.getReadableDatabase();
+        Cursor c = qb.query(this.mDb, projection, selection, selectionArgs, null, null, orderBy);
+        if (c != null) {
+            c.setNotificationUri(this.getContext().getContentResolver(), uri);
+        }
+        return c;
+    }
+    @Override
+    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
+        // change modified date
+        values.put(WifiDirectShareTaskMetaData.TASK_MODIFIED_DATE, System.currentTimeMillis());
+        File dbfile = new File(this.mDb.getPath());
+        if (!dbfile.exists()) {
+             Log.w(TAG, "update: ShareDB is not exist, need create db!");
+            this.mDb.close();
+        }
+        // update database
+        this.mDb = this.mDbHelper.getWritableDatabase();
+        int count;
+        switch (URI_MATCHER.match(uri)) {
+            case MULTIPLE_TASK_URI:
+                count = this.mDb.update(WifiDirectShareTaskMetaData.TABLE_NAME, values, selection, selectionArgs);
+                break;
+            case SINGLE_TASK_URI:
+                String rowId = uri.getPathSegments().get(1);
+                count = this.mDb.update(WifiDirectShareTaskMetaData.TABLE_NAME, values, WifiDirectShareTaskMetaData._ID + "="
+                        + rowId + (!TextUtils.isEmpty(selection) ? " AND (" + selection + ')' : ""), selectionArgs);
+                break;
+            default:
+                throw new IllegalArgumentException("Unknown URI " + uri);
+        }
+        this.getContext().getContentResolver().notifyChange(uri, null);
+        return count;
+    }
+    private static class DatabaseHelper extends SQLiteOpenHelper {
+        DatabaseHelper(Context context) {
+            super(context, DATABASE_NAME, null, DATABASE_VERSION);
+        }
+        @Override
+        public void onCreate(SQLiteDatabase db) {
+            db.execSQL("CREATE TABLE " + WifiDirectShareTaskMetaData.TABLE_NAME + " (" + WifiDirectShareTaskMetaData._ID
+                    + " INTEGER PRIMARY KEY," + WifiDirectShareTaskMetaData.TASK_TYPE + " INTEGER,"
+                    + WifiDirectShareTaskMetaData.TASK_STATE + " INTEGER," + WifiDirectShareTaskMetaData.TASK_RESULT
+                    + " TEXT," + WifiDirectShareTaskMetaData.TASK_OBJECT_NAME + " TEXT,"
+                    + WifiDirectShareTaskMetaData.TASK_OBJECT_URI + " TEXT," + WifiDirectShareTaskMetaData.TASK_OBJECT_FILE
+                    + " TEXT," + WifiDirectShareTaskMetaData.TASK_MIMETYPE + " TEXT,"
+                    + WifiDirectShareTaskMetaData.TASK_PEER_NAME + " TEXT," 
+                    //+ WifiDirectShareTaskMetaData.TASK_PEER_ADDR+ " TEXT,"
+                    + WifiDirectShareTaskMetaData.TASK_TOTAL_BYTES + " INTEGER,"
+                    + WifiDirectShareTaskMetaData.TASK_DONE_BYTES + " INTEGER,"
+                    + WifiDirectShareTaskMetaData.TASK_CREATION_DATE + " INTEGER,"
+                   // + WifiDirectShareTaskMetaData.TASK_IS_HANDOVER + " INTEGER,"
+                    + WifiDirectShareTaskMetaData.TASK_MODIFIED_DATE + " INTEGER);");
+        }
+        @Override
+        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+            Log.w(TAG,"Upgrading database from version " + oldVersion + " to " + newVersion
+                            + " (will destroy all old data)!");
+            db.execSQL("DROP TABLE IF EXISTS " + WifiDirectShareTaskMetaData.TABLE_NAME);
+            this.onCreate(db);
+        }
+    }
+}
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/share/MimeUtils.java
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/share/MimeUtils.java	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/share/MimeUtils.java	(版本 25821)
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+package com.oppo.wifidirect.share;
+import android.media.MediaFile;
+import android.webkit.MimeTypeMap;
+public class MimeUtils {
+//#ifndef VENDOR_EDIT
+//wenjie.Liu@Prd.SysApp.PowerManager, 2013/01/24, Modify for :add .csv ext for vcard file
+/*
+    public static final String VCARD_TYPE    = "text/x-vcard",
+                               VCARD_EXT    = ".vcf";
+*/
+//#else /* VENDOR_EDIT */
+	public static final String VCARD_TYPE	= "text/x-vcard",
+							   VCARD_EXT	= ".vcf",
+							   VCARD_EXT_2  = ".csv";
+//#endif /* VENDOR_EDIT */
+    /**
+     * Returns mime type of input file path
+     *
+     * @param filename
+     * @return mime-type string or null
+     */
+    public static String getMimeType( String filename ){
+        if( filename == null )    return null;
+        // For ALPS00287958, hanlde .ape etc file mimeType
+        String mimeType = MediaFile.getMimeTypeForFile( filename );
+        if( mimeType == null ){
+            String fileExtension = null;
+            int idx = filename.lastIndexOf('.');
+            if( idx > 0 ){
+                fileExtension = filename.substring( idx + 1 ).toLowerCase();
+            }
+            mimeType = MimeTypeMap.getSingleton().getMimeTypeFromExtension( fileExtension );
+        }
+        return mimeType;
+    }
+    /**
+     * Returns applied file name with ".vcf" extension
+     *
+     * @param filename
+     * @param limit: Maximum size of applied filename
+     * @return applied file name or null. A file name with ".vcf" extension will be return directly.
+     */
+    public static String applyVcardExt(String filename, int limit) {
+        String ret;
+        if ( filename == null ) return null;
+        int idx = filename.lastIndexOf('.');
+        if ( idx > 0 ){
+            String ext = filename.substring( idx ).toLowerCase();
+        //#ifndef VENDOR_EDIT
+        //wenjie.Liu@Prd.SysApp.PowerManager, 2013/01/24, Modify for :add .csv ext for vcard file
+        /*
+             if ( VCARD_EXT.equals(ext) ) return filename;       
+        */
+        //#else /* VENDOR_EDIT */
+			if ( VCARD_EXT.equals(ext) || VCARD_EXT_2.equals(ext) ) return filename;            
+        //#endif /* VENDOR_EDIT */
+        }
+        if ( filename.length() < (limit - 4) ){
+            ret = filename + VCARD_EXT;
+        }
+        else {
+            ret = filename.substring( 0, limit - 5 ) + VCARD_EXT;
+        }
+        return ret;
+    }
+}
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/share/MimeType.java
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/share/MimeType.java	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/share/MimeType.java	(版本 25821)
+/************************************************************************************
+** File: - ..\11071evt\mediatek\source\packages\Bluetooth\common\bt40\src\com\mediatek\bluetooth\MimeType.java
+** VENDOR_EDIT
+** Copyright (C), 2008-2012, OPPO Mobile Comm Corp., Ltd
+** 
+** Description: 
+**      bluetooth opp mimetype
+** 
+** Version: 0.1
+** Date created: 16:43:39,06/12/2011
+** Author: Jiehong.Tang@CommSrv.BT
+** 
+** --------------------------- Revision History: --------------------------------
+** 	<author>	<data>			<desc>
+** 
+************************************************************************************/
+package com.oppo.wifidirect.share;
+import java.io.IOException;
+import java.util.regex.Pattern;
+import java.util.HashMap;
+import java.util.ArrayList;
+//import javax.obex.HeaderSet;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.Intent;
+import android.net.Uri;
+import android.util.Log;
+import android.database.Cursor;
+//import com.oppo.os.OppoEnvironment;;
+import android.os.Environment;
+import com.oppo.os.OppoUsbEnvironment;
+import com.oppo.wifidirect.R;
+/**
+ * Bluetooth OPP internal constants definition
+ */
+public class MimeType{
+    /** Tag used for debugging/logging */
+    public static final String TAG = "MimeType";
+    public static final String BLUETOOTH_PERM = android.Manifest.permission.BLUETOOTH;
+    /**
+     * The intent that gets sent when the service must wake up for a retry Note:
+     * only retry Outbound transfer
+     */
+    public static final String ACTION_RETRY = "android.btopp.intent.action.RETRY";
+    /** the intent that gets sent when clicking a successful transfer */
+    public static final String ACTION_OPEN = "android.btopp.intent.action.OPEN";
+    /** the intent that gets sent when clicking outbound transfer notification */
+    public static final String ACTION_OPEN_OUTBOUND_TRANSFER = "android.btopp.intent.action.OPEN_OUTBOUND";
+    /** the intent that gets sent when clicking a inbound transfer notification */
+    public static final String ACTION_OPEN_INBOUND_TRANSFER = "android.btopp.intent.action.OPEN_INBOUND";
+    /** the intent that gets sent when clicking an incomplete/failed transfer */
+    public static final String ACTION_LIST = "android.btopp.intent.action.LIST";
+    /**
+     * the intent that gets sent when deleting the incoming file confirmation
+     * notification
+     */
+    public static final String ACTION_HIDE = "android.btopp.intent.action.HIDE";
+    /**
+     * the intent that gets sent when deleting the notifications of outbound and
+     * inbound completed transfer
+     */
+    public static final String ACTION_COMPLETE_HIDE = "android.btopp.intent.action.HIDE_COMPLETE";
+    /**
+     * the intent that gets sent when clicking a incoming file confirm
+     * notification
+     */
+    public static final String ACTION_INCOMING_FILE_CONFIRM = "android.btopp.intent.action.CONFIRM";
+    public static final String THIS_PACKAGE_NAME = "com.android.bluetooth";
+    /*OPPO.start:wangjimin add for changing theme 20110711*/
+    /*the intent that gets sent when changed the theme*/
+    public static final String  ACTION_THEME_CHANGED = "android.btopp.intent.action.THEME_CHANGED";
+	public static final String ALL_TRANSFERS_IN_INBOUND_SESSION_COMPLETED_ACTION = 
+        "android.btopp.intent.action.ALL_TRANSFERS_IN_INBOUND_SESSION_COMPLETE";
+    /*OPPO.end:wangjimin add for changing theme 20110711*/
+    /**
+     * The column that is used to remember whether the media scanner was invoked
+     */
+    public static final String MEDIA_SCANNED = "scanned";
+    public static final int MEDIA_SCANNED_NOT_SCANNED = 0;
+    public static final int MEDIA_SCANNED_SCANNED_OK = 1;
+    public static final int MEDIA_SCANNED_SCANNED_FAILED = 2;
+    /**
+     * The MIME type(s) of we could share to other device.
+     */
+    /*
+     * TODO: define correct type list
+     */
+    public static final String[] ACCEPTABLE_SHARE_OUTBOUND_TYPES = new String[] {
+        "image/*", "text/x-vcard",
+    };
+    /**
+     * The MIME type(s) of we could not share to other device. TODO: define
+     * correct type list
+     */
+    public static final String[] UNACCEPTABLE_SHARE_OUTBOUND_TYPES = new String[] {
+        "virus/*",
+    };
+    /**
+     * The MIME type(s) of we could accept from other device.
+     * This is in essence a "white list" of acceptable types.
+     * Today, restricted to images, audio, video and certain text types.
+     */
+    public static final String[] ACCEPTABLE_SHARE_INBOUND_TYPES = new String[] {
+        "image/*",
+        "video/*",
+        "audio/*",
+        "text/x-vcard",
+        "text/plain",
+        "text/html",
+        "application/zip",
+        "application/vnd.ms-excel",
+        "application/msword",
+        "application/vnd.ms-powerpoint",
+        "application/pdf",
+    };
+    /**
+     * The MIME type(s) of we could not accept from other device. TODO: define
+     * correct type list
+     */
+    public static final String[] UNACCEPTABLE_SHARE_INBOUND_TYPES = new String[] {
+        "text/x-vcalendar",
+        "text/x-vcard",
+    };
+    public static final String[] ACCEPTABLE_SHARE_INBOUND_CALENDAR_TYPES = new String[] {
+        "vcs",
+        "ics",
+    };
+    public static final String[] ACCEPTABLE_SHARE_INBOUND_CONTACT_TYPES = new String[] {
+        "vcf",
+        "csv",
+    };
+    public static final String[] ACCEPTABLE_SHARE_INBOUND_MUSIC_TYPES = new String[] {
+        "mp3",
+        "midi",
+		"wma",
+		"lrc",
+		"wav",
+		//#ifdef VENDOR_EDIT
+		//Jiehong.Tang@CommSrv.BT, 2012/04/09, Add for new format 
+		"aac",
+		"awb",
+		"ape",
+		"ogg",
+		"flac",
+		"imy",
+		"m4a",
+		"lrc",
+		//kecheng.Shang@SysApp.BT, 2012/08/03, Add for 
+		"mid",    
+		//#endif /* VENDOR_EDIT */
+    };
+    public static final String[] ACCEPTABLE_SHARE_INBOUND_IMAGE_TYPES = new String[] {
+        "jpg",
+        "jpeg",
+		"png",
+		"bmp",
+        "wbmp",
+		"gif",
+    };
+    public static final String[] ACCEPTABLE_SHARE_INBOUND_VEDIO_TYPES = new String[] {
+        "mp4",
+        "3gp",
+		"avi",
+		//#ifdef VENDOR_EDIT
+		//Jiehong.Tang@CommSrv.BT, 2012/04/09, Add for new format 
+		"rm",
+		"rmvb",
+		"flv",
+		"asf",
+		"wmv",
+		"srt",
+		//#ifdef VENDOR_EDIT
+		//kecheng.Shang@CommSrv.BT, 2012/05/26, Add for new format 
+		"mov",
+		"mkv",
+		//#endif /* VENDOR_EDIT */
+    };
+	public static final String[] ACCEPTABLE_SHARE_INBOUND_BOOK_TYPES = new String[] {
+        "txt",
+        "pdb",
+        "umd",
+    };
+    public static final String[] ACCEPTABLE_SHARE_INBOUND_THEME_TYPES = new String[] {
+        "theme",
+    };
+	public static final String[] ACCEPTABLE_SHARE_INBOUND_RECORDER_TYPES = new String[] {
+		//"wav",
+		"amr",
+    };
+	public static final String[] ACCEPTABLE_SHARE_INBOUND_OFFICE_TYPES = new String[] {
+        "doc",
+		"xls",
+		"ppt",
+		"pdf",
+		"docx",
+		"xlsx",
+		"pptx",
+    };
+    /** Where we store Bluetooth received files on the external storage */
+    public static final String DEFAULT_STORE_SUBDIR = "/bluetooth";
+    /**
+     * Debug level logging
+     */
+    public static final boolean DEBUG = false;
+    /**
+     * Verbose level logging
+     */
+    public static final boolean VERBOSE = false;
+    /** use TCP socket instead of Rfcomm Socket to develop */
+    public static final boolean USE_TCP_DEBUG = false;
+    /** use simple TCP server started from TestActivity */
+    public static final boolean USE_TCP_SIMPLE_SERVER = false;
+    /** Test TCP socket port */
+    public static final int TCP_DEBUG_PORT = 6500;
+    /** use emulator to debug */
+    public static final boolean USE_EMULATOR_DEBUG = false;
+    public static final int MAX_RECORDS_IN_DATABASE = 1000;
+    public static final int BATCH_STATUS_PENDING = 0;
+    public static final int BATCH_STATUS_RUNNING = 1;
+    public static final int BATCH_STATUS_FINISHED = 2;
+    public static final int BATCH_STATUS_FAILED = 3;
+    public static final String BLUETOOTHOPP_NAME_PREFERENCE = "btopp_names";
+    public static final String BLUETOOTHOPP_CHANNEL_PREFERENCE = "btopp_channels";
+    public static String filename_SEQUENCE_SEPARATOR = "-";
+    public static final String SAVE_PATH = "save_path";
+    public static final String PHONE = "Phone";
+    public static final String MEMORY_CARD = "Card";
+   //#ifndef VENDOR_EDIT
+//yimin@data.EXP, delete 2014/04/02 for store all files to WifiDirect
+    public static final int MUSIC_DEFAULT_STORE_SUBDIR = R.string.bluetooth_save_path_music;
+    public static final int IMAGE_DEFAULT_STORE_SUBDIR = R.string.bluetooth_save_path_image;
+    public static final int VEDIO_DEFAULT_STORE_SUBDIR = R.string.bluetooth_save_path_vedio;
+    public static final int BOOK_DEFAULT_STORE_SUBDIR = R.string.bluetooth_save_path_book;
+    public static final int THEME_DEFAULT_STORE_SUBDIR = R.string.bluetooth_save_path_theme;
+    public static final int RECORDER_DEFAULT_STORE_SUBDIR = R.string.bluetooth_save_path_recorder;
+    public static final int OFFICE_DEFAULT_STORE_SUBDIR = R.string.bluetooth_save_path_office;
+    public static final int OTHER_DEFAULT_STORE_SUBDIR = R.string.bluetooth_save_path_other;
+    public static final int WifiDirect_Save_WifiDirect = R.string.wifidirect_save_path_wifidirect;
+ //#endif /* VENDOR_EDIT */
+   // public static final int[] SavePathDirs = {MUSIC_DEFAULT_STORE_SUBDIR, IMAGE_DEFAULT_STORE_SUBDIR,
+      //                 VEDIO_DEFAULT_STORE_SUBDIR, OTHER_DEFAULT_STORE_SUBDIR,WifiDirect_Save_Path_WifiDirect};
+    //public static final String PHONE_ROOT = "/internal";
+    //public static final String MEMORY_CARD_ROOT = "/sdcard";
+    public static final String PHONE_ROOT = OppoUsbEnvironment.getExternalStorageDirectory().getPath();
+    public static final String MEMORY_CARD_ROOT = OppoUsbEnvironment.getExternalStorageDirectory().getPath();
+    public static final String KEYS_IN_STATISTIC = "keys_in_statistic";
+    public static final String SUMS_IN_STATISTIC = "sums_in_statistic";
+    public static final String LAST_RECEIVED_FILE_IN_DIR_IN_STATISTIC = "last_received_file_in_statistic";
+    public static final String RECEIVED_VCARD_PATH = Intent.EXTRA_STREAM;
+    public final static String ACTION_RECEIVER_VCARD = "oppo.intent.action.receive_vacrd";
+    public final static String ACTION_RECEIVER_VCALENDAR = "android.intent.action.RECEIVE_AGENDA";
+    public static String getExtensionFromFileName(String name)
+    {
+        if(null == name)
+        {
+            return null;
+        }
+        int dotIndex = name.lastIndexOf(".");
+        String extension = null;
+        if (dotIndex < 0) {
+            // should not happen. It must be pre-rejected
+            Log.i(TAG, "no extension");
+        } else {
+            extension = name.substring(dotIndex + 1);
+        }
+        if (extension != null) {
+    		Log.i(TAG, "getExtensionFromFileName extension = " + extension );
+		}
+        return extension;
+    }
+    public static String getNoExtensionFileName(String name)
+    {
+        if(null == name)
+        {
+            return null;
+        }
+        int dotIndex = name.lastIndexOf(".");
+        String filename = name;
+        if (dotIndex < 0) {
+            // should not happen. It must be pre-rejected
+            Log.i(TAG, "no extension");
+        } else {
+            filename = name.substring(0, dotIndex);
+        }
+        return filename;
+    }
+    public static int getDirTypeFromExtension(String extension)
+    {
+        int dirId = 0;
+        Log.i(TAG, "extension:" + extension);
+	//#ifndef VENDOR_EDIT
+	//yimin@data.EXP, delete 2014/04/02 for store all files to WifiDirect
+	/*
+        if(null == extension)
+        {
+            return MimeType.OTHER_DEFAULT_STORE_SUBDIR;
+        }
+        if(MimeType.mimeTypeMatches(extension.toLowerCase(), MimeType.ACCEPTABLE_SHARE_INBOUND_MUSIC_TYPES))
+        {
+            Log.i(TAG, "music file");
+            dirId = MimeType.MUSIC_DEFAULT_STORE_SUBDIR;
+        }
+        else if(MimeType.mimeTypeMatches(extension.toLowerCase(), MimeType.ACCEPTABLE_SHARE_INBOUND_IMAGE_TYPES))
+        {
+            Log.i(TAG, "image file");
+            dirId = MimeType.IMAGE_DEFAULT_STORE_SUBDIR;
+        }
+        else if(MimeType.mimeTypeMatches(extension.toLowerCase(), MimeType.ACCEPTABLE_SHARE_INBOUND_VEDIO_TYPES))
+        {
+            Log.i(TAG, "vedio file");
+            dirId = MimeType.VEDIO_DEFAULT_STORE_SUBDIR;
+        }
+		else if(MimeType.mimeTypeMatches(extension.toLowerCase(), MimeType.ACCEPTABLE_SHARE_INBOUND_BOOK_TYPES))
+        {
+            Log.i(TAG, "book file");
+            dirId = MimeType.BOOK_DEFAULT_STORE_SUBDIR;
+        }
+        else if(MimeType.mimeTypeMatches(extension.toLowerCase(), MimeType.ACCEPTABLE_SHARE_INBOUND_THEME_TYPES))
+        {
+            Log.i(TAG, "theme file");
+            dirId = MimeType.THEME_DEFAULT_STORE_SUBDIR;
+        }
+        else if(MimeType.mimeTypeMatches(extension.toLowerCase(), MimeType.ACCEPTABLE_SHARE_INBOUND_RECORDER_TYPES))
+        {
+            Log.i(TAG, "recorder file");
+            dirId = MimeType.RECORDER_DEFAULT_STORE_SUBDIR;
+        }
+		else if(MimeType.mimeTypeMatches(extension.toLowerCase(), MimeType.ACCEPTABLE_SHARE_INBOUND_OFFICE_TYPES))
+        {
+            Log.i(TAG, "office file");
+            dirId = MimeType.OFFICE_DEFAULT_STORE_SUBDIR;
+        }
+        else
+        {
+            Log.i(TAG, "other file");
+            dirId = MimeType.OTHER_DEFAULT_STORE_SUBDIR;
+        }
+        */
+        return MimeType.WifiDirect_Save_WifiDirect;
+	//#endif /* VENDOR_EDIT */
+    }
+    public static boolean isCalendarFile(String name)
+    {
+        Log.i(TAG, "isCalendarFile:" + name);
+        String extension = MimeType.getExtensionFromFileName(name);
+        if(null != extension && MimeType.mimeTypeMatches(extension.toLowerCase(), MimeType.ACCEPTABLE_SHARE_INBOUND_CALENDAR_TYPES))
+        {
+            Log.i(TAG, "calendar file");
+            return true;
+        }
+        return false;
+    }
+    public static boolean isContactFile(String name)
+    {
+        Log.i(TAG, "isContactFile:" + name);
+        String extension = MimeType.getExtensionFromFileName(name);
+        if(null != extension && MimeType.mimeTypeMatches(extension.toLowerCase(), MimeType.ACCEPTABLE_SHARE_INBOUND_CONTACT_TYPES))
+        {
+            Log.i(TAG, "contact file");
+            return true;
+        }
+        return false;
+    }
+    /*
+     * This function should be called whenever transfer status change to
+     * completed.
+     */
+    /*public static void sendIntentIfInBoundSessionCompleted(Context context, HashMap hashMap, String lastReceivedFileInDIr) {
+        if(0 >= hashMap.size())
+        {
+            if(VERBOSE) Log.i(TAG, "maybe just received calendar/contact file");
+            return;
+        }
+        Intent intent = new Intent(BluetoothShare.ALL_TRANSFERS_IN_INBOUND_SESSION_COMPLETED_ACTION);
+        intent.setClassName(THIS_PACKAGE_NAME, BluetoothOppReceiver.class.getName());   
+        ArrayList<Integer> keys = new ArrayList<Integer>(hashMap.keySet());
+        ArrayList<Integer> sums = new ArrayList<Integer>(hashMap.values());
+        intent.putIntegerArrayListExtra(KEYS_IN_STATISTIC, keys);
+        intent.putIntegerArrayListExtra(SUMS_IN_STATISTIC, sums);
+        intent.putExtra(LAST_RECEIVED_FILE_IN_DIR_IN_STATISTIC, lastReceivedFileInDIr);
+        context.sendBroadcast(intent);
+    }
+    public static void sendIntentIfOutBoundSessionCompleted(Context context) {
+        Intent intent = new Intent(BluetoothShare.ALL_TRANSFERS_IN_OUTBOUND_SESSION_COMPLETED_ACTION);
+        intent.setClassName(THIS_PACKAGE_NAME, BluetoothOppReceiver.class.getName()); 
+        context.sendBroadcast(intent);
+    }
+    */
+    public static boolean mimeTypeMatches(String mimeType, String[] matchAgainst) {
+        if(null == mimeType)
+        {
+            return false;
+        }
+        for (String matchType : matchAgainst) {
+            if (mimeTypeMatches(mimeType, matchType)) {
+                return true;
+            }
+        }
+        return false;
+    }
+    public static boolean mimeTypeMatches(String mimeType, String matchAgainst) {
+        if(null == mimeType)
+        {
+            return false;
+        }
+        Pattern p = Pattern.compile(matchAgainst.replaceAll("\\*", "\\.\\*"),
+                Pattern.CASE_INSENSITIVE);
+        return p.matcher(mimeType).matches();
+    }
+/*
+    public static void logHeader(HeaderSet hs) {
+        Log.v(TAG, "Dumping HeaderSet " + hs.toString());
+        try {
+            Log.v(TAG, "COUNT : " + hs.getHeader(HeaderSet.COUNT));
+            Log.v(TAG, "NAME : " + hs.getHeader(HeaderSet.NAME));
+            Log.v(TAG, "TYPE : " + hs.getHeader(HeaderSet.TYPE));
+            Log.v(TAG, "LENGTH : " + hs.getHeader(HeaderSet.LENGTH));
+            Log.v(TAG, "TIME_ISO_8601 : " + hs.getHeader(HeaderSet.TIME_ISO_8601));
+            Log.v(TAG, "TIME_4_BYTE : " + hs.getHeader(HeaderSet.TIME_4_BYTE));
+            Log.v(TAG, "DESCRIPTION : " + hs.getHeader(HeaderSet.DESCRIPTION));
+            Log.v(TAG, "TARGET : " + hs.getHeader(HeaderSet.TARGET));
+            Log.v(TAG, "HTTP : " + hs.getHeader(HeaderSet.HTTP));
+            Log.v(TAG, "WHO : " + hs.getHeader(HeaderSet.WHO));
+            Log.v(TAG, "OBJECT_CLASS : " + hs.getHeader(HeaderSet.OBJECT_CLASS));
+            Log.v(TAG, "APPLICATION_PARAMETER : " + hs.getHeader(HeaderSet.APPLICATION_PARAMETER));
+        } catch (IOException e) {
+            Log.e(TAG, "dump HeaderSet error " + e);
+        }
+    }
+	*/
+}
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/share/UriData.java
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/share/UriData.java	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/share/UriData.java	(版本 25821)
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+package com.oppo.wifidirect.share;
+import android.net.Uri;
+public class UriData {
+    private Uri mUri;
+    private String mData;
+    private String mName;
+    private long mSize;
+    public UriData(Uri uri) {
+        this.mUri = uri;
+    }
+    public Uri getUri() {
+        return this.mUri;
+    }
+    public String getData() {
+        return this.mData;
+    }
+    public void setData(String data) {
+        this.mData = data;
+    }
+    public String getName() {
+        return this.mName;
+    }
+    public void setName(String name) {
+        this.mName = name;
+    }
+    public long getSize() {
+        return this.mSize;
+    }
+    public void setSize(long size) {
+        this.mSize = size;
+    }
+    public String getPrintableString() {
+        return new StringBuilder().append("name[").append(this.mName).append("]").append("size[")
+                .append(this.mSize).append("]").append("data[").append(this.mData).append("]")
+                .append("uri[").append(this.mUri).append("]").toString();
+    }
+}
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/share/UriDataUtils.java
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/share/UriDataUtils.java	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/share/UriDataUtils.java	(版本 25821)
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+package com.oppo.wifidirect.share;
+import android.content.Context;
+import android.database.Cursor;
+import android.net.Uri;
+import android.provider.ContactsContract;
+import android.provider.MediaStore;
+import android.provider.MediaStore.MediaColumns;
+import android.provider.OpenableColumns;
+//import com.mediatek.bluetooth.opp.adp.OppConstants;
+//import com.mediatek.bluetooth.util.BtLog;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import android.util.Log;
+public class UriDataUtils {
+    private static final String OPPC_PUSH_TEMP_FILENAME = "__OPPC_PuSH_";
+    private static final String TAG = "UriDataUtils";
+    private static final String CALENDAR_AUTHORITY = "com.mediatek.calendarimporter";
+    private static final String LINK_SHARE_URI_SCHEME = "btlink";
+    public static UriData getUriData(Context context, Uri uri) {
+        Cursor cursor = null;
+        UriData result = null;
+        String scheme = uri.getScheme();
+        // File Uri - example: file:///sdcard/bluetooth/001.png
+        if ("file".equals(scheme)) {
+            Log.d(TAG,"getUriData() - File: " + uri);
+            result = new UriData(uri);
+            result.setData(uri.getPath());
+            result.setName(uri.getLastPathSegment());
+            result.setSize(new File(uri.getPath()).length());
+            return result;
+        } else if ("content".equals(scheme)) {
+            Log.d(TAG,"getUriData() - Content: " + uri);
+            String authority = uri.getAuthority();
+            String[] projection;
+            // Contacts
+            if (ContactsContract.AUTHORITY.equals(authority) || CALENDAR_AUTHORITY.equals(authority)) {
+                projection = new String[] {
+                        OpenableColumns.SIZE, OpenableColumns.DISPLAY_NAME
+                };
+            } else { // Media
+                projection = new String[] {
+                        OpenableColumns.SIZE, OpenableColumns.DISPLAY_NAME, MediaColumns.DATA
+                };
+            }
+            try {
+                // query from content provider
+                cursor = context.getContentResolver().query(uri, projection, null, null, null);
+                if (cursor == null || !cursor.moveToFirst()) {
+                    Log.w(TAG,"getUriData() - no query result for content uri: " + uri);
+                    return null;
+                }
+                result = new UriData(uri);
+                result.setName(cursor.getString(cursor.getColumnIndex(OpenableColumns.DISPLAY_NAME)));
+                result.setSize(cursor.getLong(cursor.getColumnIndex(OpenableColumns.SIZE)));
+                // Contacts
+                // We need convert contact filename for ALPS00277849, use
+                // date-time format as new vcard file name
+                if (ContactsContract.AUTHORITY.equals(authority) || CALENDAR_AUTHORITY.equals(authority)) {
+                    // result.setName( result.getName() );
+                    result.setName(getPushTempFileName(authority));
+                    result.setData(context.getApplicationContext().getFileStreamPath(OPPC_PUSH_TEMP_FILENAME).getPath());
+                    if (result.getSize() == 0) {
+                        InputStream in = null;
+                        try {
+                            in = context.getContentResolver().openInputStream(uri);
+                            if (in != null) {
+                                result.setSize(in.available());
+                            }
+                        } catch (FileNotFoundException ex) {
+                            Log.e(TAG,"getUriData() - get Contact vCard fail: " + ex.getMessage());
+                        } catch (IOException ex) {
+                            Log.e(TAG,"getUriData() - get Contact vCard fail: " + ex.getMessage());
+                        } finally {
+                            if (in != null) {
+                                try {
+                                    in.close();
+                                } catch (IOException ex) {
+                                    Log.e(TAG,"getUriData() - fail to close input-stream for uri[" + uri + "]");
+                                }
+                            }
+                        }
+                    }
+                } else {
+                    // Media
+                    result.setData(cursor.getString(cursor.getColumnIndex(MediaColumns.DATA)));
+                }
+                return result;
+            } finally {
+                if (cursor != null) {
+                    cursor.close();
+                }
+            }
+        }/* else if (OppClientActivity.LI
+        NK_SHARE_URI_SCHEME.equals(scheme)) {
+            BtLog.d("getUriData() - LinkShare: " + uri);
+            String text = uri.getSchemeSpecificPart();
+            String subject = uri.getFragment();
+            Uri tempFileUri = Utils.createContextFileForText(context, subject, text);
+            if (tempFileUri != null) {
+                result = new UriData(uri);
+                result.setData(tempFileUri.getPath());
+                result.setName(tempFileUri.getLastPathSegment());
+                result.setSize(new File(tempFileUri.getPath()).length());
+            }
+            return result;
+        }*/ else {
+            Log.e(TAG,"getUriData() - unsupported uri: " + uri);
+            return null;
+        }
+    }
+    /**
+     * create data file and setup file size ( in UriData object )
+     *
+     * @param context
+     * @param uriData
+     * @return
+     */
+    public static boolean openUriData(Context context, Uri uri) {
+        String scheme = uri.getScheme();
+        // File Uri - example: file:///sdcard/bluetooth/001.png
+        if ("file".equals(scheme)) {
+            // already exist => check available
+            return true;
+        } else if ("content".equals(scheme)) {
+            String authority = uri.getAuthority();
+            // Media
+            if (MediaStore.AUTHORITY.equals(authority)) {
+                // already exist => check available
+                return true;
+            } else if (ContactsContract.AUTHORITY.equals(authority) // Contacts
+                    || CALENDAR_AUTHORITY.equals(authority)) {
+                // create temp file for vCard content
+                try {
+                    // open vCard content / temp file and then copy
+                    InputStream in = context.getContentResolver().openInputStream(uri);
+                    if (in == null) {
+                        Log.e(TAG,"openUriData() - open Contact file fail: openInputStream(" + uri + ") return null");
+                        return false;
+                    }
+                    FileOutputStream out = context.getApplicationContext().openFileOutput(OPPC_PUSH_TEMP_FILENAME,
+                            Context.MODE_PRIVATE);
+                    UriDataUtils.copyStreamContent(in, out);
+                    return true;
+                } catch (FileNotFoundException ex) {
+                    Log.e(TAG,"openUriData() - open Contact file fail: " + ex.getMessage());
+                    return false;
+                } catch (IOException ex) {
+                    return false;
+                }
+            } else {
+                Log.w(TAG,"openUriData() - unsupported content uri: " + uri);
+                return false;
+            }
+        }/*else if (OppClientActivity.LINK_SHARE_URI_SCHEME.equals(scheme)) {
+            BtLog.d("getUriData() - LinkShare: " + uri);
+            String text = uri.getSchemeSpecificPart();
+            String subject = uri.getFragment();
+            Uri tempFileUri = Utils.createContextFileForText(context, subject, text);
+            return (tempFileUri != null);
+        }*/ else {
+            Log.w(TAG,"openUriData() - unsupported uri: " + uri);
+            return false;
+        }
+    }
+    /**
+     * copy the content from InputStream to OutputStream
+     *
+     * @param in
+     * @param out
+     * @return
+     * @throws IOException
+     */
+    public static long copyStreamContent(InputStream in, OutputStream out) throws IOException {
+        int read;
+        long total = 0;
+        byte[] buf = new byte[512];
+        while ((read = in.read(buf)) != -1) {
+            out.write(buf, 0, read);
+            total += read;
+        }
+        in.close();
+        out.close();
+        return total;
+    }
+    /**
+     * close the opened task data ( open by oppcOpenTaskData )
+     *
+     * @param task
+     * @return success or failure
+     */
+    public static void closeUriData(Context context, Uri uri) {
+        String scheme = uri.getScheme();
+        if ("content".equals(scheme)) {
+            String authority = uri.getAuthority();
+            // Contacts & Calendar
+            if (ContactsContract.AUTHORITY.equals(authority) || CALENDAR_AUTHORITY.equals(authority)) {
+                context.getApplicationContext().deleteFile(OPPC_PUSH_TEMP_FILENAME);
+            }
+        }
+    }
+    /**
+     * get temp file name for contact/calender objects
+     *
+     * @param authority
+     * @return temp file name
+     */
+    public static String getPushTempFileName(String authority) {
+        String tempFileName = null;
+        SimpleDateFormat tempFormatter = new SimpleDateFormat("yyyyMMdd_hhmmss");
+        Date curDate = new Date(System.currentTimeMillis());
+        String timeStr = tempFormatter.format(curDate);
+        // Contacts - such as 20120508_132345.vcf
+        if (ContactsContract.AUTHORITY.equals(authority)) {
+            tempFileName = timeStr + ".vcf";
+        } else if (CALENDAR_AUTHORITY.equals(authority)) { // Calendar - such as 20120508_132345.vcs
+            tempFileName = timeStr + ".vcs";
+        } else {
+            tempFileName = timeStr;
+        }
+        return tempFileName;
+    }
+}
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/share/OppBtErrorActivity.java
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/share/OppBtErrorActivity.java	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/share/OppBtErrorActivity.java	(版本 25821)
+/************************************************************************************
+** File: - ..\mediatek\source\packages\Bluetooth\profiles\opp\src\com\mediatek\bluetooth\opp\mmi\OppBtErrorActivity.java
+** VENDOR_EDIT
+** Copyright (C), 2008-2012, OPPO Mobile Comm Corp., Ltd
+** 
+** Description: 
+**      bluetooth opp error dialog
+** 
+** Version: 0.1
+** Date created: 16:43:39,06/12/2011
+** Author: Jiehong.Tang@CommSrv.BT
+** 
+** --------------------------- Revision History: --------------------------------
+** 	<author>	<data>			<desc>
+** 
+************************************************************************************/
+/*
+ * Copyright (c) 2008-2009, Motorola, Inc.
+ *
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * - Redistributions of source code must retain the above copyright notice,
+ * this list of conditions and the following disclaimer.
+ *
+ * - Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * - Neither the name of the Motorola, Inc. nor the names of its contributors
+ * may be used to endorse or promote products derived from this software
+ * without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+package com.oppo.wifidirect.share;
+import com.oppo.wifidirect.R;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.os.Bundle;
+import android.view.View;
+import android.widget.TextView;
+import com.android.internal.app.AlertActivity;
+import com.android.internal.app.AlertController;
+/**
+ * This class is designed to show BT error messages;
+ */
+public class OppBtErrorActivity extends AlertActivity implements
+        DialogInterface.OnClickListener {
+    private String mErrorContent;
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        Intent intent = getIntent();
+        String mErrorTitle = intent.getStringExtra("title");
+        mErrorContent = intent.getStringExtra("content");
+        // Set up the "dialog"
+        final AlertController.AlertParams p = mAlertParams;
+        p.mIconId = android.R.drawable.ic_dialog_alert;
+        p.mTitle = mErrorTitle;
+        p.mView = createView();
+        p.mPositiveButtonText = getString(R.string.bt_error_btn_ok);
+        p.mPositiveButtonListener = this;
+        setupAlert();
+    }
+    private View createView() {
+        View view = getLayoutInflater().inflate(R.layout.opp_confirm_dialog, null);
+        TextView contentView = (TextView)view.findViewById(R.id.content);
+        contentView.setText(mErrorContent);
+        return view;
+    }
+    public void onClick(DialogInterface dialog, int which) {
+        switch (which) {
+            case DialogInterface.BUTTON_POSITIVE:
+                break;
+        }
+    }
+}
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/share/OppHistoryActivity.java
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/share/OppHistoryActivity.java	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/share/OppHistoryActivity.java	(版本 25821)
+/************************************************************************************
+** File: - ..\mediatek\source\packages\Bluetooth\profiles\opp\src\com\mediatek\bluetooth\opp\mmi\OppHistoryActivity.java
+** VENDOR_EDIT
+** Copyright (C), 2008-2012, OPPO Mobile Comm Corp., Ltd
+** 
+** Description: 
+**      bluetooth opp history
+** 
+** Version: 0.1
+** Date created: 16:43:39,06/12/2011
+** Author: Jiehong.Tang@CommSrv.BT
+** 
+** --------------------------- Revision History: --------------------------------
+** 	<author>	<data>			<desc>
+** 
+************************************************************************************/
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+package com.oppo.wifidirect.share;
+import com.oppo.wifidirect.R;
+import android.app.Activity;
+import android.app.AlertDialog;
+//import android.bluetooth.BluetoothAdapter;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.database.Cursor;
+import android.net.Uri;
+import android.os.Bundle;
+import android.util.Log;
+import android.view.ContextMenu;
+import android.view.Menu;
+import android.view.MenuInflater;
+import android.view.MenuItem;
+import android.view.View;
+import android.view.ContextMenu.ContextMenuInfo;
+import android.widget.AdapterView;
+import android.widget.ListView;
+import android.widget.AdapterView.OnItemClickListener;
+import android.app.ProgressDialog;
+import android.os.Handler;
+import android.os.Message;
+import android.content.Context;
+import android.content.ContentResolver;
+import com.oppo.wifidirect.share.WifiDirectShareTask.Direction;
+import android.content.ContentValues;
+import java.io.File;
+import android.content.pm.PackageManager;
+import java.util.List;
+import android.content.pm.ResolveInfo;
+//import com.oppo.file.OppoFileOperator;
+import android.provider.ContactsContract.Contacts;
+import android.content.ActivityNotFoundException;
+import com.oppo.wifidirect.DataService;
+//import com.mediatek.bluetooth.share.WifiDirectShareTask;
+//import com.mediatek.bluetooth.share.WifiDirectShareTask.WifiDirectShareTaskMetaData;
+//import com.mediatek.bluetooth.opp.adp.OppManager;
+//import com.mediatek.bluetooth.opp.mmi.OppTransferInfo;
+/**
+ * View showing the user's finished bluetooth opp transfers that the user does
+ * not confirm. Including outbound and inbound transfers, both successful and
+ * failed. *
+ */
+public class OppHistoryActivity extends Activity implements
+        View.OnCreateContextMenuListener, OnItemClickListener {
+	private static final String TAG = "OppHistoryActivity";
+    private ListView mListView;
+    private Cursor mTransferCursor;
+    private OppTransferAdapter mTransferAdapter;
+    private int mIdColumnId;
+    private int mContextMenuPosition;
+	private boolean bDirectionIn;
+	ContentResolver  mContentResolver ;
+    /** Class to handle Notification Manager updates */
+    //private BluetoothOppNotification mNotifier;
+    @Override
+    public void onCreate(Bundle icicle) {
+        Log.d(TAG ,"onCreate()");
+        super.onCreate(icicle);
+        setContentView(R.layout.bluetooth_transfers_page);
+        mListView = (ListView)findViewById(R.id.list);
+        mListView.setEmptyView(findViewById(R.id.empty));
+		Log.d(TAG, "OppHistoryActivity.onCreate() mTransferCursor is not NULL ");
+        String direction;
+        bDirectionIn = getIntent().getBooleanExtra("isDirectionIn", true);
+        if (bDirectionIn) {
+            setTitle(getText(R.string.inbound_history_title));
+            direction = OppTransferInfo.WHERE_INBOUND;
+        } else {
+            setTitle(getText(R.string.outbound_history_title));
+             direction = OppTransferInfo.WHERE_OUTBOUND;
+        }
+        final String selection = "(" +OppTransferInfo.WHERE_SUCCESS 
+								 + " OR " + OppTransferInfo.WHERE_FAILED + ")"
+								 + " AND " + direction;
+        final String sortOrder = WifiDirectShareTaskMetaData.TASK_MODIFIED_DATE + " DESC";
+		Log.d(TAG, "OppHistoryActivity.onCreate() selection = " + selection);
+        mTransferCursor = managedQuery(WifiDirectShareTaskMetaData.CONTENT_URI, new String[] {
+                "_id", WifiDirectShareTaskMetaData.TASK_OBJECT_NAME, WifiDirectShareTaskMetaData.TASK_STATE,
+                WifiDirectShareTaskMetaData.TASK_TOTAL_BYTES, WifiDirectShareTaskMetaData.TASK_PEER_NAME, WifiDirectShareTaskMetaData.TASK_MODIFIED_DATE,
+                WifiDirectShareTaskMetaData.TASK_OBJECT_FILE, WifiDirectShareTaskMetaData.TASK_TYPE,WifiDirectShareTaskMetaData.TASK_MIMETYPE
+        }, selection, sortOrder);
+        // only attach everything to the listbox if we can access
+        // the transfer database. Otherwise, just show it empty
+        if (mTransferCursor != null) {
+			Log.d( TAG,"OppHistoryActivity.onCreate() mTransferCursor is not NULL ");
+            mIdColumnId = mTransferCursor.getColumnIndexOrThrow("_id");
+			Log.d( TAG,"OppHistoryActivity.onCreate() mIdColumnId = " + mIdColumnId);
+            // Create a list "controller" for the data
+            mTransferAdapter = new OppTransferAdapter(this,
+                    R.layout.bluetooth_transfer_item, mTransferCursor);
+            mListView.setAdapter(mTransferAdapter);
+            mListView.setScrollBarStyle(View.SCROLLBARS_INSIDE_INSET);
+            mListView.setOnCreateContextMenuListener(this);
+            mListView.setOnItemClickListener(this);
+        }
+		mContext = this;
+		mContentResolver  = getContentResolver();
+    }
+    @Override
+    public boolean onCreateOptionsMenu(Menu menu) {
+        if (mTransferCursor != null) {
+            MenuInflater inflater = getMenuInflater();
+            inflater.inflate(R.menu.transferhistory, menu);
+        }
+        return true;
+    }
+    @Override
+    public boolean onPrepareOptionsMenu(Menu menu) {
+        boolean showClear = getClearableCount() > 0;
+        menu.findItem(R.id.transfer_menu_clear_all).setEnabled(showClear);
+        return super.onPrepareOptionsMenu(menu);
+    }
+	//oppo.zyx:modify bug 206942 10089-7480 10089-7557
+	//add progerssBar when delete history
+	@Override
+    public void onStop() {
+        super.onStop();
+		if(null != mThread)
+		{	
+			try {
+				mThread.interrupt();
+				mThread.join();
+				mThread = null;
+			} catch (InterruptedException e) {
+                Log.i(TAG,"Interrupted waiting for thread to join");
+            }
+		}
+		mHandler.removeMessages(CLOSE_DIALOG);
+    }
+	@Override
+    public void onDestroy() {
+        super.onDestroy();
+		if(null != mThread)
+		{	
+			mThread.interrupt();
+			mThread = null;
+		}
+		mHandler.removeMessages(CLOSE_DIALOG);
+    }
+	ProgressDialog mProgressDialog;
+	Context mContext;
+	Thread mThread = null;
+    private static final int SHOW_DIALOG = 1;
+    private static final int CLOSE_DIALOG = 2;
+	Handler mHandler = new Handler(){
+        public void handleMessage(Message msg) {    
+           switch (msg.what) {    
+		   		case SHOW_DIALOG:
+				{
+					mProgressDialog = ProgressDialog.show(mContext, 
+                        mContext.getResources().getString(R.string.clear_history), 
+                        mContext.getResources().getString(R.string.clearing_history), true, false);
+					mHandler.sendEmptyMessageDelayed(CLOSE_DIALOG, 1000 * 20);
+					mThread = new Thread(new Runnable()
+						{
+							public void run()
+							{
+								clearAllDownloads();
+								mHandler.removeMessages(CLOSE_DIALOG);
+								if(null != mProgressDialog)
+			                    {
+			                        mProgressDialog.dismiss();
+			                        mProgressDialog = null;
+			                    }
+								finish();
+							}	
+						}
+					);
+					mThread.start();
+					//must in main thread, if not will result some bugs
+					//because cursor will be updated in main thread!
+					/*clearAllDownloads();
+					mHandler.removeMessages(CLOSE_DIALOG);
+					if(null != mProgressDialog)
+                    {
+                        mProgressDialog.dismiss();
+                        mProgressDialog = null;
+                    }*/
+				}
+				break;
+				case CLOSE_DIALOG:
+                {
+                    if(null != mProgressDialog)
+                    {
+                        mProgressDialog.dismiss();
+                        mProgressDialog = null;
+                    }
+                }
+                break;
+				default:break;   
+		   }
+		}
+	};
+	//oppo.zyx:modify end
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        switch (item.getItemId()) {
+            case R.id.transfer_menu_clear_all:
+                promptClearList();
+                return true;
+        }
+        return false;
+    }
+    @Override
+    public boolean onContextItemSelected(MenuItem item) {
+        mTransferCursor.moveToPosition(mContextMenuPosition);
+        switch (item.getItemId()) {
+            case R.id.transfer_menu_open:
+                onCompleteTransferClicked(true);
+                updateNotificationWhenBtDisabled();
+                return true;
+            case R.id.transfer_menu_clear:
+                onCompleteTransferClicked(false);
+                updateNotificationWhenBtDisabled();
+                return true;
+        }
+        return false;
+    }
+    @Override
+    public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo) {
+        if (mTransferCursor != null) {
+            AdapterView.AdapterContextMenuInfo info = (AdapterView.AdapterContextMenuInfo)menuInfo;
+            mTransferCursor.moveToPosition(info.position);
+            mContextMenuPosition = info.position;
+            String fileName = mTransferCursor.getString(mTransferCursor
+                    .getColumnIndexOrThrow(WifiDirectShareTaskMetaData.TASK_OBJECT_NAME));
+            if (fileName == null) {
+                fileName = this.getString(R.string.unknown_file);
+            }
+            menu.setHeaderTitle(fileName);
+            MenuInflater inflater = getMenuInflater();
+            inflater.inflate(R.menu.transferhistorycontextfinished, menu);
+        }
+    }
+    /**
+     * Prompt the user if they would like to clear the transfer history
+     */
+    private void promptClearList() {
+        new AlertDialog.Builder(this).setTitle(R.string.transfer_clear_dlg_title).setMessage(
+                R.string.transfer_clear_dlg_msg).setPositiveButton(android.R.string.ok,
+                new DialogInterface.OnClickListener() {
+                    public void onClick(DialogInterface dialog, int whichButton) {
+                        //oppo.zyx:modify bug 206942
+						//android code
+						clearAllDownloads();
+						mHandler.sendEmptyMessageDelayed(SHOW_DIALOG, 100);
+						//oppo.zyx:modify end
+                    }
+                }).setNegativeButton(android.R.string.cancel, null).show();
+    }
+    /**
+     * Get the number of finished transfers, including error and success.
+     */
+    private int getClearableCount() {
+        int count = 0;
+        if (mTransferCursor.moveToFirst()) {
+            while (!mTransferCursor.isAfterLast()) {
+                int statusColumnId = mTransferCursor.getColumnIndexOrThrow(WifiDirectShareTaskMetaData.TASK_STATE);
+                int status = mTransferCursor.getInt(statusColumnId);
+                if (OppTransferInfo.isStatusCompleted(status)) {
+                    count++;
+                }
+                mTransferCursor.moveToNext();
+            }
+        }
+        return count;
+    }
+    /**
+     * Clear all finished transfers, error and success transfer items.
+     */
+    private void clearAllDownloads() {
+		//OppManager oppManager = OppManager.getInstance(this);
+		if(bDirectionIn){
+		  removeAllRecords( WifiDirectShareTask.Direction.in);
+		}
+		else{
+		  removeAllRecords( WifiDirectShareTask.Direction.out);
+		}
+		updateNotificationWhenBtDisabled();
+    }
+    /*
+     * (non-Javadoc)
+     * @see
+     * android.widget.AdapterView.OnItemClickListener#onItemClick(android.widget
+     * .AdapterView, android.view.View, int, long)
+     */
+    public void onItemClick(AdapterView parent, View view, int position, long id) {
+        // Open the selected item
+        mTransferCursor.moveToPosition(position);
+        onCompleteTransferClicked(true);
+        updateNotificationWhenBtDisabled();
+    }
+    /**
+     * Open the selected finished transfer. mDownloadCursor must be moved to
+     * appropriate position before calling this function
+     */
+    private void onCompleteTransferClicked(boolean bOpen) {
+        Log.d(TAG,"onCompleteTransferClicked");
+        WifiDirectShareTask sharetask;
+        int sessionId = mTransferCursor.getInt(mIdColumnId);
+	//	OppManager oppManager = OppManager.getInstance(this);
+        Uri contentUri = Uri.parse(WifiDirectShareTaskMetaData.CONTENT_URI + "/" + sessionId);
+       //ppTransferInfo transInfo = new OppTransferInfo();
+       //transInfo = OppTransferUtility.queryRecord(this, contentUri);
+       if(mTransferCursor == null){
+            Log.d(TAG,"mTransferCursor = = null");
+            return ;  
+       }
+        sharetask = new WifiDirectShareTask(mTransferCursor);
+       //if (transInfo == null) {
+       //     Log.e(TAG,"Error: Can not get data from db");
+       //     return;
+       // }
+		if(!bOpen)
+		{
+			if(bDirectionIn){
+				removeSingleRecord(contentUri, WifiDirectShareTask.Direction.in,this);
+			}
+			else{
+				removeSingleRecord(contentUri, WifiDirectShareTask.Direction.out,this);
+			}
+			return;
+		}
+        if ((sharetask.getType()== WifiDirectShareTask.TYPE_OPPS_PUSH) && (sharetask.getState() == WifiDirectShareTask.STATE_SUCCESS)) {
+            Log.d(TAG,"openReceivedFile");
+            openReceivedFile(mContext, sharetask.getData(),sharetask.getMimeType(),
+                    sharetask.getModifiedDate(), contentUri);
+			if(bDirectionIn){
+				removeSingleRecord(contentUri, WifiDirectShareTask.Direction.in,this);
+			}
+			else{
+				removeSingleRecord(contentUri, WifiDirectShareTask.Direction.out,this);
+			}
+        } else {
+            Intent in = new Intent(this, OppTransferActivity.class);
+            in.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+            in.setData(contentUri);
+            this.startActivity(in);
+        }
+    }
+    /**
+     * When Bluetooth is disabled, notification can not be updated by
+     * ContentObserver in OppService, so need update manually.
+     */
+    private void updateNotificationWhenBtDisabled() {
+       // BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
+        //if (!adapter.isEnabled()) {
+			//OppManager oppManager = OppManager.getInstance(this);
+            //if (V) Log.v(TAG, "Bluetooth is not enabled, update notification manually.");
+            DataService.refreshFinishedOppNotify(WifiDirectShareTask.Direction.in,this);            
+			DataService.refreshFinishedOppNotify(WifiDirectShareTask.Direction.out,this);
+    //    }
+    }
+    public  static   void removeSingleRecord(Uri uri, Direction taskDirection,Context mContext){
+		if(uri != null){
+			if(taskDirection == WifiDirectShareTask.Direction.out){
+				mContext.getContentResolver().delete( uri, null, null);
+			}else if(taskDirection == WifiDirectShareTask.Direction.in){
+				ContentValues values = new ContentValues();
+				values.put( WifiDirectShareTaskMetaData.TASK_STATE, WifiDirectShareTask.STATE_REMOVED );
+				//first we try to update the success state to removed
+				int count = mContext.getContentResolver().update( uri, values, OppTransferInfo.WHERE_SUCCESS, null );			
+				if(count != 1){
+					//if no one is updated, it means that the task's state is failure, try to remove it from db
+					mContext.getContentResolver().delete( uri, null, null);
+				}
+			}
+			DataService.refreshFinishedOppNotify(taskDirection,mContext);
+		}
+	}
+	public static void openReceivedFile(Context context, String fileName, String mimetype,
+            Long timeStamp, Uri uri)
+	{
+	  //#ifndef VENDOR_EDIT
+          //yimin@exp.data.modify,2014/3/25
+        if (fileName == null /*|| mimetype == null*/) {
+            Log.e(TAG,"ERROR: Para fileName ==null, or mimetype == null");
+            return;
+        }
+      /*
+        File f = new File(fileName);
+       if (!f.exists()) {
+            Intent in = new Intent(context, OppBtErrorActivity.class);
+            in.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+            in.putExtra("title", context.getString(R.string.not_exist_file));
+            in.putExtra("content", context.getString(R.string.not_exist_file_desc));
+            context.startActivity(in);
+            return;
+        }
+        Uri path = Uri.parse(fileName);
+        // If there is no scheme, then it must be a file
+        if (path.getScheme() == null) {
+            path = Uri.fromFile(new File(fileName));
+        }
+		int fileType = OppoFileOperator.getFileType(fileName);
+		Intent intent = new Intent(Intent.ACTION_VIEW);
+		uri = Uri.fromFile(new File(fileName));
+		boolean canOpen = false;
+		switch(fileType){
+			case OppoFileOperator.IMAGE_TYPE: 
+				canOpen = true;
+				intent.setDataAndType(uri, "image/*");
+				break;
+			case OppoFileOperator.VIDEO_TYPE:
+				canOpen = true;
+				intent.setDataAndType(uri, "video/*");
+				break;	
+			case OppoFileOperator.AUDIO_TYPE:
+			case OppoFileOperator.WAV_TYPE:
+            case OppoFileOperator.AMR_TYPE:
+				canOpen = true;
+				intent.setDataAndType(uri, "audio/*");
+				break;
+			case OppoFileOperator.HTML_TYPE:
+				canOpen = true;
+				intent.setDataAndType(uri, "text/html");
+				break;
+			case OppoFileOperator.TXT_TYPE: 
+			case OppoFileOperator.LRC_TYPE:
+            case OppoFileOperator.EPUB_TYPE:
+				canOpen = true;
+				intent.setDataAndType(uri, "text/txt");
+				break;
+			case OppoFileOperator.OPUB_TYPE:
+				canOpen = true;
+				intent = new Intent("com.oppo.reader.textbrowser");
+				intent.setDataAndType(uri, "text/txt");
+				break;
+			case OppoFileOperator.APPLICATION_TYPE:
+				canOpen = true;
+				//uri = Uri.fromFile(new File(fileName));
+				intent.setDataAndType(uri, "application/vnd.android.package-archive");
+				break;
+			case OppoFileOperator.DOC_TYPE:
+            case OppoFileOperator.DOCX_TYPE:{
+				canOpen = true;
+				intent.setDataAndType(uri, "application/vnd.ms-word");
+                break;
+            }
+            case OppoFileOperator.XLS_TYPE:
+            case OppoFileOperator.XLSX_TYPE:{
+				canOpen = true;
+				intent.setDataAndType(uri, "application/vnd.ms-excel");
+                break;
+            }
+            case OppoFileOperator.PPT_TYPE:
+            case OppoFileOperator.PPTX_TYPE:{
+				canOpen = true;
+				intent.setDataAndType(uri, "application/vnd.ms-powerpoint");
+                break;
+            }
+            case OppoFileOperator.PDF_TYPE:{
+				canOpen = true;
+				intent.setDataAndType(uri, "application/pdf");
+                break;
+            }
+            case OppoFileOperator.CSV_TYPE:
+            case OppoFileOperator.VCF_TYPE:{
+				canOpen = true;
+                intent.setType(Contacts.CONTENT_VCARD_TYPE);
+                intent.putExtra(Intent.EXTRA_STREAM, fileName);
+				break;
+			}
+			case OppoFileOperator.THEME_TYPE:{
+				canOpen = true;
+				intent = new Intent("android.intent.action.OPPO_PREVIEW_THEME");
+                intent.putExtra("oppo_preview_theme_path", fileName);
+                break;
+            }
+			default:break;
+		}
+		if(canOpen)
+		{
+			intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+            try {
+                Log.d(TAG, "ACTION_VIEW intent sent out: " + path + " / " + mimetype);
+                context.startActivity(intent);
+            } catch (ActivityNotFoundException ex) {
+                Log.d( TAG,"no activity for handling ACTION_VIEW intent:  " + mimetype);
+            }
+		}
+		else
+		{
+			Intent in = new Intent(context, OppBtErrorActivity.class);
+            in.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+            in.putExtra("title", context.getString(R.string.unknown_file));
+            in.putExtra("content", context.getString(R.string.unknown_file_desc));
+            context.startActivity(in);
+		}
+	 */
+	         File file = new File(fileName);
+            if (file.exists()){
+                Uri path = Uri.fromFile(file);
+                Intent intent = new Intent(Intent.ACTION_VIEW);
+                intent.setDataAndType(path,mimetype);
+                PackageManager pm = context.getPackageManager();
+                List<ResolveInfo> activities = pm.queryIntentActivities(intent, 0);
+                if (activities.size() > 0){
+                    context.startActivity(intent);
+                }
+            } else {
+                Intent in = new Intent(context, OppBtErrorActivity.class);            
+                in.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);            
+                in.putExtra("title", context.getString(R.string.not_exist_file));            
+                in.putExtra("content", context.getString(R.string.not_exist_file_desc));            
+                context.startActivity(in);
+            }
+	 //#endif /* VENDOR_EDIT */
+    }
+  private  void removeAllRecords(Direction taskDirection){
+		ContentValues values = new ContentValues();
+				values.put( WifiDirectShareTaskMetaData.TASK_STATE, WifiDirectShareTask.STATE_REMOVED );
+		this.mContentResolver.delete(WifiDirectShareTaskMetaData.CONTENT_URI,
+									OppTransferInfo.WHERE_FAILED + " AND " + getDirectionString(taskDirection),
+									null);
+		this.mContentResolver.update(WifiDirectShareTaskMetaData.CONTENT_URI, 
+									values, 
+									OppTransferInfo.WHERE_SUCCESS + " AND " + getDirectionString(taskDirection), 
+									null );	
+        //#ifdef VENDOR_EDIT
+        //Jiehong.Tang@CommSrv.BT, 2011/08/18, Add for  refresh opp notify
+      DataService.refreshFinishedOppNotify(taskDirection,this); 
+        //#endif /* VENDOR_EDIT */
+	} 
+  private String getDirectionString(Direction taskDirection){
+		if(WifiDirectShareTask.Direction.in == taskDirection){
+			return OppTransferInfo.WHERE_INBOUND;
+		}
+		else if(WifiDirectShareTask.Direction.out == taskDirection){
+			return OppTransferInfo.WHERE_OUTBOUND;
+		}
+		else{
+			return null;
+		}
+	}
+}
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/WifiP2pStateReceiver.java
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/WifiP2pStateReceiver.java	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/WifiP2pStateReceiver.java	(版本 25821)
+package com.oppo.wifidirect;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.net.NetworkInfo;
+import android.net.wifi.p2p.WifiP2pInfo;
+import android.net.wifi.p2p.WifiP2pManager;
+import android.util.Log;
+public class WifiP2pStateReceiver extends BroadcastReceiver {
+    private final String tag = "WifiP2pBroadcastReceiver";
+    private static Intent startIntent = null;
+    private static Intent startDataIntent = null;
+    private static Intent stopIntent = null;
+    private static Intent stopDataIntent = null;
+    @Override
+    public void onReceive(Context context, Intent intent) {
+        String action = intent.getAction();
+        Log.d(tag, "Receive " + action);   
+        if(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION.equals(action)) {
+            NetworkInfo networkInfo = (NetworkInfo) intent.getParcelableExtra(
+                        WifiP2pManager.EXTRA_NETWORK_INFO);
+            WifiP2pInfo info = (WifiP2pInfo)intent.getParcelableExtra(
+                    WifiP2pManager.EXTRA_WIFI_P2P_INFO);
+            Log.e(tag, "networkInfo.state " + networkInfo.getState());
+            if (networkInfo.isConnected()) {
+                startIntent = new Intent(context,ControlService.class);
+                startDataIntent = new Intent(context,DataService.class);
+                if(!info.isGroupOwner) {
+                    startIntent.putExtra("address", info.groupOwnerAddress.getHostAddress());
+                    startIntent.putExtra("groupRole", 1);
+                    startDataIntent.putExtra("address", info.groupOwnerAddress.getHostAddress());
+                    startDataIntent.putExtra("groupRole", 1);
+                    Log.e(tag,"+++++begin client +++++++");
+                }
+                else {
+                    startIntent.putExtra("groupRole", 0);
+                    startDataIntent.putExtra("groupRole", 0);
+                    Log.e(tag,"+++++begin server +++++++");
+                }
+                startIntent.putExtra("command", "start");
+                startDataIntent.putExtra("command", "start");
+                context.startService(startIntent);
+                context.startService(startDataIntent);
+            } else {
+                Log.e(tag,"+++++stop server +++++++");
+                stopDataIntent = new Intent(context,DataService.class);
+                stopDataIntent.putExtra("command", "stop");
+                context.startService(stopDataIntent);
+                stopIntent = new Intent(context,ControlService.class);
+                stopIntent.putExtra("command", "stop");
+                context.startService(stopIntent);
+                startIntent = null;
+                startDataIntent = null;
+                stopDataIntent = null;
+                stopIntent = null;
+            }
+        }
+    }
+}
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/DataService.java
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/DataService.java	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/DataService.java	(版本 25821)
+ package com.oppo.wifidirect;
+import com.oppo.wifidirect.R;
+import com.oppo.wifidirect.IDataService;
+import com.oppo.wifidirect.ui.HistoryConfirmDialog;
+import com.oppo.wifidirect.util.CalculateFreeSpace;
+import com.oppo.wifidirect.util.MediaScanner;
+import android.app.Notification;
+import android.app.NotificationManager;
+import android.app.PendingIntent;
+import android.app.Service;  
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;  
+import android.content.IntentFilter;
+import android.os.Binder;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.HandlerThread;
+import android.os.IBinder;
+import android.os.Looper;
+import android.os.Message;
+import android.os.Messenger;
+import android.util.Log;
+import android.widget.RemoteViews;
+import android.widget.Toast;
+import com.android.internal.util.AsyncChannel;
+import java.io.BufferedInputStream;
+import java.io.BufferedOutputStream;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.FileInputStream;
+import java.net.InetSocketAddress;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.util.ArrayList;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.Future;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+//#ifdef VENDOR_EDIT
+//kecheng.Shang@SysApp.BT, 2013/05/03, Add for 
+ import android.content.ContentResolver; 
+ import android.net.Uri;
+ import com.oppo.wifidirect.share.WifiDirectShareTask;
+ import com.oppo.wifidirect.share.WifiDirectShareTask.Direction;
+ import com.oppo.wifidirect.share.WifiDirectShareTaskMetaData;
+ import com.oppo.wifidirect.share.SystemUtils;
+ import com.oppo.wifidirect.share.MimeType;
+ import com.oppo.wifidirect.share.OppTransferInfo;
+ import com.oppo.wifidirect.share.OppHistoryActivity;
+ import com.oppo.wifidirect.share.MimeUtils;
+ import com.oppo.wifidirect.share.UriDataUtils;
+ import com.oppo.wifidirect.share.Utils;
+ import com.oppo.wifidirect.share.UriData;
+ import java.util.HashMap;
+ import java.util.Iterator;
+ import android.content.ContentValues;
+ import android.database.Cursor;
+ import android.content.res.Resources;
+//#endif /* VENDOR_EDIT */
+public class DataService extends Service {
+     private final static  String tag = "DataService";
+    private Context mContext;
+    private HashMap<Integer, TrasferRecord> recordMap = new HashMap<Integer, TrasferRecord>();
+    private AsyncChannel mReplyChannel = new AsyncChannel();
+    private Messenger mDataMessager;
+    private Handler mDataServiceHandler;
+    private int groupRole;
+    private int dataRole;
+    private int mServiceStartId;
+    private String address;
+    private ExecutorService sendExecutor;
+    private ExecutorService receiveExecutor;
+    private ServerSocket receiveServerSocket;
+    private ServerSocket sendServerSocket;
+    private List sendList;
+    private final int P2P_SEND_FILE_REQUEST = 1;
+    private final int P2P_SEND_FILE_RESPONSE_SUCCESS = 2;
+    private final int P2P_SEND_FILE_RESPONSE_FAIL = 3;
+    private final int P2P_RECEIVE_FILE_REQUEST = 4;
+    private final int P2P_RECEIVE_FILE_RESPONSE_SUCCESS = 5;
+    private final int P2P_RECEIVE_FILE_RESPONSE_FAIL = 6;
+//#ifdef VENDOR_EDIT
+//kecheng.Shang@SysApp.BT, 2013/05/03, Add for 
+    ContentResolver mResolver;
+    public static final int OPP_NOTIFICATION_ID_IN_FINISHED = 100012; 
+							//NotificationFactory.getProfileNotificationId( BluetoothProfile.ID_OPP, 12);
+	public static final int OPP_NOTIFICATION_ID_OUT_FINISHED = 10013;
+							//NotificationFactory.getProfileNotificationId( BluetoothProfile.ID_OPP, 13);
+//#endif /* VENDOR_EDIT */
+    private static final int SEND_BEGIN_TOAST_MSG = 0;
+    private static final int SEND_END_TOAST_MSG = 1;
+    private static final int SEND_INTERRUPT_TOAST_MSG = 2;
+    private static final int RECEIVE_BEGIN_TOAST_MSG = 3;
+    private static final int RECEIVE_END_TOAST_MSG = 4;
+    private static final int RECEIVE_INTERRUPT_TOAST_MSG = 5;
+    private static final int FILE_PATH = 6;
+    private NotificationManager mNm = null;
+    private final String ACTION_CANCEL_TRANSFER = "ACTION_WIFIDIRECT_CANCEL_FILE_TRANSFER";
+    private final IntentFilter mIntentFilter = new IntentFilter();
+    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+            Log.d(tag, "receive action: " + action);
+            if(Intent.ACTION_MEDIA_SHARED.equals(action)) {
+                removeAllFuture();
+                //showToast(ddd,null);
+            } else if(Intent.ACTION_MEDIA_EJECT.equals(action)) {
+                removeAllFuture();
+                //showToast(ddd,null);
+            }
+        }
+    };
+private Resources res;
+    @Override
+    public void onCreate() {
+        super.onCreate(); 
+        Log.e(tag,"onCreate");
+        mContext = this;
+        mDataServiceHandler = new DataServiceHandler();
+        mDataMessager = new Messenger(mDataServiceHandler);
+        sendExecutor = Executors.newCachedThreadPool();
+        receiveExecutor = Executors.newCachedThreadPool();
+     // mContentResolver  = getContentResolver();
+        mResolver = getContentResolver();
+        res = getResources();
+        mIntentFilter.addAction(Intent.ACTION_MEDIA_SHARED);
+        mIntentFilter.addAction(Intent.ACTION_MEDIA_EJECT); 
+        mIntentFilter.addDataScheme("file");
+        this.registerReceiver(mReceiver, mIntentFilter);
+        if (mNm == null) {
+			mNm = (NotificationManager) mContext
+					.getSystemService(Context.NOTIFICATION_SERVICE);
+		}
+    }
+    @Override  
+    public IBinder onBind(Intent intent) {   
+        Log.e(tag,"onBind");
+        return mDataServiceBinder;   
+    } 
+    @Override
+    public int onStartCommand(Intent intent, int flags, int startId) {
+        Log.d(tag,"onStartCommand");
+        if (intent != null) {
+            mServiceStartId = startId;
+            String action = intent.getAction();
+            String command = intent.getStringExtra("command");
+            Log.d(tag,"command " + command);
+            if(command != null) {
+                if(command.equals("start")) {
+                Log.w(tag,"onStartCommand start");
+                groupRole = intent.getExtras().getInt("groupRole");
+                if(groupRole == 1) {
+                    //client
+                    address = intent.getExtras().getString("address");
+                    Log.d(tag,"onStartCommand client address " + address);
+                } else {
+                    //server
+                    address = "0.0.0.0";
+                    Log.d(tag,"onStartCommand server address " + address);
+                }
+                } else if(command.equals("stop")){
+                    stopSelf();
+                    Log.w(tag,"onStartCommand stop");
+                } else if(command.equals("boot_start")) {
+                    Log.w(tag,"onStartCommand  boot_start");
+                }
+            } else if(action != null) {
+                if(ACTION_CANCEL_TRANSFER.equals(action)) {
+                    int index = intent.getExtras().getInt("index");
+                    Log.d(tag,"onReceive index " + index);
+                    TrasferRecord record = recordMap.get(index);
+                    if(record != null) {
+                        Log.d(tag,"onReceive record != null");
+                        Log.e(tag,"cancel "+record.mFuture.cancel(true));
+                    }
+                }
+            }    
+        }else {
+            Log.e(tag,"warning!!! onStartCommand intent is null!");
+        }
+        return START_STICKY;
+    }
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+        Log.d(tag,"onDestroy");
+        this.unregisterReceiver(mReceiver);
+    }
+    class ServerAcceptThread extends Thread {
+        private Socket mSocket;
+        private int index;
+        public ServerAcceptThread(int index) {
+            this.index = index;
+        }
+        @Override
+    	public void run() {
+    	    try {
+                Log.d(tag,"ServerAcceptThread run() ServerSocket wait");
+                receiveServerSocket = new ServerSocket(18890);
+                mSocket = receiveServerSocket.accept();
+                Log.d(tag,"ServerAcceptThread connected");
+                Future<Object> future = receiveExecutor.submit(new ReceiveCallable(index, mSocket));
+                Log.d(tag,"ServerAcceptThread add record in map " + index);
+                TrasferRecord record = getFromFutureMap(index);
+                record.mFuture = future;
+            } catch(Exception e) {
+                Log.e(tag, Log.getStackTraceString(e));
+    	    } finally{
+                try {
+                    receiveServerSocket.close();
+                    receiveServerSocket = null; 
+                } catch(Exception e ) {
+                    Log.e(tag, Log.getStackTraceString(e));
+                }
+    	    }
+        }
+    }
+    class ServerSendThread extends Thread {
+        private Socket mSocket;
+        private ArrayList<Uri> mSendFilePath;
+        private int index;
+        public ServerSendThread(int index, ArrayList<Uri> pathList) {
+            this.index = index;
+            this.mSendFilePath = pathList;
+        }
+        @Override
+    	public void run() {
+    	    try {
+                Log.d(tag,"ServerSendThread run() ServerSocket wait");
+                sendServerSocket = new ServerSocket(18891);
+                mSocket = sendServerSocket.accept();
+                Log.d(tag,"ServerAcceptThread connected");
+                Future<Object> future = sendExecutor.submit(new SendCallable(index , mSocket, mSendFilePath));
+                TrasferRecord record = getFromFutureMap(index);
+                record.mFuture = future;
+    	    } catch(Exception e) {
+                Log.e(tag, Log.getStackTraceString(e));
+    	    } finally{
+    	        try {
+                    sendServerSocket.close();
+                    sendServerSocket = null; 
+                } catch(Exception e ) {
+                    Log.e(tag, Log.getStackTraceString(e));
+                }
+    	    }
+        }
+    }
+    class ClientAcceptThread extends Thread {
+        private Socket mSocket;
+        private int index;
+        public ClientAcceptThread(int index) {
+            this.index = index;
+        }
+        @Override
+    	public void run() {
+    	    try {
+                Log.d(tag,"ClientAcceptThread run() Socket wait");
+                Thread.sleep(500);
+                mSocket = new Socket(address,18891);
+                Log.d(tag,"ClientAcceptThread connected");
+                Future<Object> future = receiveExecutor.submit(new ReceiveCallable(index, mSocket));
+                TrasferRecord record = getFromFutureMap(index);
+                record.mFuture = future;
+            } catch(Exception e) {
+                Log.e(tag, Log.getStackTraceString(e));
+    	    }
+        }
+    }
+    class ClientSendThread extends Thread {
+        private Socket mSocket;
+        private ArrayList<Uri> mSendFilePath;
+        private int index;
+        public ClientSendThread(int index, ArrayList<Uri> pathList) {
+            this.index = index;
+            this.mSendFilePath = pathList;
+        }
+        @Override
+    	public void run() {
+    	    try {
+                Log.d(tag,"ClientSendThread run() Socket wait");
+                Thread.sleep(500);
+                mSocket = new Socket(address,18890);
+                Log.d(tag,"ClientSendThread connected");
+                Future<Object> future = sendExecutor.submit(new SendCallable(index, mSocket, mSendFilePath)); 
+                TrasferRecord record = getFromFutureMap(index);
+                record.mFuture = future;
+    	    } catch(Exception e) {
+                Log.e(tag, Log.getStackTraceString(e));
+    	    }
+        }
+    }
+    private int mListenerKey = 0;
+    private final static int INVALID_LISTENER_KEY = -1;
+    private Object mListenerMapLock = new Object();
+    private void addInFutureMap(int key, TrasferRecord record) {
+        synchronized (mListenerMapLock) {
+            recordMap.put(key, record);
+        }
+    }
+    private TrasferRecord getFromFutureMap(int key) {
+        if (key == INVALID_LISTENER_KEY) {
+            return null;
+        }
+        synchronized (mListenerMapLock) {
+            return recordMap.get(key);
+        }
+    }
+    private TrasferRecord removeFromFutureMap(int key) {
+        synchronized (mListenerMapLock) {
+            return recordMap.remove(key);
+        }
+    }
+    private void removeAllFuture() {
+        Iterator iter = recordMap.entrySet().iterator(); 
+        while (iter.hasNext()) { 
+            Map.Entry entry = (Map.Entry) iter.next(); 
+            //Object key = entry.getKey(); 
+            //Object val = entry.getValue(); 
+            TrasferRecord record = removeFromFutureMap((Integer)entry.getKey());
+            record.mFuture.cancel(true);
+        } 
+        Log.i(tag,"removeAllFuture over");
+    }
+    private class TrasferRecord {
+        public int index;
+        public String mPin;
+        public Future<Object> mFuture;
+        public int transferState;
+        public ConnectState connectState;
+        public String mReason;
+        public ArrayList<String> mFileNames;
+        public class ConnectState {
+            final int INVALID      = 0x00;
+            final int DISCONNECTED = 0x01;
+            final int CONNECTING   = 0x02;
+            final int CONNECTED    = 0x03;
+        }
+        public final static int SEND    = 0x01;
+        public final static int RECEIVE = 0x02;
+        public TrasferRecord(int index, int mTrasferState) {
+            this.index = index;
+            this.transferState = mTrasferState;
+        }
+    }
+    //ControlService aidl ,call this for receive message
+    private IDataService.Stub mDataServiceBinder = new IDataService.Stub() {
+        public Messenger getMessenger() {
+            return mDataMessager;
+        }
+    };
+    private long getCurrentTime() {
+        return System.currentTimeMillis();
+    }
+    private long getElapsedTime(long start, long end) {
+        return (end - start);
+    }
+    private class ReceiveCallable implements Callable<Object>{
+        private Socket receiveSocket;
+        private DataInputStream dis;
+		private FileOutputStream fos;
+        private int fileNumber = 0;
+        private String[] mimeType;
+        private String[] receiveFileNames;
+        private long[] fileSize;
+        private File file;
+        private long singleFileSizeCounter;
+        private int readCount;
+        private long boundary;
+        private byte[] buffer = new byte[1024 * 10];//10byte fix,find best length to send
+        //debug for statistic analysis for time
+        private long connBeginTime;
+        private long connEndTime;
+        private long connElapsedTime;
+        private long transferBeginTime;
+        private long transferEndTime;
+        private long transferElapsedTime;
+        //send file total size
+        private long totalLength = 0;
+        private WifiDirectShareTask [] sharetask;
+       // private ArrayList<WifiDirectShareTask> sharelist;
+        //int
+        private int transfEndNum = 0;
+        //notification
+        private Notification mNotification = null;
+		private RemoteViews mRemoteViews = null;
+        private int historyProgress = 0;
+//#ifdef VENDOR_EDIT
+//kecheng.Shang@SysApp.BT, 2013/05/14, Add for 
+         private int index;
+        private HashMap hashMap = new HashMap();
+        int dirId;
+//#endif /* VENDOR_EDIT */
+        public ReceiveCallable(int index, Socket socket) {
+            this.index = index;
+            this.receiveSocket = socket;
+        }
+        public String call() throws Exception {
+            try {
+                Thread currentThread = Thread.currentThread();
+                Log.i(tag, "ReceiveCall info "+ Thread.currentThread().getName());
+                Log.w(tag,"ReceiveCallable index " + index);
+                showToast(RECEIVE_BEGIN_TOAST_MSG,null);
+                connBeginTime = getCurrentTime();
+            //connectted by client
+                connEndTime = getCurrentTime();
+                connElapsedTime = getElapsedTime(connBeginTime,connEndTime);
+                Log.i(tag, "connection time " + connElapsedTime);
+            //end connectted by client
+            // Begin to receive data
+                transferBeginTime = getCurrentTime();
+                showNotification();
+                dis = new DataInputStream(new BufferedInputStream
+                    (receiveSocket.getInputStream()));
+                // First block , File Number
+				fileNumber = dis.readInt();
+				Log.i(tag, "File Number = " + fileNumber);
+                // Second block , File names
+				receiveFileNames = new String[fileNumber];
+				for (int i = 0; i < fileNumber; i++) {
+					receiveFileNames[i] = dis.readUTF();
+                    Log.i(tag, (i+1) + " File name = " + receiveFileNames[i]);
+				}
+                // Third block , File size
+                fileSize = new long[fileNumber];
+                for (int i = 0; i < fileNumber; i++) {
+					fileSize[i] = dis.readLong();
+                    totalLength += fileSize[i];
+                    Log.i(tag, (i+1) + " File size = " + fileSize[i]);
+				}
+				//mimetype
+				mimeType = new String[fileNumber];
+				for (int i = 0; i < fileNumber; i++) {
+					mimeType[i] = dis.readUTF();
+                    Log.i(tag, (i+1) + " mimeType = " + mimeType[i]);
+				}
+                //mimetype end
+                //Forth block ,Data
+                buffer = new byte[1024 * 10];
+                //File Directory
+                File dir = new File(Constants.STORE_PATH
+						+ getResources().getString(R.string.folder_name));
+				if (dir.exists() && !dir.isDirectory()) {
+					dir.delete();
+				}
+				if (!dir.exists()) {
+					dir.mkdirs();
+				}
+               // int kk = 1;
+                long currentTotal = 0;
+                int i = 0;
+            //#ifdef VENDOR_EDIT
+            //kecheng.Shang@SysApp.BT, 2013/05/12, Add for
+                sharetask = new WifiDirectShareTask[fileNumber];
+                for(int j=0 ;j<fileNumber; j++){
+                    if (MimeUtils.VCARD_TYPE.equals(mimeType[j])) {
+                        receiveFileNames[j] = MimeUtils.applyVcardExt(receiveFileNames[j], 256);
+                    }
+                     if (mimeType[j] == null || mimeType[j].length() == 0 || mimeType[j].endsWith("*")) {
+                        mimeType[j] = MimeUtils.getMimeType(receiveFileNames[j]);
+                    }
+                    Log.d(tag,"create sharetask");
+                    sharetask[j] = new WifiDirectShareTask(WifiDirectShareTask.TYPE_OPPS_PUSH);
+                    String fileSavePath = Utils.generateFileSavePath( DataService.this, receiveFileNames[j] );
+                    Log.d(tag,"fileSavePath ="+fileSavePath);
+                    sharetask[j].setState(WifiDirectShareTask.STATE_PENDING);
+                    sharetask[j].setObjectName(receiveFileNames[j]);
+                    sharetask[j].setMimeType(mimeType[j]);
+                    sharetask[j].setTotalBytes(fileSize[j]);
+                    sharetask[j].setData(fileSavePath);
+                    sharetask[j].setState(WifiDirectShareTask.STATE_PENDING);
+                    Uri newUri = mResolver.insert(WifiDirectShareTaskMetaData.CONTENT_URI, sharetask[j].getContentValues());
+                    sharetask[j].setId(Integer.parseInt(newUri.getLastPathSegment()));
+                }
+            //#endif /* VENDOR_EDIT */
+                int tempPercent = 0;
+                int tempPercent1 = 0;
+                while (i < fileNumber && !(currentThread.isInterrupted())) {
+                    Log.i(tag, (i+1) + " " +  receiveFileNames[i] + "begin");
+                //#ifdef VENDOR_EDIT
+                //kecheng.Shang@SysApp.BT, 2013/05/10, Add for 
+                //#endif /* VENDOR_EDIT */
+					file = new File(sharetask[i].getData());
+					fos = new FileOutputStream(file);
+                    // pre-progress boundary
+					if (fileSize[i] <= Constants.BUFFER_SIZE) {
+						boundary = fileSize[i];
+					} else {
+						boundary = Constants.BUFFER_SIZE;
+					}
+                    while(singleFileSizeCounter < fileSize[i] && 
+                        (readCount = dis.read(buffer, 0, (int) boundary)) != -1 && !(currentThread.isInterrupted())) {
+                        fos.write(buffer, 0, readCount);
+                        singleFileSizeCounter += readCount;
+                        //#ifdef VENDOR_EDIT
+                        //kecheng.Shang@SysApp.BT, 2013/05/12, Add for 
+                         if(singleFileSizeCounter == fileSize[i]){
+                            sharetask[i].setState(WifiDirectShareTask.STATE_SUCCESS);
+                            Log.d(tag," receive set state = success ");
+                            String	toastmsg = res.getString(R.string.notification_received, sharetask[i].getData());
+						    showToast(FILE_PATH, toastmsg);
+                         }else if(currentThread.isInterrupted()){
+                            sharetask[i].setState(WifiDirectShareTask.STATE_FAILURE);
+                            String	toastmsg = res.getString(R.string.notification_received_fail, sharetask[i].getData());
+                            showToast(FILE_PATH, toastmsg);
+                         }
+                         //#endif /* VENDOR_EDIT */
+                        currentTotal += readCount;
+                        if ((fileSize[i] - singleFileSizeCounter) <= Constants.BUFFER_SIZE) {
+							boundary = fileSize[i] - singleFileSizeCounter;
+						} else {
+							boundary = Constants.BUFFER_SIZE;
+						}
+                        tempPercent1 = (int) (currentTotal * 100 / totalLength);
+                        if(tempPercent != tempPercent1) {
+                            tempPercent = tempPercent1; 
+                            updateNotification(tempPercent);
+                        }
+                        //Log.i(tag,kk + " readCount " + readCount);
+                        //Log.w(tag,"boundary " + boundary);
+                        //kk++;
+                    }
+                    //#ifdef VENDOR_EDIT
+                    //kecheng.Shang@SysApp.BT, 2013/05/12, Add for 
+                    mResolver.update( sharetask[i].getTaskUri(), sharetask[i].getContentValues(), null, null );
+                    //#endif /* VENDOR_EDIT */
+                    new MediaScanner(DataService.this.getApplicationContext(), sharetask[i].getData(), sharetask[i].getMimeType(), null, 0);
+                    Log.e(tag,"readCount final" + readCount);
+                    // kk = 1;
+                    Log.w(tag,"singleFileSizeCounter " + singleFileSizeCounter);
+                    Log.i(tag,"fileSize " + fileSize[i]);
+                    fos.flush();
+                    fos.close();//fix
+                    fos = null;
+                    singleFileSizeCounter = 0;
+                    Log.i(tag, (i+1) + " " +  receiveFileNames[i] + "end");
+                    transfEndNum = i + 1;
+                    i++;
+                }
+                if(!(currentThread.isInterrupted()) && currentTotal == totalLength) {
+                    Log.e(tag, "not interrupt");
+                    transferEndTime = getCurrentTime();
+                    transferElapsedTime = getElapsedTime(transferBeginTime, transferEndTime);
+                    Log.i(tag, "transferElapsedTime " + transferElapsedTime);
+                    //showToast(RECEIVE_END_TOAST_MSG,null);
+                    //#ifdef VENDOR_EDIT
+                    //kecheng.Shang@SysApp.BT, 2013/05/14, Add for 
+                    // HashMap hashMap = new HashMap();
+                    for(int k=0; k<fileNumber;k++ ){
+                       if( sharetask[k].getState()== WifiDirectShareTask.STATE_SUCCESS){
+                       Log.i(tag, "putHashMap" );
+                            putHashMap(sharetask[k]);
+                       }
+                    }
+                    //#endif /* VENDOR_EDIT */
+                    //showAcceptedCompletedDialog();
+                    sendIntentIfCompleted();
+                } else {
+                    //interrupt transfer file
+                    Log.e(tag, "interrupt!!");
+                    showToast(RECEIVE_INTERRUPT_TOAST_MSG,null);
+                    file.delete();
+                }
+                //end Forth block ,Data
+            // end to receive data        
+            } catch(Exception e) {
+                Log.e(tag, Log.getStackTraceString(e));
+                Log.e(tag, Thread.currentThread().getName() + "something wrong");
+                file.delete();
+            } finally {
+                try {
+					if (dis != null) {
+						dis.close();
+                        dis = null;
+					}
+				} catch (Exception e) {
+					Log.e(tag, Log.getStackTraceString(e));
+				}
+                try {
+                    if(fos != null) {
+                       fos.close();
+                       fos = null;
+                    }     
+                } catch(Exception e) {
+                    Log.e(tag, Log.getStackTraceString(e));
+                }
+				try {
+					if (receiveSocket != null) {
+						receiveSocket.close();
+                        receiveSocket = null;
+					}
+				} catch (Exception e) {
+					Log.e(tag, Log.getStackTraceString(e));
+				}
+				//#ifdef VENDOR_EDIT
+				//kecheng.Shang@SysApp.BT, 2013/05/12, Add for 
+		        ContentValues mValues = new ContentValues();
+			    mValues.put( WifiDirectShareTaskMetaData.TASK_STATE, WifiDirectShareTask.STATE_FAILURE );
+			    mResolver.update( WifiDirectShareTaskMetaData.CONTENT_URI, 
+										 mValues,
+										 WifiDirectShareTaskMetaData.TASK_STATE + " = ? and " 
+										 + WifiDirectShareTaskMetaData.TASK_TYPE + " = ? ",
+										 new String[]{
+											Integer.toString( WifiDirectShareTask.STATE_PENDING ),
+											Integer.toString( WifiDirectShareTask.TYPE_OPPS_PUSH)
+										});
+				//#endif /* VENDOR_EDIT */
+                Log.d(tag,"update database");
+                removeFromFutureMap(index);
+                removeNotification();
+               refreshFinishedOppNotify(WifiDirectShareTask.checkDirection(WifiDirectShareTask.TYPE_OPPS_PUSH),DataService.this) ;
+            }
+            return "" + transfEndNum;
+        }
+        private void showNotification() {
+            Log.i(tag,"showNotification index " + index);
+            /*Intent intent = new Intent(DataService.this, CancelTransferDialog.class);
+            intent.putExtra("index", index);
+            PendingIntent pendIntent = PendingIntent.getActivity(DataService.this, index, intent, PendingIntent.FLAG_UPDATE_CURRENT);  
+            */
+			mRemoteViews = new RemoteViews(
+					DataService.this.getPackageName(),R.layout.notification_remote);
+			mRemoteViews.setTextViewText(
+					R.id.notification_title,
+					getResources().getString(
+							R.string.notification_receive_title));
+			mRemoteViews.setTextViewText(
+					R.id.notification_progress,
+					getResources().getString(
+							R.string.notification_progress_sign));
+			mRemoteViews.setProgressBar(R.id.notification_pb, 100, 0, false);
+			mRemoteViews.setImageViewResource(R.id.icon,
+					R.drawable.big_download);
+            Intent intent1 = new Intent(ACTION_CANCEL_TRANSFER);
+            intent1.setClass(DataService.this.getApplicationContext(), DataService.class);
+            intent1.putExtra("index", index);
+            PendingIntent pendingIntent1 = PendingIntent.getService(DataService.this, index, intent1, PendingIntent.FLAG_UPDATE_CURRENT);
+            mRemoteViews.setOnClickPendingIntent(R.id.statusbar_btn_close, pendingIntent1);
+			Notification.Builder builder = new Notification.Builder(
+					DataService.this.getApplicationContext());
+			builder.setSmallIcon(R.drawable.stat_sys_download);
+			builder.setTicker(DataService.this.getResources().getString(
+					R.string.notification_receive_title));
+			builder.setWhen(System.currentTimeMillis());
+			builder.setContent(mRemoteViews);
+			mNotification = builder.getNotification();
+            //mNotification.contentIntent = pendIntent;
+			mNotification.flags = Notification.FLAG_ONGOING_EVENT;
+			mNm.notify(index, mNotification);
+		}
+        private void removeNotification() {
+			Log.d(tag, "will cancel notification index " + index);
+			mNm.cancel(index);
+		}
+		private void updateNotification(int progressValue) {
+			if (historyProgress != progressValue) {
+				if (mNotification == null || mNm == null) {
+					return;
+				}
+				mNotification.contentView.setTextViewText(
+						R.id.notification_progress,
+						progressValue
+								+ getResources().getString(
+										R.string.notification_progress_sign));
+				mNotification.contentView.setProgressBar(R.id.notification_pb,
+						100, progressValue, false);
+				historyProgress = progressValue;
+				mNm.notify(index, mNotification);
+			}
+		}
+		protected void putHashMap (WifiDirectShareTask task){
+		    dirId = MimeType.getDirTypeFromExtension(MimeType.getExtensionFromFileName(task.getData()));
+            Log.d(tag, "putHashMap dirId = "+ dirId);
+		    Integer integer = new Integer(dirId);
+            if(false == hashMap.containsKey(integer))
+            {
+                hashMap.put(integer, 1);
+		        Log.d( tag,"putHashMap integer = 1 ");
+            }
+            else if(hashMap.containsKey(integer))
+            {
+                hashMap.put(integer, new Integer(((Integer)hashMap.get(integer)).intValue() + 1));
+		        Log.d(tag, "putHashMap integer =  "+ ((Integer)hashMap.get(integer)).intValue());
+            }				
+	    }
+	   private  void sendIntentIfCompleted(){
+            Log.d(tag, "[sendHashMap intent +]");
+			//Jiehong.Tang@CommSrv.BT 20110825 add for bug:sd card removed
+			if(hashMap.isEmpty()){
+				Log.e(tag, "[HashMap is null]");
+				return;
+			}
+			//end
+			String root_path = SystemUtils.mRootPath;
+			if(root_path == null)
+			    root_path = "Phone";
+			Log.d(tag, "alven:ifcomplete:root="+root_path); 
+			String result = root_path + "/" + res.getString(dirId);
+			Log.d(tag, "intentcompleted +"+ result);
+			Intent sendintent = 
+			            new Intent(DataService.this, HistoryConfirmDialog.class);
+			//sendintent.setAction(MimeType.ALL_TRANSFERS_IN_INBOUND_SESSION_COMPLETED_ACTION);
+        	sendintent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); 
+        	ArrayList<Integer> keys = new ArrayList<Integer>(hashMap.keySet());
+        	ArrayList<Integer> sums = new ArrayList<Integer>(hashMap.values());
+        	sendintent.putIntegerArrayListExtra(MimeType.KEYS_IN_STATISTIC, keys);
+        	sendintent.putIntegerArrayListExtra(MimeType.SUMS_IN_STATISTIC, sums);
+			sendintent.putExtra(MimeType.LAST_RECEIVED_FILE_IN_DIR_IN_STATISTIC, result);
+			DataService.this.startActivity(sendintent);
+			hashMap.clear();	
+        }
+    }
+    private void showToast(final int type ,final String toastmsg) {
+        Handler handler=new Handler(Looper.getMainLooper());  
+        handler.post(new Runnable(){ 
+            public void run(){  
+                switch(type) {
+                    case SEND_BEGIN_TOAST_MSG:
+                        Toast.makeText(getApplicationContext(), R.string.wifi_p2p_begin_to_send_message, Toast.LENGTH_SHORT).show();
+                        break;
+                    case SEND_END_TOAST_MSG:
+                        Toast.makeText(getApplicationContext(), R.string.file_send_success, Toast.LENGTH_SHORT).show();
+                        break;
+                    case SEND_INTERRUPT_TOAST_MSG:
+                        Toast.makeText(getApplicationContext(), R.string.file_send_interrupt, Toast.LENGTH_SHORT).show();
+                        break;
+                    case RECEIVE_BEGIN_TOAST_MSG:
+                        Toast.makeText(getApplicationContext(), R.string.wifi_p2p_begin_to_receive_message, Toast.LENGTH_SHORT).show();
+                        break;
+                    case RECEIVE_END_TOAST_MSG:
+                        Toast.makeText(getApplicationContext(), R.string.file_receive_success, Toast.LENGTH_SHORT).show();
+                        break;
+                    case RECEIVE_INTERRUPT_TOAST_MSG:
+                        Toast.makeText(getApplicationContext(), R.string.file_receive_interrupt, Toast.LENGTH_SHORT).show();
+                        break;
+                   case  FILE_PATH:    
+                        Toast.makeText(getApplicationContext(), toastmsg, Toast.LENGTH_LONG).show();
+                        break;
+                    default:
+                        break;
+                }
+            }  
+        });  
+    }
+//#ifndef VENDOR_EDIT
+//kecheng.Shang@SysApp.BT, 2013/05/14, Remove for 
+/*
+    private void showAcceptedCompletedDialog() {
+        Handler handler=new Handler(Looper.getMainLooper());  
+        handler.post(new Runnable(){ 
+            public void run(){  
+                Intent histroyConfirmDialogIntent = new Intent(DataService.this, HistoryConfirmDialog.class);
+                histroyConfirmDialogIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);//fix
+                startActivity(histroyConfirmDialogIntent);
+            }  
+        });
+        Log.d(tag, "showAcceptedCompletedDialog end");
+    }
+    */
+//#endif /* VENDOR_EDIT */
+    private void showSendToast() {
+        Handler handler=new Handler(Looper.getMainLooper());  
+        handler.post(new Runnable(){ 
+            public void run(){  
+                Toast.makeText(getApplicationContext(), R.string.file_send_success, Toast.LENGTH_SHORT).show();
+            }  
+        });
+    }
+    private class SendCallable implements Callable<Object>{
+        private ArrayList<Uri> mSendFileUri;
+        private Socket sendSocket;
+        private DataOutputStream dos;
+        private FileInputStream fis;
+        private File file;
+        private String fileName;
+        private List<File> fileList = new ArrayList<File>();
+       // private long length;
+        private byte[] buffer = new byte[Constants.BUFFER_SIZE];
+		private int count = 0;
+        private long transferBeginTime;
+        private long transferEndTime;
+        private long transferElapsedTime;
+        private HashMap <File , WifiDirectShareTask> map = 
+                        new HashMap <File , WifiDirectShareTask>();
+        private Notification mNotification = null;
+		private RemoteViews mRemoteViews = null;
+        private int historyProgress = 0;
+        private int index;
+        public SendCallable(int index, Socket socket, ArrayList<Uri> pathList) {
+            this.index = index;
+            this.sendSocket = socket;
+            this.mSendFileUri = pathList;
+        }
+        public String call() {
+            try {
+            // Begin to receive data
+		 showToast(SEND_BEGIN_TOAST_MSG,null);	
+                Thread currentThread = Thread.currentThread();
+        //kecheng.Shang@SysApp.BT, 2013/05/03, Add for 
+                addToWifiDirectSharedProvider(mSendFileUri);
+        //#endif /* VENDOR_EDIT */
+                transferBeginTime = getCurrentTime();
+                Log.i(tag, "sendCall info "+ Thread.currentThread().getName());
+                Log.w(tag,"SendCallable index " + index);
+                showNotification();
+                dos = new DataOutputStream(new BufferedOutputStream
+                    (sendSocket.getOutputStream()));
+                // First block , File Number
+                Log.d(tag, "File Number " + mSendFileUri.size());
+                dos.writeInt(mSendFileUri.size());
+			    dos.flush();
+                // Second block , File names
+               // for (Uri filePath : mSendFileUri) {
+                   // file = new File(filePath.getPath());
+                   // if (file.exists()) {
+                   for(File  file : map.keySet()){
+                        fileName = file.getName();
+						dos.writeUTF(fileName);
+                        //fileList.add(file);
+                        Log.i(tag, "File name = " + fileName);
+                    //} else {
+                    //    mSendFilePath.remove(filePath);
+                    //    Log.e(tag, filePath + "not exist, removed from list");
+                    //}
+                }
+                dos.flush();
+                long totalLength = 0;
+                // Third block , File size
+               // for (Uri filePath : mSendFileUri) {
+                for(File  file : map.keySet()){
+                   //File  file = new File(filePath.getPath());
+                   //fileList.add(file) ;
+                    long length= file.length();
+                    Log.d(tag,"file.length = "+length);
+					totalLength += length;// in byte
+					dos.writeLong(length);
+				}
+				dos.flush();
+				//mimetype begin
+				for (Map.Entry<File, WifiDirectShareTask> entry : map.entrySet()) {
+		            WifiDirectShareTask value = entry.getValue();
+		            dos.writeUTF(value.getMimeType());
+	            }
+	            dos.flush();
+	            //mimetype end
+                //Forth block ,Data
+              //  long singleFileSizeCounter = 0;
+                long currentTotal = 0;
+              //  Log.e(tag,"file.length " + file.length());
+                int tempPercent = 0;
+                int tempPercent1 = 0;
+               Iterator it = map.entrySet().iterator();
+			   while(it.hasNext() && !currentThread.isInterrupted()){
+			   		Map.Entry entry = (Map.Entry)it.next();
+                    File key = (File)entry.getKey();
+                    WifiDirectShareTask value =(WifiDirectShareTask) entry.getValue();
+                try{
+                    Log.d(tag,"key = "+key.toString());
+                    fis = new FileInputStream(key);
+		    //#ifdef VENDOR_EDIT
+		    //yimin@Comm.exp.wifi,modify for set singleFileSizeCounter to 0 every key
+		      long singleFileSizeCounter = 0;
+                     //#endif /* VENDOR_EDIT */
+                    while ((count = fis.read(buffer)) != -1 && !currentThread.isInterrupted()) {
+                        dos.write(buffer, 0, count);
+                        singleFileSizeCounter += count;
+                        currentTotal += count;
+                            tempPercent1 = (int) (currentTotal * 100 / totalLength);
+                            if(tempPercent != tempPercent1) {
+                                tempPercent = tempPercent1; 
+                                updateNotification(tempPercent);
+                            }
+						if(value.getTotalBytes() == singleFileSizeCounter){
+							value.setState(WifiDirectShareTask.STATE_SUCCESS );
+						String	toastmsg = res.getString(R.string.notification_sent, key.getName());
+						showToast(FILE_PATH, toastmsg);
+							Log.e(tag,"WifiDirectShareTask.STATE_SUCCESS");
+						}else if(currentThread.isInterrupted()){
+							value.setState(WifiDirectShareTask.STATE_FAILURE );
+							Log.e(tag,"WifiDirectShareTask.STATE_FAILURE");
+						    String	toastmsg = res.getString(R.string.notification_sent_fail, key.getName());
+                            showToast(FILE_PATH, toastmsg);	
+						}
+					  }	
+                } catch(Exception e) {    
+                    Log.e(tag, Log.getStackTraceString(e));
+                    value.setState(WifiDirectShareTask.STATE_FAILURE);  
+                    String toastmsg = res.getString(R.string.notification_sent_fail, key.getName());
+                    showToast(FILE_PATH, toastmsg);	
+                    Log.e(tag,"WifiDirectShareTask.STATE_FAILURE");
+                } finally {
+                    dos.flush();
+                    try{
+                        if(fis != null){
+                            fis.close();
+                            }
+                        }catch(Exception e){
+                        Log.e(tag, Log.getStackTraceString(e));
+                        }
+					mResolver.update( value.getTaskUri(), value.getContentValues(), null, null );
+                    Log.e(tag,"mResolver.update()");
+                }
+			}		
+         while(it.hasNext()) {
+		 	Map.Entry entry = (Map.Entry)it.next();
+		 	WifiDirectShareTask value = (WifiDirectShareTask)entry.getValue();
+			value.setState(WifiDirectShareTask.STATE_FAILURE );
+			mResolver.update( value.getTaskUri(), value.getContentValues(), null, null );
+			Log.e(tag,"set left sharetask fail");
+		 }      
+                //end Forth block ,Data
+				if(!(currentThread.isInterrupted())) {
+                    Log.e(tag, "not interrupt");
+                    //showToast(SEND_END_TOAST_MSG,null);
+                } else {
+                    Log.e(tag, "interrupt");
+                    showToast(SEND_INTERRUPT_TOAST_MSG,null);
+                }
+				transferEndTime = getCurrentTime();
+				transferElapsedTime = getElapsedTime(transferBeginTime, transferEndTime);
+				Log.i(tag, "transferElapsedTime " + transferElapsedTime);
+                map.clear();
+            }catch (Exception e) {
+                Log.e(tag, Log.getStackTraceString(e));
+            } finally {
+                try {
+					if (dos != null) {
+						dos.close();
+                        dos = null;
+					}
+				} catch (Exception e) {
+					Log.e(tag, Log.getStackTraceString(e));
+				}
+               // try {
+               //     if(fis != null) {
+               //         fis.close();
+                fis = null;
+				//	}
+			    //	} catch (Exception e) {
+				//	Log.e(tag, Log.getStackTraceString(e));
+				//}
+				try {
+					if (sendSocket != null) {
+						sendSocket.close();
+                        sendSocket = null;
+					}
+				} catch (Exception e) {
+					Log.e(tag, Log.getStackTraceString(e));
+				}
+                removeFromFutureMap(index);
+                removeNotification();
+                refreshFinishedOppNotify(WifiDirectShareTask.checkDirection(WifiDirectShareTask.TYPE_OPPC_PUSH),DataService.this);
+            }
+            return "true";
+        }
+    //}
+   //#ifdef VENDOR_EDIT
+//kecheng.Shang@SysApp.BT, 2013/05/03, Add for 
+ void addToWifiDirectSharedProvider(ArrayList<Uri> uriList){
+      if(uriList == null){
+        Log.e(tag, "uriList == null");
+        return;
+      }
+      Log.d(tag,"uriList size ="+uriList.size());
+      for (Iterator<Uri> it = uriList.iterator(); it.hasNext(); ){       
+     // for (Uri uri : uriList) {
+        //#ifdef VENDOR_EDIT
+        //kecheng.Shang@SysApp.BT, 2013/05/09, Add for 
+       // we should use file-extension to get mime-type
+             Uri uri = it.next();
+             String type = mResolver.getType(uri);
+             Log.d(tag,"type ="+type);
+             if (type == null && uri != null) {
+                 type = MimeUtils.getMimeType(uri.getLastPathSegment());
+                 Log.d(tag,"MimeUtils.getMimeType ="+type);
+                  }
+            /*
+            if (type == null || uri == null) {
+                Log.d(tag,"type == null || uri == null");
+                return;
+            } */
+            if (uri == null) {
+                Log.d(tag,"uri == null");
+                return;
+            }
+  //#endif /* VENDOR_EDIT */
+              UriData ud = UriDataUtils.getUriData(DataService.this, uri);
+              if(ud != null){
+                long batchTimestamp = System.currentTimeMillis();
+                WifiDirectShareTask sharetask = 
+                           new WifiDirectShareTask(WifiDirectShareTask.TYPE_OPPC_PUSH);
+                sharetask.setObjectName(ud.getName());
+                sharetask.setData(ud.getData());
+                sharetask.setTotalBytes(ud.getSize());
+                sharetask.setCreationDate(batchTimestamp); +
+                if(type == null) {
+                    sharetask.setMimeType("file/*");    
+                } else {
+                    sharetask.setMimeType(type); 
+                }
+                sharetask.setObjectUri(uri.toString());
+                sharetask.setState(WifiDirectShareTask.STATE_PENDING);
+                Uri newUri = mResolver.insert(WifiDirectShareTaskMetaData.CONTENT_URI, sharetask.getContentValues());
+                sharetask.setId(Integer.parseInt(newUri.getLastPathSegment()));
+                File file = new File(ud.getData());
+                map.put(file,sharetask);
+                Log.d(tag," hashmap put");
+                }else{
+                    it.remove();
+                    Log.w(tag, "remove uri");
+                }
+          }
+      }
+//#endif /* VENDOR_EDIT */ 
+  //}
+        private void showNotification() {
+            Log.d(tag, "showNotification()");
+            /*
+            Intent intent = new Intent(DataService.this, CancelTransferDialog.class);
+            intent.putExtra("index", index);
+            PendingIntent pendIntent = PendingIntent.getActivity(DataService.this, index, intent, PendingIntent.FLAG_UPDATE_CURRENT);
+            */
+			mRemoteViews = new RemoteViews(DataService.this.getPackageName(),
+					R.layout.notification_remote);
+			mRemoteViews.setTextViewText(R.id.notification_title,
+					getResources().getString(R.string.notification_title));
+			mRemoteViews.setTextViewText(
+					R.id.notification_progress,
+					getResources().getString(
+							R.string.notification_progress_sign));
+			mRemoteViews.setProgressBar(R.id.notification_pb, 100, 0, false);
+			mRemoteViews.setImageViewResource(R.id.icon, R.drawable.big_upload);
+            Intent intent1 = new Intent(ACTION_CANCEL_TRANSFER);
+            intent1.setClass(DataService.this.getApplicationContext(), DataService.class);
+            intent1.putExtra("index", index);
+            PendingIntent pendingIntent1 = PendingIntent.getService(DataService.this, index, intent1, PendingIntent.FLAG_UPDATE_CURRENT);
+            mRemoteViews.setOnClickPendingIntent(R.id.statusbar_btn_close, pendingIntent1);
+			Notification.Builder builder = new Notification.Builder(getApplicationContext());
+			builder.setContent(mRemoteViews);
+			builder.setSmallIcon(R.drawable.stat_sys_upload);
+			builder.setWhen(System.currentTimeMillis());
+			builder.setTicker(getApplicationContext().getResources().getString(
+					R.string.notification_title));
+			mNotification = builder.getNotification();
+            //mNotification.contentIntent = pendIntent;
+			mNotification.flags = Notification.FLAG_ONGOING_EVENT;
+			mNm.notify(index, mNotification);
+		}
+        private void removeNotification() {
+			Log.d(tag, "will cancel notification");
+			mNm.cancel(index);
+		}
+		private void updateNotification(int progressValue) {
+			if (historyProgress != progressValue) {
+				if (mNotification == null || mNm == null) {
+					return;
+				}
+				mNotification.contentView.setTextViewText(
+						R.id.notification_progress,
+						progressValue
+								+ getResources().getString(
+										R.string.notification_progress_sign));
+				mNotification.contentView.setProgressBar(R.id.notification_pb,
+						100, progressValue, false);
+				historyProgress = progressValue;
+				mNm.notify(index, mNotification);
+			}
+		}
+    }
+    private ArrayList<String> stringToFileArrayList(String fileNames) {
+        String[] pathArray = fileNames.split("\n");
+        ArrayList<String> pathArrayList = new ArrayList<String>();
+        for(String path : pathArray) {
+            pathArrayList.add(path); 
+        }
+        return pathArrayList;
+    }
+    public interface CommandListener {
+        public void onSuccess();
+        public void onFailure(int reason);
+    }
+    //setting --aidl--> ControlService.Channel --> DataService
+    //   |                                |
+    //   <---------------listener callback--------------
+    private class DataServiceHandler extends Handler {
+        int index;
+        TrasferRecord record;
+        @Override
+        public void handleMessage(Message message) {
+            switch(message.what) {
+                case P2P_SEND_FILE_REQUEST:
+                    //start send thread
+                    ArrayList<Uri> list = (ArrayList<Uri>)message.obj;
+                    index = (int)message.arg2;
+                    record = new TrasferRecord(index, TrasferRecord.SEND); 
+                    addInFutureMap(index, record);
+                    Log.d(tag, "control msg " + list.size() );
+                    if(groupRole == 0) {
+                        //server send
+                        Log.d(tag, "server send ");
+                       new ServerSendThread(index, list).start();
+                    } else {
+                        //clienet send
+                        Log.d(tag, "client send  list size ="+list.size());
+                        new ClientSendThread(index, list).start();
+                    }
+                    replyToMessage(message, P2P_SEND_FILE_RESPONSE_SUCCESS, -1);
+                    break;
+                case P2P_RECEIVE_FILE_REQUEST:
+                    //start receive thread
+                    Log.d(tag, "control msg " + (String)message.obj);
+                    index = (int)message.arg2;
+                    record = new TrasferRecord(index, TrasferRecord.RECEIVE); 
+                    addInFutureMap(index, record);
+                    if(groupRole == 0) {
+                        //server accept
+                        Log.d(tag, "server accept ");
+                        new ServerAcceptThread(index).start();
+                    } else {
+                        //client accept
+                        Log.d(tag, "client accept ");
+                        new ClientAcceptThread(index).start();
+                    }
+                    replyToMessage(message, P2P_RECEIVE_FILE_RESPONSE_SUCCESS, -1);
+                    break;
+                default:
+                        Log.d(tag, "Ignored " + message);
+                        break;
+            }
+        }
+    }
+    private void replyToMessage(Message msg, int what) {
+        if (msg.replyTo == null) return;
+        Message dstMsg = obtainMessage(msg);
+        dstMsg.what = what;
+        mReplyChannel.replyToMessage(msg, dstMsg);
+    }
+    private void replyToMessage(Message msg, int what, int arg1) {
+        if (msg.replyTo == null) return;
+        Message dstMsg = obtainMessage(msg);
+        dstMsg.what = what;
+        dstMsg.arg1 = arg1;
+        mReplyChannel.replyToMessage(msg, dstMsg);
+    }
+    private void replyToMessage(Message msg, int what, Object obj) {
+        if (msg.replyTo == null) return;
+        Message dstMsg = obtainMessage(msg);
+        dstMsg.what = what;
+        dstMsg.obj = obj;
+        mReplyChannel.replyToMessage(msg, dstMsg);
+    }
+    private Message obtainMessage(Message srcMsg) {
+        Message msg = Message.obtain();
+        msg.arg2 = srcMsg.arg2;
+        return msg;
+    }
+    public static String waitForEvent() {
+        return null;
+    }
+//#ifdef VENDOR_EDIT
+//kecheng.Shang@SysApp.BT, 2013/05/13, Add for 
+   public  static void refreshFinishedOppNotify(Direction taskDirection, Context mContext){
+        Log.d(tag,"refreshFinishedOppNotify");
+		Notification n;
+		NotificationManager mNm = (NotificationManager) mContext
+					.getSystemService(Context.NOTIFICATION_SERVICE);
+		int mSuccessRecordNum = getSuccessRecordNum(taskDirection,mContext);		
+		int mFailedRecordNum = getFailedRecordNum(taskDirection,mContext);
+		int pid ; 
+		if(taskDirection == WifiDirectShareTask.Direction.out){
+		    Log.d(tag,"opps_push");
+		    pid = OPP_NOTIFICATION_ID_IN_FINISHED;
+		}else{
+		    Log.d(tag,"oppc_push");
+		    pid = OPP_NOTIFICATION_ID_OUT_FINISHED;
+		}
+		if(mSuccessRecordNum + mFailedRecordNum > 0)
+		{
+			//n = OppNotificationFactory.getFinishedOppNotify( this.mApplicationContext, 
+															 // taskDirection , 
+															  //getSuccessRecordNum(taskDirection),
+															  //getFailedRecordNum(taskDirection));
+			n = getFinishedOppNotify(taskDirection,mSuccessRecordNum,mFailedRecordNum,mContext);												  
+			mNm.notify( pid, n );
+			Log.d(tag,"notify");
+		}
+		else
+		{
+			mNm.cancel( pid );
+			Log.d(tag,"cancel");
+		}
+	} 
+	private  static int getSuccessRecordNum(Direction taskDirection,Context mContext){
+		int recordNum = 0;
+ 		//Cursor cursor = mContext.getContentResolver().query( WifiDirectShareTaskMetaData.CONTENT_URI,
+												//	new String[]{ WifiDirectShareTaskMetaData._ID },//null
+												//	WifiDirectShareTaskMetaData.TASK_STATE + " = ? "+ " AND " 
+												//	+ WifiDirectShareTaskMetaData.TASK_TYPE+ " = ?",
+												//	 new String[]{
+											    //     Integer.toString( WifiDirectShareTask.STATE_SUCCESS ),
+											    //     Integer.toString( sharetask_type )
+											    //    },
+												//	null/*BluetoothShareTaskMetaData.TASK_MODIFIED_DATE + " DESC"*/ );
+	    Cursor cursor = mContext.getContentResolver().query( WifiDirectShareTaskMetaData.CONTENT_URI,
+													new String[]{ WifiDirectShareTaskMetaData._ID },//null
+													OppTransferInfo.WHERE_SUCCESS + " AND " + getDirectionString(taskDirection),
+													null,
+													null/*BluetoothShareTaskMetaData.TASK_MODIFIED_DATE + " DESC"*/ );	
+		if(cursor != null && cursor.moveToFirst()){
+			recordNum = cursor.getCount();
+		}
+		if( cursor != null )	cursor.close();		
+		Log.d(tag, "getSuccessRecordNum recordNum " + recordNum);
+		return recordNum;
+	}
+	private static  int getFailedRecordNum(Direction taskDirection,Context mContext){
+		int recordNum = 0;
+ 	//	Cursor cursor = mContext.getContentResolver().query( WifiDirectShareTaskMetaData.CONTENT_URI,
+											//		new String[]{ WifiDirectShareTaskMetaData._ID },//null
+											//		WifiDirectShareTaskMetaData.TASK_STATE + " = ? "+ " AND " 
+											//		+ WifiDirectShareTaskMetaData.TASK_STATE+ " = ?",
+											//		 new String[]{
+											//         Integer.toString( WifiDirectShareTask.STATE_FAILURE ),
+											//         Integer.toString(sharetask_type)
+											//        },
+											//		null/*BluetoothShareTaskMetaData.TASK_MODIFIED_DATE + " DESC"*/ );
+	    Cursor cursor =mContext.getContentResolver().query( WifiDirectShareTaskMetaData.CONTENT_URI,
+													new String[]{ WifiDirectShareTaskMetaData._ID },//null
+													OppTransferInfo.WHERE_FAILED + " AND " + getDirectionString(taskDirection),
+													null,
+													null/*BluetoothShareTaskMetaData.TASK_MODIFIED_DATE + " DESC"*/ );		
+		if(cursor != null && cursor.moveToFirst()){
+			recordNum = cursor.getCount();
+		}
+		cursor.close();
+		Log.d(tag , "getFailedRecordNum recordNum " + recordNum);
+		return recordNum;
+	}+
+	private static Notification  getFinishedOppNotify( Direction taskDirection ,int completedNum, 
+	                                    int failedNum, Context mContext){
+	    Log.d(tag,"getFinishedOppNotify");
+	    String title;
+        String caption;
+        Intent intent;
+		Resources res = mContext.getResources();
+		PendingIntent pendingIntent;
+		int notificationFlag = Notification.FLAG_AUTO_CANCEL;	// default for 'Finish' state
+		Notification notify = new Notification();
+        int pid ; 
+		if( taskDirection == Direction.out ){
+	        pid = OPP_NOTIFICATION_ID_IN_FINISHED;
+			notify.icon = R.drawable.oppo_stat_sys_upload_anim0;
+	        title = res.getString(R.string.outbound_noti_title);
+	        caption = res.getString(R.string.noti_caption, completedNum,
+	                failedNum);
+ 	        intent = new Intent(mContext ,OppHistoryActivity.class);
+ 	        //intent.setClassName("com.oppo.wifidirect", OppHistoryActivity.class.getName());
+ 	        intent.putExtra("isDirectionIn",false);
+ 	        Log.d(tag,"TYPE_OPPc_PUSH pendingIntent");
+	        //intent.setClassName(OppConstants.THIS_PACKAGE_NAME, OppReceiver.class.getName());
+			//pendingIntent = PendingIntent.getBroadcast(context, 0, intent, 0);
+			pendingIntent = PendingIntent.getActivity(mContext, pid, intent, PendingIntent.FLAG_UPDATE_CURRENT);
+			notify.setLatestEventInfo(mContext, title, caption, pendingIntent);
+		//	pendingIntent = PendingIntent.getActivity(this, 0, intent, PendingIntent.FLAG_ONE_SHOT);
+	    //    intent = new Intent(OppConstants.OppNotify.ACTION_OPP_CLEAR_ALL_OUTSESSION);
+	    //    intent.setClassName(OppConstants.THIS_PACKAGE_NAME, OppReceiver.class.getName());
+	    //    notify.deleteIntent = PendingIntent.getBroadcast(context, 0, intent, 0);
+			notify.when = System.currentTimeMillis();
+		}
+		else {
+            pid = OPP_NOTIFICATION_ID_OUT_FINISHED;
+			//#ifdef VENDOR_DIT
+			//kecheng.Shang@CommSrv.BT,2012-05-29,add to change icon
+            //notify.icon = android.R.drawable.stat_sys_download_done;
+			//#endif
+//#ifndef VENDOR_EDIT
+//LeiYu@Prd.SysApp.BT, 2012/08/18, Modify for change pictures of BT transfer notification
+/*
+            notify.icon = com.android.internal.R.drawable.stat_sys_download_anim0;
+*/
+//#else /* VENDOR_EDIT */
+			//notify.icon = com.android.internal.R.drawable.oppo_stat_sys_download_anim0;
+			notify.icon = R.drawable.oppo_stat_sys_download_anim0;
+//#endif /* VENDOR_EDIT */	
+            title = res.getString(R.string.inbound_noti_title);
+            caption = res.getString(R.string.noti_caption, completedNum,
+                    failedNum);
+			intent = new Intent(mContext ,OppHistoryActivity.class);
+           // intent.setClassName("com.oppo.wifidirect.share", OppHistoryActivity.class.getName());
+            intent.putExtra("isDirectionIn",true);
+		   //	pendingIntent = PendingIntent.getBroadcast(context, 0, intent, 0);
+		    pendingIntent = PendingIntent.getActivity(mContext, pid, intent, PendingIntent.FLAG_UPDATE_CURRENT);
+			notify.setLatestEventInfo(mContext , title, caption, pendingIntent);
+            //intent = new Intent(OppConstants.OppNotify.ACTION_OPP_CLEAR_ALL_INSESSION);
+            //intent.setClassName(OppConstants.THIS_PACKAGE_NAME, OppReceiver.class.getName());
+            //notify.deleteIntent = PendingIntent.getBroadcast(context, 0, intent, 0);
+			notify.when = System.currentTimeMillis();
+		}
+		return notify;
+	}
+	//}
+//#endif /* VENDOR_EDIT */
+  //Toast.makeText(mApplicationContext, message, Toast.LENGTH_LONG).show();  
+  private static String getDirectionString(Direction taskDirection)
+	{
+		if(WifiDirectShareTask.Direction.in == taskDirection){
+			return OppTransferInfo.WHERE_INBOUND;
+		}
+		else if(WifiDirectShareTask.Direction.out == taskDirection){
+			return OppTransferInfo.WHERE_OUTBOUND;
+		}
+		else{
+			return null;
+		}
+	} 
+}
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/IDataService.aidl
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/IDataService.aidl	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/IDataService.aidl	(版本 25821)
+package com.oppo.wifidirect;
+import android.os.Messenger;
+interface IDataService {
+    Messenger getMessenger();
+}
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/WifiP2pConnectService.java
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/WifiP2pConnectService.java	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/WifiP2pConnectService.java	(版本 25821)
+package com.oppo.wifidirect;
+import com.oppo.wifidirect.R;
+import com.oppo.wifidirect.ControlService;
+import android.app.Service; 
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.Binder;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.Looper;
+import android.net.NetworkInfo;
+import android.net.wifi.p2p.WifiP2pConfig;
+import android.net.wifi.p2p.WifiP2pManager;
+import android.util.Log;
+import android.widget.Toast;
+public class WifiP2pConnectService extends Service {
+    //initial channel
+    private WifiP2pManager mWifiP2pManager;
+    private WifiP2pManager.Channel mChannel;
+    private int mServiceStartId;
+    private final String tag = "WifiP2pConnectService";
+    //search mark
+    private boolean mWifiP2pSearching;
+    //p2p enable mark
+    private boolean mWifiP2pEnabled;
+    //path get from UI
+    private String path;
+    //only show connected peer
+    private boolean p2pConnected = false;
+    //couter hander,if not connected in 40s,cancel the connect
+    private Handler cancelHandler;
+    private final int cancelTime = 30000;
+    //broadcast receiver
+    private final IntentFilter mIntentFilter = new IntentFilter();
+    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+            Log.d(tag, "receive action: " + action);
+            if (WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION.equals(action)) {
+                if (mWifiP2pManager == null) return;
+                NetworkInfo networkInfo = (NetworkInfo) intent.getParcelableExtra(
+                        WifiP2pManager.EXTRA_NETWORK_INFO);
+                if (networkInfo.isConnected()) {
+                    Log.d(tag, "P2P Connected");
+                    p2pConnected = true;
+                    cancelHandler.removeCallbacks(cancelRunnable);
+                    stopSelf();
+                } else {
+                    p2pConnected = false;
+                    startSearch();
+                }
+            } else if(WifiP2pManager.WIFI_P2P_DISCOVERY_CHANGED_ACTION.equals(action)) {
+                int discoveryState = intent.getIntExtra(WifiP2pManager.EXTRA_DISCOVERY_STATE,
+                    WifiP2pManager.WIFI_P2P_DISCOVERY_STOPPED);
+                Log.d(tag, "Discovery state changed: " + discoveryState);
+                if (discoveryState == WifiP2pManager.WIFI_P2P_DISCOVERY_STARTED) {
+                    mWifiP2pSearching = true;
+                } else {
+                    mWifiP2pSearching = false;
+                }
+            }
+        }
+    };
+    @Override
+    public void onCreate() {
+        //intent filter
+        mIntentFilter.addAction(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION);
+        mIntentFilter.addAction(WifiP2pManager.WIFI_P2P_DISCOVERY_CHANGED_ACTION);
+        //get wifip2pmanager
+        mWifiP2pManager = (WifiP2pManager) getSystemService(Context.WIFI_P2P_SERVICE);
+        //wifip2pmanager.channal initial
+        if (mWifiP2pManager != null) {
+            mChannel = mWifiP2pManager.initialize(this, this.getMainLooper(), null);
+            if (mChannel == null) {
+                //Failure to set up connection
+                Log.e(tag, "Failed to set up connection with wifi p2p service");
+                mWifiP2pManager = null;
+            }
+        } else {
+            Log.e(tag, "mWifiP2pManager is null !");
+        }
+        //initial counter handler
+        cancelHandler = new Handler();
+        this.registerReceiver(mReceiver, mIntentFilter);
+    }
+    @Override  
+    public IBinder onBind(Intent intent) {   
+        Log.d(tag,"onBind");
+        return null;
+    }
+    @Override
+    public int onStartCommand(Intent intent, int flags, int startId) {
+        Log.d(tag,"onStartCommand");
+        if (intent != null) {
+            mServiceStartId = startId;
+            String command = intent.getStringExtra("command");
+            if(command.equals("connect")) {
+                Log.e(tag,"onStartCommand->connect");
+                WifiP2pConfig config = (WifiP2pConfig)intent.getParcelableExtra("p2pInfo");
+                path = intent.getStringExtra("path");
+                connectToPeer(config);
+            } else if(command.equals("search")) {
+                Log.e(tag,"onStartCommand->search");
+                startSearch();
+            }
+        }
+        return START_STICKY;
+    }
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+        Log.d(tag,"onDestroy");
+        mWifiP2pManager.stopPeerDiscovery(mChannel, null);        
+        this.unregisterReceiver(mReceiver);   
+    }
+    private Runnable cancelRunnable = new Runnable(){
+            public void run() {
+                if (mWifiP2pManager != null) {
+                    mWifiP2pManager.cancelConnect(mChannel,
+                            new WifiP2pManager.ActionListener() {
+                        public void onSuccess() {
+                            Log.d(tag, " cancel connect success");
+                            showToast();
+                        }
+                        public void onFailure(int reason) {
+                            Log.d(tag, " cancel connect fail " + reason);
+                        }
+                    });
+                }
+            }
+    };+
+    private void showToast() {
+        Handler handler=new Handler(Looper.getMainLooper());
+        handler.post(new Runnable(){ 
+            public void run(){  
+                Toast.makeText(getApplicationContext(), R.string.connect_break_title, Toast.LENGTH_SHORT).show();
+                stopSelf();
+            }
+        });
+    }
+    private void connectToPeer(WifiP2pConfig config) {
+        mWifiP2pManager.connect(mChannel, config,
+                        new WifiP2pManager.ActionListener() {
+                            public void onSuccess() {
+                            }
+                            public void onFailure(int reason) {
+                                Log.e(tag, " connect fail " + reason);
+                                Toast.makeText(getApplicationContext(),
+                                        R.string.wifi_p2p_failed_connect_message,
+                                        Toast.LENGTH_SHORT).show();
+                            }
+                    });
+        cancelHandler.postDelayed(cancelRunnable, cancelTime);
+    }
+    private void startSearch() {
+        if (mWifiP2pManager != null && !mWifiP2pSearching) {
+            mWifiP2pManager.discoverPeers(mChannel, new WifiP2pManager.ActionListener() {
+                public void onSuccess() {
+                }
+                public void onFailure(int reason) {
+                    Log.d(tag, " discover fail " + reason);
+                }
+            });
+        }
+    }
+}
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/Constants.java
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/Constants.java	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/Constants.java	(版本 25821)
+/**
+ * Copyrigth 2000-2012 OPPO Mobile Comm Corp.,Ltd.
+ * All rights reserved.
+ * 
+ * Description :This is the send side activity
+ * 
+ * History : 
+ * 
+ * Version 1.0        2012-11-15         James Liu ,Create
+ */
+package com.oppo.wifidirect;
+import android.os.Environment;
+public class Constants {
+	public final static String ACTION_OBEAM_SEND = "com.oppo.wfd.trans.send";
+	public final static String ACTION_OBEAM_RECEIVE = "com.oppo.wfd.trans.receive";
+	public final static String ACTION_SEND_ACTIVITY = "com.oppo.wfd.trans.send.activity";
+	public final static String ACTION_RECEIVE_ACTIVITY = "com.oppo.wfd.trans.receive.activity";
+	public final static int PORT = 8899;
+	public final static int CONTROL_PORT = PORT + 1;
+	public final static int TIME_OUT = 1000 * 60;
+	public final static String STORE_FOLDER = "TransferFiles";
+	public final static String STORE_PATH = Environment
+			.getExternalStorageDirectory().getAbsolutePath()
+			+ "/";
+	public final static int SEND_SERVICE_NOTIFICATION_ID = 0xa001;
+	public final static int RECEIVE_SERVICE_NOTIFICATION_ID = 0xa002;
+	public final static int PROTOCOL_VERSION = 1;
+	//public final static int BUFFER_SIZE = 1024 * 10 * 10;//100k
+	public final static int BUFFER_SIZE = 1024 * 10 * 1;//10k
+	public final static String APPLICATION_TAG = "OppoFileTransfer";
+	public final static int APPLICATION_NOTIFICATION_ID = 0x0a01;
+	public final static int COMPLETE_FLAG = 0x0b001;
+	public final static boolean DBG = true;
+}
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/ui/HistoryConfirmDialog.java
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/ui/HistoryConfirmDialog.java	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/ui/HistoryConfirmDialog.java	(版本 25821)
+package com.oppo.wifidirect.ui;
+import com.oppo.wifidirect.R;
+import com.oppo.wifidirect.share.MimeType;
+import android.content.BroadcastReceiver;
+import android.content.ContentValues;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.net.Uri;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Message;
+import android.util.Log;
+import android.view.KeyEvent;
+import android.view.View;
+import android.widget.TextView;
+import android.widget.Toast;
+import android.text.format.Formatter;
+import com.android.internal.app.AlertActivity;
+import com.android.internal.app.AlertController;
+import java.util.ArrayList;
+/**
+ * This class is designed to ask user to confirm if accept incoming file;
+ */
+public class HistoryConfirmDialog extends AlertActivity 
+    implements DialogInterface.OnClickListener {
+    private static final String TAG = "HistoryConformDialog";
+    private static final int DISMISS_TIMEOUT_DIALOG = 0;
+    private static final int DISMISS_TIMEOUT_DIALOG_VALUE = 10000;
+    private static final String PREFERENCE_USER_TIMEOUT = "user_timeout";
+    private TextView mMusicView = null;
+    private TextView mImageView = null;
+    private TextView mVedioView = null;
+    private TextView mOtherView = null;
+    private static ArrayList<Integer> keys = null;
+    private static ArrayList<Integer> sums = null;
+    private static String lastFile = null;
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        Intent intent = getIntent();
+        //yanchen
+        keys = intent.getIntegerArrayListExtra(MimeType.KEYS_IN_STATISTIC);
+        sums = intent.getIntegerArrayListExtra(MimeType.SUMS_IN_STATISTIC);
+        //yanchen end
+		Log.i(TAG, "keys=" + keys +", sums="+ sums); //20110822
+        //yanchen
+        lastFile = intent.getStringExtra(MimeType.LAST_RECEIVED_FILE_IN_DIR_IN_STATISTIC);
+		Log.i(TAG, "lastFile =" + lastFile); //20110822
+        //yanchen end
+        // Set up the "dialog"
+        final AlertController.AlertParams p = mAlertParams;
+        p.mIconId = android.R.drawable.ic_dialog_info;
+        p.mTitle = getString(R.string.accepted_file_statitic_dialog_button);
+        p.mView = createView();
+        p.mPositiveButtonText = getString(R.string.accepted_file_statitic_dialog_button);
+        p.mPositiveButtonListener = this;
+        setupAlert();
+        onTimeout();
+    }
+    private View createView() {
+        View view = getLayoutInflater().inflate(R.layout.receive_history, null);
+        mMusicView = (TextView)view.findViewById(R.id.music_view);
+        mImageView = (TextView)view.findViewById(R.id.image_view);
+        mVedioView = (TextView)view.findViewById(R.id.vedio_view);
+        mOtherView = (TextView)view.findViewById(R.id.other_view);
+        mMusicView.setVisibility(View.GONE);
+        mImageView.setVisibility(View.GONE);
+        mVedioView.setVisibility(View.GONE);
+        mOtherView.setVisibility(View.GONE);
+        int num = keys.size();
+        int dirId = 0;
+        int sum = 0;
+        String text = null;
+        for(int i = 0; i < num; i++)
+        {
+            dirId = keys.get(i).intValue();
+            sum = sums.get(i).intValue();
+            text = getString(R.string.accepted_comfirm_dialog_message, sum, getString(dirId));
+            if(MimeType.MUSIC_DEFAULT_STORE_SUBDIR == dirId)
+            {
+                mMusicView.setText(text);
+                mMusicView.setVisibility(View.VISIBLE);
+            }
+            else if(MimeType.IMAGE_DEFAULT_STORE_SUBDIR == dirId)
+            {
+                mImageView.setText(text);
+                mImageView.setVisibility(View.VISIBLE);
+            }
+            else if(MimeType.VEDIO_DEFAULT_STORE_SUBDIR == dirId)
+            {
+                mVedioView.setText(text);
+                mVedioView.setVisibility(View.VISIBLE);
+            }
+            else //if(Constants.OTHER_DEFAULT_STORE_SUBDIR == dirId)
+            {
+                mOtherView.setText(text);
+                mOtherView.setVisibility(View.VISIBLE);
+            }
+        }
+        return view;
+    }
+    public void onClick(DialogInterface dialog, int which) {
+        switch (which) {
+            case DialogInterface.BUTTON_POSITIVE:
+                Log.i(TAG, "onClick, open dir:" + lastFile); 
+                //#ifndef VENDOR_EDIT
+                //liyang@MMApp.FileMgr, 2012/03/30, Modify for when open the dir check it engrypt or not 
+                   // Intent intent = new Intent("ACTION_FILEMANAGER_BROWSE");
+                //#else /* VENDOR_EDIT */
+                Intent intent = new Intent("ACTION_FILEMANAGER_BROWSE_CHECK_PASSWORD");    
+                //#endif /* VENDOR_EDIT */
+                intent.putExtra("CurrentDir", lastFile); //20110822
+                //OPPO LanceYao add for refresh file brower force
+                intent.putExtra("forceInvalidate", true);
+                //OPPO LanceYao add end
+                try
+                {
+                    startActivity(intent);
+                }
+                catch (Exception ex)
+                {
+                    Log.v(TAG, "no FileManager activity");
+                }
+                break;
+        }
+    }
+    @Override
+    public boolean onKeyDown(int keyCode, KeyEvent event) {
+        if (keyCode == KeyEvent.KEYCODE_BACK) {
+            finish();
+        }
+        return true;
+    }
+    @Override
+    protected void onDestroy() {
+        super.onDestroy();
+        mTimeoutHandler.removeMessages(DISMISS_TIMEOUT_DIALOG);
+    }
+    private void onTimeout() {
+        mTimeoutHandler.sendMessageDelayed(mTimeoutHandler.obtainMessage(DISMISS_TIMEOUT_DIALOG),
+                DISMISS_TIMEOUT_DIALOG_VALUE);
+    }
+    private final Handler mTimeoutHandler = new Handler() {
+        @Override
+        public void handleMessage(Message msg) {
+            switch (msg.what) {
+                case DISMISS_TIMEOUT_DIALOG:
+                    Log.v(TAG, "Received DISMISS_TIMEOUT_DIALOG msg.");
+                    finish();
+                    break;
+                default:
+                    break;
+            }
+        }
+    };
+}
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/ui/WifiP2pSettings.java
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/ui/WifiP2pSettings.java	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/ui/WifiP2pSettings.java	(版本 25821)
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.oppo.wifidirect.ui;
+import com.oppo.wifidirect.ControlService;
+import com.oppo.wifidirect.R;
+import com.oppo.wifidirect.WifiP2pConnectService;
+import com.oppo.wifidirect.ui.Utf8ByteLengthFilter;
+import com.oppo.wifidirect.util.Utils;
+import android.app.ActionBar;
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.app.Dialog;
+import android.content.BroadcastReceiver;
+import android.content.ContentResolver;
+import android.content.Context;
+import android.content.ComponentName;
+import android.content.DialogInterface;
+import android.content.DialogInterface.OnClickListener;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.content.ServiceConnection;
+import android.database.Cursor;
+import android.net.NetworkInfo;
+import android.net.Uri;
+import android.net.wifi.WifiManager;
+import android.net.wifi.WpsInfo;
+import android.net.wifi.p2p.WifiP2pConfig;
+import android.net.wifi.p2p.WifiP2pDevice;
+import android.net.wifi.p2p.WifiP2pDeviceList;
+import android.net.wifi.p2p.WifiP2pGroup;
+import android.net.wifi.p2p.WifiP2pGroupList;
+import android.net.wifi.p2p.WifiP2pManager;
+import android.net.wifi.p2p.WifiP2pManager.ActionListener;
+import android.net.wifi.p2p.WifiP2pManager.ConnectionInfoListener;
+import android.net.wifi.p2p.WifiP2pManager.GroupInfoListener;
+import android.net.wifi.p2p.WifiP2pManager.PeerListListener;
+import android.net.wifi.p2p.WifiP2pManager.PersistentGroupInfoListener;
+import android.os.Bundle;
+import android.os.SystemProperties;
+import android.preference.Preference;
+import android.preference.PreferenceActivity;
+import android.preference.PreferenceCategory;
+import android.preference.PreferenceGroup;
+import android.preference.PreferenceScreen;
+import android.provider.MediaStore.MediaColumns;
+import android.provider.Settings;
+import android.text.InputFilter;
+import android.text.TextUtils;
+import android.util.Log;
+import android.view.Gravity;
+import android.view.Menu;
+import android.view.MenuInflater;
+import android.view.MenuItem;
+import android.widget.EditText;
+import android.widget.Toast;
+import java.util.ArrayList;
+import java.io.FileNotFoundException;
+import com.oppo.widget.OppoEditText;
+import android.database.Cursor;
+import android.content.ContentResolver;
+import java.io.File;
+import com.oppo.widget.OppoMenuItem;
+import com.oppo.widget.OppoOptionMenuBar;
+import com.oppo.widget.OppoOptionMenuBar.OnOptionsItemSelectedListener;
+/*
+ * Displays Wi-fi p2p settings UI
+ */
+public class WifiP2pSettings extends PreferenceActivity
+        implements PeerListListener, PersistentGroupInfoListener, GroupInfoListener {
+    private static final String TAG = "WifiP2pSettings";
+    private static final boolean DBG = true;
+    private static final int MENU_ID_SEARCH = Menu.FIRST;
+    private static final int MENU_ID_RENAME = Menu.FIRST + 1;
+    private static final int DEVICE_NAME_MAX_LENGTH_BYTES = 32;
+    private final IntentFilter mIntentFilter = new IntentFilter();
+    private WifiP2pManager mWifiP2pManager;
+    //#ifdef VENDOR_EDIT
+    //YanChen@Prd.SysApp.WIFI, 2013/02/02, Add for enable wifi when enter p2p if wifi is disable
+    private WifiManager mWifiManager;    
+//430    private IControlService mControlService;
+//430     private SettingHandler mSettingHandler;
+//430     private AsyncChannel mAsyncChannel = new AsyncChannel();
+    //#endif /* VENDOR_EDIT */
+    private WifiP2pManager.Channel mChannel;
+    private OnClickListener mRenameListener;
+    private OnClickListener mDisconnectListener;
+    private OnClickListener mCancelConnectListener;
+    private OnClickListener mDeleteGroupListener;
+    //#ifdef VENDOR_EDIT
+    //YanChen@Prd.SysApp.WIFI, 2013/02/02, Add for 
+    private OnClickListener mOpenWifiListener;
+    //#endif /* VENDOR_EDIT */
+    private WifiP2pPeer mSelectedWifiPeer;
+    private WifiP2pPersistentGroup mSelectedGroup;
+    private OppoEditText mDeviceNameText;
+    private boolean mWifiP2pEnabled;
+    private boolean mWifiP2pSearching;
+    private int mConnectedDevices;
+    private WifiP2pGroup mConnectedGroup;
+    //#ifndef VENDOR_EDIT
+    //yimin@exp.data.modify,2014/3/25
+   // private OppoPreferenceGroup mPeersGroup;
+   // private OppoPreference mThisDevicePref;
+    private PreferenceGroup mPeersGroup;
+    private Preference mThisDevicePref;
+    private static final int DIALOG_DISCONNECT  = 1;
+    private static final int DIALOG_CANCEL_CONNECT = 2;
+    private static final int DIALOG_RENAME = 3;
+    private static final int DIALOG_DELETE_GROUP = 4;
+    private static final int DIALOG_ENABLE_WIFI = 5;
+    private static final String SAVE_DIALOG_PEER = "PEER_STATE";
+    private static final String SAVE_DEVICE_NAME = "DEV_NAME";
+    private static final String PEER_GROUP = "wifi_p2p_peer_devices_list";
+    private static final String THIS_DEVICE = "this_device";
+   // private Uri uri = null;
+    private final int singleSend = 0;
+    private final int multipleSend = 1;
+    private final int oppomultipleSend = 2;
+    private final int P2P_SEND_FILE_REQUEST = 1;
+    //only show connected peer
+    private boolean p2pConnected = false;
+    /* path format
+    *   storage/sdcard0/a.txt  \n 
+    *   storage/sdcard0/b.txt  \n
+    */
+    private String filePaths;
+    private WifiP2pDevice mThisDevice;
+    private WifiP2pDeviceList mPeers = new WifiP2pDeviceList();
+    private String mSavedDeviceName;
+    //#ifdef VENDOR_EDIT
+    //YanChen@Prd.SysApp.WIFI, 2013/06/03, Add for 
+    private final String THIS_DEVICE_PREFERENCE_KEY = "this_device";
+    private final String SCAN_PREFERENCE_KEY = "wifi_scan";
+    private final String RENAME_PREFERENCE_KEY = "rename";
+    //#endif /* VENDOR_EDIT */
+    private ArrayList<Uri> mUris ;
+    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            String action = intent.getAction();
+            if (DBG) {
+                Log.d(TAG, "receive action: " + action);
+            }
+            if (WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION.equals(action)) {
+                mWifiP2pEnabled = intent.getIntExtra(WifiP2pManager.EXTRA_WIFI_STATE,
+                    WifiP2pManager.WIFI_P2P_STATE_DISABLED) == WifiP2pManager.WIFI_P2P_STATE_ENABLED;
+                handleP2pStateChanged();
+            } else if (WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION.equals(action)) {
+                if (mWifiP2pManager != null) {
+                    mWifiP2pManager.requestPeers(mChannel, WifiP2pSettings.this);
+                }
+            } else if (WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION.equals(action)) {
+                if (mWifiP2pManager == null) return;
+                NetworkInfo networkInfo = (NetworkInfo) intent.getParcelableExtra(
+                        WifiP2pManager.EXTRA_NETWORK_INFO);
+                if (mWifiP2pManager != null) {
+                    mWifiP2pManager.requestGroupInfo(mChannel, WifiP2pSettings.this);
+                }
+                if (networkInfo.isConnected()) {
+                    if (DBG) Log.d(TAG, "Connected");
+				    p2pConnected = true;
+                } else {
+                    p2pConnected = false;
+                    //start a search when we are disconnected
+                    startSearch();
+                }
+            } else if (WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION.equals(action)) {
+                mThisDevice = (WifiP2pDevice) intent.getParcelableExtra(
+                        WifiP2pManager.EXTRA_WIFI_P2P_DEVICE);
+                if (DBG) Log.d(TAG, "Update device info: " + mThisDevice);
+                updateDevicePref();
+            } else if (WifiP2pManager.WIFI_P2P_DISCOVERY_CHANGED_ACTION.equals(action)) {
+                int discoveryState = intent.getIntExtra(WifiP2pManager.EXTRA_DISCOVERY_STATE,
+                    WifiP2pManager.WIFI_P2P_DISCOVERY_STOPPED);
+                if (DBG) Log.d(TAG, "Discovery state changed: " + discoveryState);
+                if (discoveryState == WifiP2pManager.WIFI_P2P_DISCOVERY_STARTED) {
+                    updateSearchMenu(true);
+                } else {
+                    updateSearchMenu(false);
+                }
+		updateSearchMenuTitle();
+            } else if (WifiP2pManager.WIFI_P2P_PERSISTENT_GROUPS_CHANGED_ACTION.equals(action)) {
+                if (mWifiP2pManager != null) {
+                    mWifiP2pManager.requestPersistentGroupInfo(mChannel, WifiP2pSettings.this);
+                }
+            }
+        }
+    };
+     OppoOptionMenuBar mMenuBar;
+    private class OptionMenuListener implements OnOptionsItemSelectedListener {
+		@Override
+		public boolean onOptionsItemSelected(OppoMenuItem item) {                
+				switch (item.getItemId()) {
+				case R.id.wifi_direct_search:
+					startSearch();
+					break;
+				case R.id.wifi_direct_rename:
+					showDialog(DIALOG_RENAME);
+					break;	
+				default:
+					break;
+				}
+                 return true;
+		}
+    };
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+	setContentView(R.layout.oppo_preference_list_fragment_wifi_direct_settings);
+        addPreferencesFromResource(R.xml.wifi_p2p_settings);
+	mMenuBar = (OppoOptionMenuBar) findViewById(R.id.option_menubar);
+        mMenuBar.setMenuItems(R.menu.wifi_direct_option_menu);
+	mMenuBar.setOnOptionsItemSelectedListener(new OptionMenuListener());
+        mIntentFilter.addAction(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION);
+        mIntentFilter.addAction(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION);
+        mIntentFilter.addAction(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION);
+        mIntentFilter.addAction(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION);
+        mIntentFilter.addAction(WifiP2pManager.WIFI_P2P_DISCOVERY_CHANGED_ACTION);
+        mIntentFilter.addAction(WifiP2pManager.WIFI_P2P_PERSISTENT_GROUPS_CHANGED_ACTION);
+        //mIntentFilter.addAction(CONTROL_SERVICE_IS_READY_ACTION);
+        final Activity activity = this;
+        mWifiP2pManager = (WifiP2pManager) getSystemService(Context.WIFI_P2P_SERVICE);
+        //#ifdef VENDOR_EDIT
+        //YanChen@Prd.SysApp.WIFI, 2013/02/02, Add for enable wifi when enter p2p if wifi is disable
+        mWifiManager = (WifiManager) getSystemService(Context.WIFI_SERVICE);
+        int wifiState = mWifiManager.getWifiState();
+        if(wifiState == WifiManager.WIFI_STATE_DISABLED) {
+            showDialog(DIALOG_ENABLE_WIFI);
+        }
+//430        mSettingHandler = new SettingHandler();
+        String action = getIntent().getAction();
+        String mUri_string = "";
+        StringBuffer sbuf = new StringBuffer();
+        int fileNum = -1;
+        if(Intent.ACTION_SEND.equals(action)) {
+            fileNum = singleSend;
+        } else if("com.oppo.action.wifidirect".equals(action)) {
+            fileNum = oppomultipleSend;
+            mUri_string = getIntent().getExtras().getString("android.bluetooth.intent.file_path_uri");
+        } else {
+            fileNum = multipleSend;
+        }
+        switch(fileNum) {
+            case singleSend:
+                Uri mUri = getIntent().getParcelableExtra(Intent.EXTRA_STREAM);
+                CharSequence text = getIntent().getCharSequenceExtra(Intent.EXTRA_TEXT);
+                if (mUri == null && text != null) {
+                    // encode share content into Uri
+                    /*CharSequence subject = getIntent().getCharSequenceExtra(Intent.EXTRA_SUBJECT);
+                    String fragment = (subject == null) ? null : subject.toString();
+                    Log.e(TAG, "fragment " + fragment + " subject " + subject + " text " + text); 
+                    mUri = Uri.fromParts(LINK_SHARE_URI_SCHEME, text.toString(), fragment);*/
+                    mUri = Utils.createContextFileForText(this, null, (CharSequence)text);
+                }
+                String mIntentType = getIntent().getType();
+                if(mIntentType != null) {
+                    Log.d(TAG, "mIntentType " + mIntentType);   
+                }
+                ArrayList<Uri> mtempUris = new ArrayList<Uri>();
+                mtempUris.add(mUri); 
+                mUris = mtempUris;
+                Log.e(TAG, "uri " + mUri.toString() + " " +mUris.size());
+            //#ifndef VENDOR_EDIT
+            //kecheng.Shang@SysApp.BT, 2013/05/04, Remove for 
+            /*  
+                String fileUri;
+                if(uri.toString().startsWith("content")) {
+                    try {
+                        fileUri = queryForDataFile(uri);
+                        Log.e(TAG, "query uri " + fileUri);
+                        sbuf.append(fileUri + "\n");
+                    }catch(FileNotFoundException e) {
+                        Log.e(TAG, Log.getStackTraceString(e));
+                    }
+                } else if(uri.toString().startsWith("file")) {
+                    sbuf.append(uri.getPath() + "\n");
+                }
+                filePaths = sbuf.toString();
+            */
+            //#endif /* VENDOR_EDIT */
+                break;
+            case multipleSend:
+                mUris = getIntent().getParcelableArrayListExtra(Intent.EXTRA_STREAM);
+               // for(Uri tmpUri : mUris) {
+               //     sbuf.append(tmpUri.getPath() + "\n");
+               // }
+                //filePaths = sbuf.toString();
+                break;
+	  //#ifndef VENDOR_EDIT
+          //yimin@exp.data.modify,2014/3/25
+          /*  case oppomultipleSend:
+                if(mUri_string != null) {
+                    mUris = queryForDataFile(mUri_string);
+                }//fix here must throw exception if mUri_string is null
+                break;
+	  */
+	   //#endif /* VENDOR_EDIT */
+            default:
+                //not start from file manager
+                //ignore
+                break;
+        }
+        //#endif /* VENDOR_EDIT */
+        if (mWifiP2pManager != null) {
+            mChannel = mWifiP2pManager.initialize(activity, this.getMainLooper(), null);
+            if (mChannel == null) {
+                //Failure to set up connection
+                Log.e(TAG, "Failed to set up connection with wifi p2p service");
+                mWifiP2pManager = null;
+            }
+        } else {
+            Log.e(TAG, "mWifiP2pManager is null !");
+        }
+        if (savedInstanceState != null && savedInstanceState.containsKey(SAVE_DIALOG_PEER)) {
+            WifiP2pDevice device = savedInstanceState.getParcelable(SAVE_DIALOG_PEER);
+            mSelectedWifiPeer = new WifiP2pPeer(this, device);
+        }
+        if (savedInstanceState != null && savedInstanceState.containsKey(SAVE_DEVICE_NAME)) {
+            mSavedDeviceName = savedInstanceState.getString(SAVE_DEVICE_NAME);
+        }
+        mRenameListener = new OnClickListener() {
+            @Override
+            public void onClick(DialogInterface dialog, int which) {
+                if (which == DialogInterface.BUTTON_POSITIVE) {
+                    if (mWifiP2pManager != null) {
+                        mWifiP2pManager.setDeviceName(mChannel,
+                                mDeviceNameText.getText().toString(),
+                                new WifiP2pManager.ActionListener() {
+                            public void onSuccess() {
+                                if (DBG) Log.d(TAG, " device rename success");
+                            }
+                            public void onFailure(int reason) {
+                                Toast.makeText(getApplicationContext(),
+                                        R.string.wifi_p2p_failed_rename_message,
+                                        Toast.LENGTH_LONG).show();
+                            }
+                        });
+                    }
+                }
+            }
+        };
+        //disconnect dialog listener
+        mDisconnectListener = new OnClickListener() {
+            @Override
+            public void onClick(DialogInterface dialog, int which) {
+                if (which == DialogInterface.BUTTON_POSITIVE) {
+                    if (mWifiP2pManager != null) {
+                        mWifiP2pManager.removeGroup(mChannel, new WifiP2pManager.ActionListener() {
+                            public void onSuccess() {
+                                if (DBG) Log.d(TAG, " remove group success");
+                            }
+                            public void onFailure(int reason) {
+                                if (DBG) Log.d(TAG, " remove group fail " + reason);
+                            }
+                        });
+                    }
+                }
+            }
+        };
+        //cancel connect dialog listener
+        mCancelConnectListener = new OnClickListener() {
+            @Override
+            public void onClick(DialogInterface dialog, int which) {
+                if (which == DialogInterface.BUTTON_POSITIVE) {
+                    if (mWifiP2pManager != null) {
+                        mWifiP2pManager.cancelConnect(mChannel,
+                                new WifiP2pManager.ActionListener() {
+                            public void onSuccess() {
+                                if (DBG) Log.d(TAG, " cancel connect success");
+                            }
+                            public void onFailure(int reason) {
+                                if (DBG) Log.d(TAG, " cancel connect fail " + reason);
+                            }
+                        });
+                    }
+                }
+            }
+        };
+        //delete persistent group dialog listener
+        mDeleteGroupListener = new OnClickListener() {
+            @Override
+            public void onClick(DialogInterface dialog, int which) {
+                if (which == DialogInterface.BUTTON_POSITIVE) {
+                    if (mWifiP2pManager != null) {
+                        mWifiP2pManager.deletePersistentGroup(mChannel,
+                                mSelectedGroup.getNetworkId(),
+                                new WifiP2pManager.ActionListener() {
+                            public void onSuccess() {
+                                if (DBG) Log.d(TAG, " delete group success");
+                            }
+                            public void onFailure(int reason) {
+                                if (DBG) Log.d(TAG, " delete group fail " + reason);
+                            }
+                        });
+                    }
+                }
+            }
+        };
+        //#ifndef VENDOR_EDIT
+        //YanChen@Prd.SysApp.WIFI, 2013/02/01, Modify for compile
+        /*
+        setHasOptionsMenu(true);   
+        preferenceScreen.removeAll();
+        preferenceScreen.setOrderingAsAdded(true);
+        final PreferenceScreen preferenceScreen = getPreferenceScreen();
+        mThisDevicePref = new Preference(this);
+        preferenceScreen.addPreference(mThisDevicePref);
+        mPeersGroup = new PreferenceCategory(this);
+        mPeersGroup.setTitle(R.string.wifi_p2p_peer_devices);
+        */
+        //#else /* VENDOR_EDIT */
+          //#ifndef VENDOR_EDIT
+          //yimin@exp.data.modify,2014/3/25
+	 final PreferenceScreen preferenceScreen = getPreferenceScreen();
+         mThisDevicePref = (Preference)findPreference(THIS_DEVICE);    
+         mPeersGroup = (PreferenceCategory)findPreference(PEER_GROUP);
+	/*	
+        mThisDevicePref = (OppoPreference)findPreference(THIS_DEVICE_PREFERENCE_KEY);
+        mScanPreference = (OppoPreference)findPreference(SCAN_PREFERENCE_KEY);
+        mRenamePreference = (OppoPreference)findPreference(RENAME_PREFERENCE_KEY);
+        mPeersGroup = (ProgressCategory)findPreference("peers_list");
+        mPeersGroup.setAutoUpdateOverlap(true);
+	 /*
+        //#endif /* VENDOR_EDIT */
+        //#ifndef VENDOR_EDIT
+        //YanChen@Prd.SysApp.WIFI, 2013/02/01, delete for 
+        /*
+        mPersistentGroup = new PreferenceCategory(this);
+        mPersistentGroup.setTitle(R.string.wifi_p2p_remembered_groups);
+        */
+        //#endif /* VENDOR_EDIT */
+        //#ifndef VENDOR_EDIT
+        //YanChen@Prd.SysApp.WIFI, 2013/02/01, Remove for 
+        /*
+        super.onCreate(savedInstanceState);
+        */
+        //#endif /* VENDOR_EDIT */
+        Log.e(TAG,"oncreate end");
+    }
+    /*
+    private String queryForDataFile(Uri uri) throws FileNotFoundException {
+        final Cursor cursor = getContentResolver().query(
+                uri, new String[] { MediaColumns.DATA }, null, null, null);
+        if (cursor == null) {
+            throw new FileNotFoundException("Missing cursor for " + uri);
+        }
+        try {
+            switch (cursor.getCount()) {
+                case 0:
+                    throw new FileNotFoundException("No entry for " + uri);
+                case 1:
+                    if (cursor.moveToFirst()) {
+                        return cursor.getString(0);
+                    } else {
+                        throw new FileNotFoundException("Unable to read entry for " + uri);
+                    }
+                default:
+                    throw new FileNotFoundException("Multiple items at " + uri);
+            }
+        } finally {
+            cursor.close();
+        }
+    }*/
+	  //#ifndef VENDOR_EDIT
+          //yimin@exp.data.modify,2014/3/25
+    /*
+    private ArrayList<Uri> queryForDataFile(String mUri_string) {
+        Uri uri = null;
+        ArrayList<Uri> mUris = new ArrayList<Uri>();
+        if (mUri_string != null) {
+            uri = Uri.parse(mUri_string);
+        }
+        if (uri != null) {
+            ContentResolver mContentResolver = WifiP2pSettings.this.getContentResolver();
+            Cursor mCursor = mContentResolver.query(
+                    uri, 
+                    OppoFileColumns.MARK_FILES_COLUMNS,
+                    null, null, null);
+            //add for fault tolerance
+            if (mCursor == null) {
+                return null;
+            }
+            for (mCursor.moveToFirst(); !mCursor.isAfterLast(); mCursor.moveToNext()) {
+                String path = mCursor.getString(OppoFileColumns.FILE_PATH_INDEX);
+                Log.i(TAG,"filename=" + path);
+    			Uri fileuri = Uri.fromFile(new File(path));
+    			if(fileuri != null){
+                	mUris.add(fileuri);
+    			}
+            }
+            // should close cursor
+            mCursor.close();
+        }
+        return mUris;
+    }
+    */
+    @Override
+    public void onResume() {
+        Log.d(TAG, "onResume");
+        super.onResume();
+        this.registerReceiver(mReceiver, mIntentFilter);
+    }
+    @Override    
+    public void onPause() {     
+        Log.d(TAG, "onPause");        
+        super.onPause();        
+        //mWifiP2pManager.stopPeerDiscovery(mChannel, null);        
+        this.unregisterReceiver(mReceiver);    
+    }
+    @Override
+    public void onDestroy() {
+        Log.d(TAG, "onDestroy");
+        super.onDestroy();
+        //427doUnbindService();
+        //427mWifiP2pManager.stopPeerDiscovery(mChannel, null);
+        //427this.unregisterReceiver(mReceiver);
+        //System.exit(0);
+    }
+    //#ifndef VENDOR_EDIT
+    //YanChen@Prd.SysApp.WIFI, 2013/02/01, Remove for compile
+    /*
+    @Override
+    public boolean onCreateOptionsMenu(Menu menu) {
+        int textId = mWifiP2pSearching ? R.string.wifi_p2p_menu_searching :
+                R.string.wifi_p2p_menu_search;
+        menu.add(Menu.NONE, MENU_ID_SEARCH, 0, textId)
+            .setEnabled(mWifiP2pEnabled)
+            .setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);
+        menu.add(Menu.NONE, MENU_ID_RENAME, 0, R.string.wifi_p2p_menu_rename)
+            .setEnabled(mWifiP2pEnabled)
+            .setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);
+        super.onCreateOptionsMenu(menu);
+        return true;
+    }
+    @Override
+    public boolean onPrepareOptionsMenu(Menu menu) {
+        MenuItem searchMenu = menu.findItem(MENU_ID_SEARCH);
+        MenuItem renameMenu = menu.findItem(MENU_ID_RENAME);
+        /// M: disable search menu when searching @{
+        searchMenu.setEnabled(mWifiP2pEnabled && !mWifiP2pSearching);
+        renameMenu.setEnabled(mWifiP2pEnabled);
+        /// @}
+        if (mWifiP2pSearching) {
+            searchMenu.setTitle(R.string.wifi_p2p_menu_searching);
+        } else {
+            searchMenu.setTitle(R.string.wifi_p2p_menu_search);
+        }
+        return true;
+    }
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        switch (item.getItemId()) {
+            case MENU_ID_SEARCH:
+                startSearch();
+                return true;
+            case MENU_ID_RENAME:
+                showDialog(DIALOG_RENAME);
+                return true;
+        }
+        return super.onOptionsItemSelected(item);
+    }
+    */
+    //#endif /* VENDOR_EDIT */
+    @Override
+    public boolean onPreferenceTreeClick(PreferenceScreen screen, Preference preference) {
+        if (preference instanceof WifiP2pPeer) {
+            mSelectedWifiPeer = (WifiP2pPeer) preference;
+            if (mSelectedWifiPeer.device.status == WifiP2pDevice.CONNECTED) {
+                //#ifdef VENDOR_EDIT
+                //YanChen@Prd.SysApp.WIFI, 2013/04/08, Add for 
+                //doBindService();
+                Log.d(TAG,"skc1");
+                Intent sendPathToControlIntent = new Intent(WifiP2pSettings.this, ControlService.class);
+                sendPathToControlIntent.putExtra("command", "sendpath");
+                Log.d(TAG, "putParcelableArrayListExtra"+"mUris size ="+mUris.size());
+                sendPathToControlIntent.putParcelableArrayListExtra("uris", mUris);
+                startService(sendPathToControlIntent);
+                finish();
+                //#endif /* VENDOR_EDIT */
+            } else if (mSelectedWifiPeer.device.status == WifiP2pDevice.INVITED) {
+                showDialog(DIALOG_CANCEL_CONNECT);
+            } else {
+                WifiP2pConfig config = new WifiP2pConfig();
+                config.deviceAddress = mSelectedWifiPeer.device.deviceAddress;
+                config.groupOwnerIntent = WifiP2pConfig.MIN_GROUP_OWNER_INTENT;
+                int forceWps = SystemProperties.getInt("wifidirect.wps", -1);
+                if (forceWps != -1) {
+                    config.wps.setup = forceWps;
+                } else {
+                    if (mSelectedWifiPeer.device.wpsPbcSupported()) {
+                        config.wps.setup = WpsInfo.PBC;
+                    } else if (mSelectedWifiPeer.device.wpsKeypadSupported()) {
+                        config.wps.setup = WpsInfo.KEYPAD;
+                    } else {
+                        config.wps.setup = WpsInfo.DISPLAY;
+                    }
+                }
+                //427
+                sendFile(filePaths);
+                Intent connectIntent = new Intent(WifiP2pSettings.this, WifiP2pConnectService.class);
+                connectIntent.putExtra("command", "connect");
+                connectIntent.putExtra("path", filePaths);
+                connectIntent.putExtra("p2pInfo", config);
+                startService(connectIntent);
+                finish();
+            }
+        } else if (preference instanceof WifiP2pPersistentGroup) {
+            mSelectedGroup = (WifiP2pPersistentGroup) preference;
+            showDialog(DIALOG_DELETE_GROUP);
+        }
+	 //#ifndef VENDOR_EDIT
+         //yimin@exp.data.delete,2014/3/25
+        //#ifdef VENDOR_EDIT
+        //YanChen@Prd.SysApp.WIFI, 2013/06/03, Add for 
+        /*
+        else if ("wifi_scan".equals(preference.getKey())) {
+            startSearch();
+        } else if ("rename".equals(preference.getKey())) {
+            showDialog(DIALOG_RENAME);    
+        }
+        */
+        //#endif /* VENDOR_EDIT */
+        return super.onPreferenceTreeClick(screen, preference);
+    }
+    @Override
+    public Dialog onCreateDialog(int id) {
+        if (id == DIALOG_DISCONNECT) {
+            String deviceName = TextUtils.isEmpty(mSelectedWifiPeer.device.deviceName) ?
+                    mSelectedWifiPeer.device.deviceAddress :
+                    mSelectedWifiPeer.device.deviceName;
+            String msg;
+            if (mConnectedDevices > 1) {
+                msg = this.getString(R.string.wifi_p2p_disconnect_multiple_message,
+                        deviceName, mConnectedDevices - 1);
+            } else {
+                msg = this.getString(R.string.wifi_p2p_disconnect_message, deviceName);
+            }
+            AlertDialog dialog = new AlertDialog.Builder(this)
+                .setTitle(R.string.wifi_p2p_disconnect_title)
+                .setMessage(msg)
+                .setPositiveButton(this.getString(R.string.dlg_ok), mDisconnectListener)
+                .setNegativeButton(this.getString(R.string.dlg_cancel), null)
+                .create();
+            return dialog;
+        } else if (id == DIALOG_CANCEL_CONNECT) {
+            int stringId = R.string.wifi_p2p_cancel_connect_message;
+            String deviceName = TextUtils.isEmpty(mSelectedWifiPeer.device.deviceName) ?
+                    mSelectedWifiPeer.device.deviceAddress :
+                    mSelectedWifiPeer.device.deviceName;
+            AlertDialog dialog = new AlertDialog.Builder(this)
+                .setTitle(R.string.wifi_p2p_cancel_connect_title)
+                .setMessage(this.getString(stringId, deviceName))
+                .setPositiveButton(this.getString(R.string.dlg_ok), mCancelConnectListener)
+                .setNegativeButton(this.getString(R.string.dlg_cancel), null)
+                .create();
+            return dialog;
+        } else if (id == DIALOG_RENAME) {
+            mDeviceNameText = new OppoEditText(this);
+            mDeviceNameText.setFilters(new InputFilter[] {
+                    new Utf8ByteLengthFilter(DEVICE_NAME_MAX_LENGTH_BYTES)});
+            if (mSavedDeviceName != null) {
+                mDeviceNameText.setText(mSavedDeviceName);
+                mDeviceNameText.setSelection(mSavedDeviceName.length());
+            } else if (mThisDevice != null && !TextUtils.isEmpty(mThisDevice.deviceName)) {
+                mDeviceNameText.setText(mThisDevice.deviceName);
+                mDeviceNameText.setSelection(0, mThisDevice.deviceName.length());
+            }
+            mSavedDeviceName = null;
+            AlertDialog dialog = new AlertDialog.Builder(this)
+                .setTitle(R.string.wifi_p2p_menu_rename)
+                .setView(mDeviceNameText)
+                .setPositiveButton(this.getString(R.string.dlg_ok), mRenameListener)
+                .setNegativeButton(this.getString(R.string.dlg_cancel), null)
+                .create();
+            return dialog;
+        } else if (id == DIALOG_DELETE_GROUP) {
+            int stringId = R.string.wifi_p2p_delete_group_message;
+            AlertDialog dialog = new AlertDialog.Builder(this)
+                .setMessage(this.getString(stringId))
+                .setPositiveButton(this.getString(R.string.dlg_ok), mDeleteGroupListener)
+                .setNegativeButton(this.getString(R.string.dlg_cancel), null)
+                .create();
+            return dialog;
+        }
+        //#ifdef VENDOR_EDIT
+        //YanChen@Prd.SysApp.WIFI, 2013/02/02, Add for enable wifi when enter p2p if wifi is disable
+        else if(id == DIALOG_ENABLE_WIFI) {
+            int stringId = R.string.wifi_p2p_open_wifi_message;
+            Log.e(TAG,"create open wifi dialog");
+            AlertDialog dialog = new AlertDialog.Builder(this)
+                .setTitle(getResources().getString(R.string.Attention))
+                .setMessage(this.getString(stringId))
+                .setPositiveButton(this.getString(R.string.dlg_ok), new DialogInterface.OnClickListener() {
+                                public void onClick(DialogInterface dialog, int which) {
+                                    Log.e(TAG,"wifi click");
+                                    if (which == DialogInterface.BUTTON_POSITIVE) {
+                                        if (mWifiP2pManager != null) {
+                                            int airplaneMode = Settings.System.getInt(getApplicationContext().getContentResolver(), Settings.System.AIRPLANE_MODE_ON, 0);
+                                            if(airplaneMode == 1) {
+                                                Toast.makeText(getApplicationContext(),
+                                                            R.string.wifi_p2p_airplanemode_on_toast_message,
+                                                            Toast.LENGTH_SHORT).show();
+                                                return;
+                                            }
+                                            // Disable tethering if enabling Wifi
+                                            int wifiApState = mWifiManager.getWifiApState();
+                                            if ((wifiApState == WifiManager.WIFI_AP_STATE_ENABLING) ||
+                                                    (wifiApState == WifiManager.WIFI_AP_STATE_ENABLED)) {
+                                                mWifiManager.setWifiApEnabled(null, false);
+                                            }
+                                            if (!mWifiManager.setWifiEnabled(true)) {
+                                                // Intent has been taken into account, disable until new state is active
+                                                Toast.makeText(getApplicationContext(), R.string.wifi_error, Toast.LENGTH_SHORT).show();
+                                            }
+                                        }
+                                    }
+                                }
+                            })
+                .setNegativeButton(this.getString(R.string.dlg_cancel), null)
+                .create();
+            return dialog;
+        }
+        //#endif /* VENDOR_EDIT */
+        return null;
+    }
+    @Override
+    public void onSaveInstanceState(Bundle outState) {
+        if (mSelectedWifiPeer != null) {
+            outState.putParcelable(SAVE_DIALOG_PEER, mSelectedWifiPeer.device);
+        }
+        if (mDeviceNameText != null) {
+            outState.putString(SAVE_DEVICE_NAME, mDeviceNameText.getText().toString());
+        }
+    }
+    public void onPeersAvailable(WifiP2pDeviceList peers) {
+        mPeersGroup.removeAll();
+        mPeers = peers;
+        mConnectedDevices = 0;
+        for (WifiP2pDevice peer: peers.getDeviceList()) {
+            if (DBG) Log.d(TAG, " peer " + peer);
+            //only show paired peer
+            if(p2pConnected) {
+                if (peer.status == WifiP2pDevice.CONNECTED) {
+                    mPeersGroup.addPreference(new WifiP2pPeer(this, peer)); 
+                    mConnectedDevices++;
+                }
+            } else {
+                mPeersGroup.addPreference(new WifiP2pPeer(this, peer));
+                if (peer.status == WifiP2pDevice.CONNECTED) mConnectedDevices++;
+            }
+        }
+        if (DBG) Log.d(TAG, " mConnectedDevices " + mConnectedDevices);
+    }
+    public void onPersistentGroupInfoAvailable(WifiP2pGroupList groups) {
+        //#ifndef VENDOR_EDIT
+        //YanChen@Prd.SysApp.WIFI, 2013/06/03, Remove for 
+        /*
+        mPersistentGroup.removeAll();
+        */
+        //#endif /* VENDOR_EDIT */
+        for (WifiP2pGroup group: groups.getGroupList()) {
+            if (DBG) Log.d(TAG, " group " + group);
+            Log.e(TAG, " group " + group.getNetworkId());
+            //#ifndef VENDOR_EDIT
+            //YanChen@Prd.SysApp.WIFI, 2013/06/03, Remove for 
+            /*
+            mPersistentGroup.addPreference(new WifiP2pPersistentGroup(getActivity(), group));
+            */
+            //#else /* VENDOR_EDIT */
+            mWifiP2pManager.deletePersistentGroup(mChannel,
+                                group.getNetworkId(),
+                                new WifiP2pManager.ActionListener() {
+                            public void onSuccess() {
+                                if (DBG) Log.d(TAG, " delete group success");
+                            }
+                            public void onFailure(int reason) {
+                                if (DBG) Log.d(TAG, " delete group fail " + reason);
+                            }
+                        });
+        }
+    }
+    public void onGroupInfoAvailable(WifiP2pGroup group) {
+        if (DBG) Log.d(TAG, " group " + group);
+        mConnectedGroup = group;
+        updateDevicePref();
+    }
+    private void updateMenuStatus(){
+    	Log.d(TAG, "updateMenuStatus");
+    	OppoMenuItem searchMenu = (OppoMenuItem)mMenuBar.findMenuItem(R.id.wifi_direct_search);
+        OppoMenuItem renameMenu = (OppoMenuItem)mMenuBar.findMenuItem(R.id.wifi_direct_rename);
+        Log.d(TAG, "mWifiP2pEnabled = " + mWifiP2pEnabled);
+        if (mWifiP2pEnabled) {
+            searchMenu.setEnabled(true);
+            renameMenu.setEnabled(true);
+        } else {
+            searchMenu.setEnabled(false);
+            renameMenu.setEnabled(false);
+        }
+        mMenuBar.invalidateOptionMenuBar();
+    }
+    private void updateSearchMenuTitle(){
+    	OppoMenuItem searchMenu = (OppoMenuItem)mMenuBar.findMenuItem(R.id.wifi_direct_search);
+        Log.d(TAG, "mWifiP2pSearching = " + mWifiP2pSearching);
+        if (mWifiP2pSearching) {
+            searchMenu.setTitle(R.string.wifi_p2p_menu_searching);
+        } else {
+            searchMenu.setTitle(R.string.wifi_p2p_menu_search);
+        }
+        mMenuBar.invalidateOptionMenuBar();	
+    }
+    private void handleP2pStateChanged() {
+        updateSearchMenu(false);
+	updateMenuStatus();
+        if (mWifiP2pEnabled) {
+            //#ifndef VENDOR_EDIT
+            //YanChen@Prd.SysApp.WIFI, 2013/06/03, Remove for 
+            /*
+            final OppoPreferenceScreen preferenceScreen = getPreferenceScreen();
+            preferenceScreen.removeAll();
+            preferenceScreen.setOrderingAsAdded(true);
+            preferenceScreen.addPreference(mThisDevicePref);
+            mPeersGroup.setEnabled(true);
+            preferenceScreen.addPreference(mPeersGroup);
+            */
+            //#else /* VENDOR_EDIT */
+            mPeersGroup.setEnabled(true);
+            //#endif /* VENDOR_EDIT */
+            //#ifndef VENDOR_EDIT
+            //YanChen@Prd.SysApp.WIFI, 2013/06/03, Remove for 
+            /*
+            mPersistentGroup.setEnabled(true);
+            preferenceScreen.addPreference(mPersistentGroup);
+            */
+            //#endif /* VENDOR_EDIT */
+            /* Request latest set of peers */
+           mWifiP2pManager.requestPeers(mChannel, WifiP2pSettings.this);
+	   startSearch();
+	   updateSearchMenuTitle();
+        }
+    }
+    private void updateSearchMenu(boolean searching) {
+       mWifiP2pSearching = searching;
+       //#ifndef VENDOR_EDIT
+       //YanChen@Prd.SysApp.WIFI, 2013/06/03, Remove for 
+       /*
+       Activity activity = getActivity();
+       if (activity != null) activity.invalidateOptionsMenu();
+       */
+       //#endif /* VENDOR_EDIT */
+       //#ifdef VENDOR_EDIT
+       //YanChen@Prd.SysApp.WIFI, 2013/06/03, Add for 
+         //#ifndef VENDOR_EDIT
+          //yimin@exp.data.modify,2014/3/25
+          /*
+       mScanPreference.setEnabled(mWifiP2pEnabled && !mWifiP2pSearching);
+       mRenamePreference.setEnabled(mWifiP2pEnabled); 
+       if (mWifiP2pSearching) {
+            mScanPreference.setTitle(R.string.wifi_p2p_menu_searching);
+        } else {
+            mScanPreference.setTitle(R.string.wifi_p2p_menu_search);
+        }
+	*/	
+        mWifiP2pSearching = searching;
+        Activity activity = this;
+        if (activity != null) activity.invalidateOptionsMenu();
+       //#endif /* VENDOR_EDIT */
+    }
+    private void startSearch() {
+        Intent sendSearchToCntServiceIntent = new Intent(WifiP2pSettings.this, WifiP2pConnectService.class);
+        sendSearchToCntServiceIntent.putExtra("command","search");
+        startService(sendSearchToCntServiceIntent);
+    }
+    private void updateDevicePref() {
+        if (mThisDevice != null) {
+            if (TextUtils.isEmpty(mThisDevice.deviceName)) {
+                mThisDevicePref.setTitle(mThisDevice.deviceAddress);
+                Log.e(TAG,"address "+mThisDevice.deviceAddress);
+            } else {
+                mThisDevicePref.setTitle(mThisDevice.deviceName);
+                Log.e(TAG,"devicename "+mThisDevice.deviceName);
+            }
+            mThisDevicePref.setPersistent(false);
+            mThisDevicePref.setEnabled(true);
+            mThisDevicePref.setSelectable(false);
+        }
+    }
+    private void sendFile(String paths) {
+        Log.w(TAG,"change command command command");
+        Intent mIntent = new Intent(WifiP2pSettings.this, ControlService.class);
+        mIntent.putExtra("command","sendpath");
+        //mIntent.putExtra("path",paths);
+       mIntent.putParcelableArrayListExtra("uris", mUris);
+        startService(mIntent);
+    }
+}
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/ui/Utf8ByteLengthFilter.java
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/ui/Utf8ByteLengthFilter.java	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/ui/Utf8ByteLengthFilter.java	(版本 25821)
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.oppo.wifidirect.ui;
+import android.text.InputFilter;
+import android.text.Spanned;
+/**
+ * This filter will constrain edits so that the text length is not
+ * greater than the specified number of bytes using UTF-8 encoding.
+ * <p>The JNI method used by {@link android.server.BluetoothService}
+ * to convert UTF-16 to UTF-8 doesn't support surrogate pairs,
+ * therefore code points outside of the basic multilingual plane
+ * (0000-FFFF) will be encoded as a pair of 3-byte UTF-8 characters,
+ * rather than a single 4-byte UTF-8 encoding. Dalvik implements this
+ * conversion in {@code convertUtf16ToUtf8()} in
+ * {@code dalvik/vm/UtfString.c}.
+ * <p>This JNI method is unlikely to change in the future due to
+ * backwards compatibility requirements. It's also unclear whether
+ * the installed base of Bluetooth devices would correctly handle the
+ * encoding of surrogate pairs in UTF-8 as 4 bytes rather than 6.
+ * However, this filter will still work in scenarios where surrogate
+ * pairs are encoded as 4 bytes, with the caveat that the maximum
+ * length will be constrained more conservatively than necessary.
+ */
+public class Utf8ByteLengthFilter implements InputFilter {
+    private final int mMaxBytes;
+    private static final int ENGLISH_UTF8 = 0x0080;
+    private static final int CHINESE_UFT8 = 0x0800;
+    private static final int ENGLISH_CHAR_LENGTH = 1;
+    private static final int OTHER_CHAR_LENGTH = 2;
+    private static final int CHINESE_CHAR_LENGTH = 3;
+    /**
+     * M: Utf8ByteLengthFilter
+     * @param
+     * @return
+     */
+    public Utf8ByteLengthFilter(int maxBytes) {
+        mMaxBytes = maxBytes;
+    }
+    /**
+     * M: filter
+     * @param
+     * @return
+     */
+    public CharSequence filter(CharSequence source, int start, int end,
+                               Spanned dest, int dstart, int dend) {
+        int srcByteCount = 0;
+        // count UTF-8 bytes in source substring
+        for (int i = start; i < end; i++) {
+            char c = source.charAt(i);
+            srcByteCount += (c < (char) ENGLISH_UTF8) ? ENGLISH_CHAR_LENGTH :
+                (c < (char) CHINESE_UFT8 ? OTHER_CHAR_LENGTH : CHINESE_CHAR_LENGTH);
+        }
+        int destLen = dest.length();
+        int destByteCount = 0;
+        // count UTF-8 bytes in destination excluding replaced section
+        for (int i = 0; i < destLen; i++) {
+            if (i < dstart || i >= dend) {
+                char c = dest.charAt(i);
+                destByteCount += (c < (char) ENGLISH_UTF8) ? ENGLISH_CHAR_LENGTH :
+                    (c < (char) CHINESE_UFT8 ? OTHER_CHAR_LENGTH : CHINESE_CHAR_LENGTH);
+            }
+        }
+        int keepBytes = mMaxBytes - destByteCount;
+        if (keepBytes <= 0) {
+            return "";
+        } else if (keepBytes >= srcByteCount) {
+            return null; // use original dest string
+        } else {
+            // find end position of largest sequence that fits in keepBytes
+            for (int i = start; i < end; i++) {
+                char c = source.charAt(i);
+                keepBytes -= (c < (char) ENGLISH_UTF8) ? ENGLISH_CHAR_LENGTH :
+                    (c < (char) CHINESE_UFT8 ? OTHER_CHAR_LENGTH : CHINESE_CHAR_LENGTH);
+                if (keepBytes < 0) {
+                    return source.subSequence(start, i);
+                }
+            }
+            // If the entire substring fits, we should have returned null
+            // above, so this line should not be reached. If for some
+            // reason it is, return null to use the original dest string.
+            return null;
+        }
+    }
+}
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/ui/WifiP2pNotification.java
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/ui/WifiP2pNotification.java	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/ui/WifiP2pNotification.java	(版本 25821)
+package com.oppo.wifidirect.util;
+import com.oppo.wifidirect.Constants;
+import com.oppo.wifidirect.R;
+import android.app.Notification;
+import android.app.NotificationManager;
+import android.content.Context;
+import android.widget.RemoteViews;
+import android.util.Log;
+public class WifiP2pNotification {
+    private Context mContext;
+    private String mPackageName;
+    private int action;
+    private Notification mNotification = null;
+	private NotificationManager mNm = null;
+	private RemoteViews mRemoteViews = null;
+    private int historyProgress = 0;
+    private final int SEND_ACTION = 0;
+    private final int RECEIVE_ACTION = 1;
+    private final String tag = "WifiP2pNotification";
+    public WifiP2pNotification(Context context, String packageName, int action) {
+        mContext = context;
+        mPackageName = packageName;
+        this.action = action;
+    }
+    private void showNotification() {
+			if (mNm == null) {
+				mNm = (NotificationManager) mContext
+						.getSystemService(Context.NOTIFICATION_SERVICE);
+			}
+			mRemoteViews = new RemoteViews(mPackageName,
+					R.layout.notification_remote);
+			mRemoteViews.setTextViewText(R.id.notification_title,
+					mContext.getResources().getString(R.string.notification_title));
+			mRemoteViews.setTextViewText(
+					R.id.notification_progress,
+					mContext.getResources().getString(
+							R.string.notification_progress_sign));
+			mRemoteViews.setProgressBar(R.id.notification_pb, 100, 0, false);
+			mRemoteViews.setImageViewResource(R.id.icon, R.drawable.big_upload);
+			Notification.Builder builder = new Notification.Builder(mContext);
+			builder.setContent(mRemoteViews);
+			builder.setSmallIcon(R.drawable.stat_sys_upload);
+			builder.setWhen(System.currentTimeMillis());
+			builder.setTicker(mContext.getResources().getString(
+					R.string.notification_title));
+			mNotification = builder.getNotification();
+			mNotification.flags = Notification.FLAG_ONGOING_EVENT;
+			mNm.notify(Constants.APPLICATION_NOTIFICATION_ID, mNotification);
+			Log.d(tag, "showNotification()");
+		}
+        private void removeNotification() {
+			if (mNm == null) {
+				mNm = (NotificationManager) mContext
+						.getSystemService(Context.NOTIFICATION_SERVICE);
+			}
+			Log.d(tag, "will cancel notification");
+			mNm.cancel(Constants.APPLICATION_NOTIFICATION_ID);
+		}
+		private void updateNotification(int progressValue) {
+			if (historyProgress != progressValue) {
+				if (mNotification == null || mNm == null) {
+					return;
+				}
+				mNotification.contentView.setTextViewText(
+						R.id.notification_progress,
+						progressValue
+								+ mContext.getResources().getString(
+										R.string.notification_progress_sign));
+				mNotification.contentView.setProgressBar(R.id.notification_pb,
+						100, progressValue, false);
+				historyProgress = progressValue;
+				mNm.notify(Constants.APPLICATION_NOTIFICATION_ID, mNotification);
+			}
+		}
+}
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/ui/WifiP2pPeer.java
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/ui/WifiP2pPeer.java	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/ui/WifiP2pPeer.java	(版本 25821)
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.oppo.wifidirect.ui;
+import com.oppo.wifidirect.R;
+import android.content.Context;
+import android.net.wifi.WifiManager;
+import android.net.wifi.p2p.WifiP2pManager;
+import android.net.wifi.p2p.WifiP2pDevice;
+import android.preference.Preference;
+import android.text.TextUtils;
+import android.view.View;
+import android.widget.ImageView;
+import java.util.Comparator;
+public class WifiP2pPeer extends Preference {
+    private static final int[] STATE_SECURED = {R.attr.state_encrypted};
+    public WifiP2pDevice device;
+    private int mRssi;
+    private ImageView mSignal;
+    private static final int SIGNAL_LEVELS = 5;
+    public WifiP2pPeer(Context context, WifiP2pDevice dev) {
+        super(context);
+        device = dev;
+        setWidgetLayoutResource(R.layout.preference_widget_wifi_signal);
+        mRssi = 60; //TODO: fix
+    }
+    @Override
+    protected void onBindView(View view) {
+        if (TextUtils.isEmpty(device.deviceName)) {
+            setTitle(device.deviceAddress);
+        } else {
+            setTitle(device.deviceName);
+        }
+        mSignal = (ImageView) view.findViewById(R.id.signal);
+        if (mRssi == Integer.MAX_VALUE) {
+            mSignal.setImageDrawable(null);
+        } else {
+            mSignal.setImageResource(R.drawable.wifi_signal);
+            mSignal.setImageState(STATE_SECURED,  true);
+        }
+        refresh();
+        super.onBindView(view); 
+    }
+    @Override
+    public int compareTo(Preference preference) {
+        if (!(preference instanceof WifiP2pPeer)) {
+            return 1;
+        }
+        WifiP2pPeer other = (WifiP2pPeer) preference;
+        // devices go in the order of the status
+        if (device.status != other.device.status) {
+            return device.status < other.device.status ? -1 : 1;
+        }
+        // Sort by name/address
+        if (device.deviceName != null) {
+            return device.deviceName.compareToIgnoreCase(other.device.deviceName);
+        }
+        return device.deviceAddress.compareToIgnoreCase(other.device.deviceAddress);
+    }
+    int getLevel() {
+        if (mRssi == Integer.MAX_VALUE) {
+            return -1;
+        }
+        return WifiManager.calculateSignalLevel(mRssi, SIGNAL_LEVELS);
+    }
+    private void refresh() {
+        if (mSignal == null) {
+            return;
+        }
+        Context context = getContext();
+        mSignal.setImageLevel(getLevel());
+        String[] statusArray = context.getResources().getStringArray(R.array.wifi_p2p_status);
+        setSummary(statusArray[device.status]);
+    }
+}
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/ui/WifiP2pPersistentGroup.java
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/ui/WifiP2pPersistentGroup.java	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/ui/WifiP2pPersistentGroup.java	(版本 25821)
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.oppo.wifidirect.ui;
+import android.content.Context;
+import android.net.wifi.p2p.WifiP2pGroup;
+import android.preference.Preference;
+import android.view.View;
+public class WifiP2pPersistentGroup extends Preference {
+    public WifiP2pGroup mGroup;
+    public WifiP2pPersistentGroup(Context context, WifiP2pGroup group) {
+        super(context);
+        mGroup = group;
+    }
+    @Override
+    protected void onBindView(View view) {
+        setTitle(mGroup.getNetworkName());
+        super.onBindView(view);
+    }
+    int getNetworkId() {
+        return mGroup.getNetworkId();
+    }
+    String getGroupName() {
+        return mGroup.getNetworkName();
+    }
+}
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/util/Utils.java
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/util/Utils.java	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/util/Utils.java	(版本 25821)
+package com.oppo.wifidirect.util;
+import android.content.Context;
+import android.net.Uri;
+import android.util.Log;
+import android.util.Patterns;
+import com.oppo.wifidirect.R;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.text.SimpleDateFormat;
+import java.util.regex.*;
+public class Utils {
+    private static final String TAG = "Utils";
+    public static Uri createContextFileForText(Context context, CharSequence subject,
+            CharSequence text) {
+        if (text == null) {
+            return null;
+        }
+		Log.w(TAG, "[URL pattern match begin, text: " + text.toString());
+		if( subject != null ){
+			Log.w(TAG, "[URL pattern match begin, subject: " + subject.toString());
+		}
+        FileOutputStream out = null;
+        try {
+            // delete first
+            String filename = context.getString(R.string.bt_opp_push_file_name);
+            context.deleteFile(filename);
+            // replace subject if it's null
+			//subject = (subject == null) ? text : subject;
+			// new algorithm for APP link share
+			// 1. if text contains content + link, then we need to parse link and set as href, 
+			//     left content will be showed as html body. subject feild will not be showed.
+			// 2. if text only contains link(Compatible MTK Browser share):
+			//     (a) if subject feild is not empty, then show subject as html body, link as href.
+			//     (b) if subject feild is empty, then show link as html body, also link as href.
+			// 3. if text only contains plain-text, then only fill in text as html body, ignore subject.
+			// retrieve URL bt web regular expression	
+			Matcher matcher = Patterns.WEB_URL.matcher(text); 
+			String urlLink = null;	
+			int currentMatchIdx = 0; 
+			int currentStartIdx = 0;
+			// match url and compose html
+			String content = "<html><head><meta http-equiv=\"Content-Type\" content=\"text/html;"
+			                 + " charset=UTF-8\"/></head><body>";
+			StringBuffer body = new StringBuffer();
+			// fill body and href				  
+			while (matcher.find()) {
+				urlLink = matcher.group();
+				Log.w(TAG, "URL pattern match result, link: " + urlLink ); 
+				Log.w(TAG, "URL pattern match result, link.length: " + urlLink.length() ); 
+				currentMatchIdx = matcher.start();	
+				Log.w(TAG, "URL pattern  current start index - " + currentStartIdx );
+				Log.w(TAG, "URL pattern  current match index - " + currentMatchIdx );
+				if (text.length() > urlLink.length()) {
+					if (currentMatchIdx > currentStartIdx) {
+						//text not start with uri, add text body
+						body.append( text.toString().substring( currentStartIdx, currentMatchIdx ) );
+						body.append( "<a href=\"" + urlLink + "\">" );
+						body.append( urlLink ); 
+						body.append( "</a></p>" );		
+					} else if (currentMatchIdx == currentStartIdx) {
+						//text start with uri
+						body.append( "<a href=\"" + urlLink + "\">" );
+						body.append( urlLink ); 
+						body.append( "</a></p>" );		
+						// if there is left body(without uri), need to append left part to body
+					}
+					currentStartIdx = currentMatchIdx + urlLink.length();
+				} else {
+					// uri length == text length, no other text as body 
+					if (subject == null) {
+						body.append( "<a href=\"" + urlLink + "\">" );
+						body.append( urlLink );
+						body.append( "</a></p>" );	
+					} else {
+						body.append( "<a href=\"" + urlLink + "\">" );
+						body.append( subject );
+						body.append( "</a></p>" );	
+					}
+					currentStartIdx = text.length();
+					break;
+				}
+			} 
+			Log.w(TAG, "After match currentStartIdx - " + currentStartIdx );
+			Log.w(TAG, "After match current body:" + body.toString());
+			// append left part(can not handle by match loop) to body
+			if ((body.length() != 0) && (currentStartIdx < text.length())) {
+				body.append( text.toString().substring( currentStartIdx, text.length()) );
+			}
+			// check if no url match in text, fill full text as body, ignore subject feild
+			if (body.length() == 0) {
+				body.append( text );
+			}
+			// fill end charaters
+			content += body.toString();
+			content += "</body></html>";
+			Log.w(TAG, "URL final compose content: " + content); 
+			byte[] byteBuff = content.getBytes();
+			// change the text as hyperlink
+			/*
+			StringBuilder content = new StringBuilder( 125 + text.length()*2 )
+				.append( "<html><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"/></head><body>" )
+				.append( "<a href=\"" ).append( text ).append( "\">" ).append( subject ).append( "</a>" )
+				.append( "</body></html>" );
+                   */
+			// open and write file
+			out = context.openFileOutput( filename, Context.MODE_PRIVATE );
+			//out.write( content.toString().getBytes() );
+			out.write( byteBuff, 0, byteBuff.length);
+            out.flush();
+            // create Uri
+            Uri result = Uri.fromFile(new File(context.getFilesDir(), filename));
+            if (result == null) {
+                Log.w(TAG, "createContextFileForText() - can't get Uri for created file.");
+                context.deleteFile(filename);
+            }
+            return result;
+        } catch (IOException ex) {
+            Log.w(TAG, "createContextFileForText() error:" + ex.toString());
+            return null;
+        } finally {
+            try {
+                if (out != null) {
+                    out.close();
+                }
+            } catch (IOException ex) {
+                Log.w(TAG, "createContextFileForText() closing file output stream fail: "
+                        + ex.toString());
+            }
+        }
+    }
+}
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/util/WifiP2pFilePath.aidl
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/util/WifiP2pFilePath.aidl	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/util/WifiP2pFilePath.aidl	(版本 25821)
+package com.oppo.wifidirect.util;
+parcelable WifiP2pFilePath;
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/util/TaskQueue.java
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/util/TaskQueue.java	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/util/TaskQueue.java	(版本 25821)
+package com.oppo.wifidirect.util;
+import com.oppo.wifidirect.util.WifiP2pNamedTask;
+import java.util.concurrent.LinkedBlockingQueue;
+import android.util.Log;
+public class TaskQueue {
+    private static final boolean DBG = true;
+    private static final String TAG = "QueueTask";
+    private final LinkedBlockingQueue<WifiP2pNamedTask> mQueue;
+    private final Worker mWorker;
+    private volatile boolean mClosed = false;
+    private volatile boolean p2pConnected  = false;
+    public TaskQueue() {
+        mQueue = new LinkedBlockingQueue<WifiP2pNamedTask>();
+        mWorker = new Worker();
+        mWorker.start();
+    }
+    public void cancelPendingTasks() {
+        if (DBG) Log.d(TAG, "Cancelling " + mQueue.size() + " tasks: " + mWorker.getName());
+        if (mClosed) {
+            throw new IllegalStateException("cancelPendingTasks() after close()");
+        }
+        mQueue.clear();
+    }
+    public void close() {
+        mClosed = true;
+        mWorker.interrupt();
+        mQueue.clear();
+    }
+    public void execute(WifiP2pNamedTask task) {
+        Log.d(TAG, "execute");
+        if (mClosed) {
+            throw new IllegalStateException("execute() after close()");
+        }
+        mQueue.add(task);
+        Log.d(TAG, "mQueue.size() " + mQueue.size());
+    }
+    public void wakeUpTaskQueue() {
+    	p2pConnected = true;
+    	Object lock = mWorker.getLock();
+    	synchronized(lock) {
+    		lock.notify();
+    	}
+    }
+    public void holdTaskQueue() {
+    	p2pConnected = false;
+    }
+    public class Worker extends Thread {
+    	private Object lock = new Object();
+    	public Object getLock() {
+    		return lock;
+    	}
+        public void run() {
+            try {
+            	Log.w(TAG, "before loop");
+                loop();
+                Log.w(TAG, "after loop");
+            } finally {
+                if (!mClosed) Log.w(TAG, "Worker exited before close");
+            }
+        }
+        private void loop() {
+            Thread currentThread = Thread.currentThread();
+            String threadName = currentThread.getName();
+            while (!mClosed) {
+            	if(!p2pConnected){
+            		try {
+            			Log.e(TAG, "wait prior task is over, then go on");
+            			synchronized(lock) {
+            				lock.wait();
+            			}
+					} catch (InterruptedException e) {
+						// TODO Auto-generated catch block
+						//e.printStackTrace();
+                        Log.d(TAG, Log.getStackTraceString(e));
+					}
+            	}
+                //when the other device reject to connect,we will cancel connect
+                //close TaskQueue,this whie will get task to excute,stop it!
+                if(!mClosed) {
+                    WifiP2pNamedTask task;
+                    try {
+                        task = mQueue.take();
+                        Log.e(TAG, "get task!");
+                    } catch (InterruptedException ex) {
+                        continue;
+                    }
+                    currentThread.setName(threadName + " " + task.getName());
+                    try {
+                        if (DBG) Log.d(TAG, "Running task " + task.getName());
+                        task.run();
+                        if (DBG) Log.d(TAG, "Complete task " + task.getName() );
+                    } catch (RuntimeException ex) {
+                        Log.e(TAG, "Task " + task.getName() + " failed", ex);
+                    }
+                } else {
+                    Log.d(TAG, "taskqueue is closed");
+                    break;
+                }
+            }
+        }
+    }
+}
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/util/WifiP2pNamedTask.java
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/util/WifiP2pNamedTask.java	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/util/WifiP2pNamedTask.java	(版本 25821)
+package com.oppo.wifidirect.util;
+/**
+ * A task that has a name.
+ */
+public interface WifiP2pNamedTask extends Runnable {
+    String getName();
+}
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/util/MediaScanner.java
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/util/MediaScanner.java	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/util/MediaScanner.java	(版本 25821)
+/* Copyright Statement:
+ *
+ * This software/firmware and related documentation ("MediaTek Software") are
+ * protected under relevant copyright laws. The information contained herein
+ * is confidential and proprietary to MediaTek Inc. and/or its licensors.
+ * Without the prior written permission of MediaTek inc. and/or its licensors,
+ * any reproduction, modification, use or disclosure of MediaTek Software,
+ * and information contained herein, in whole or in part, shall be strictly prohibited.
+ *
+ * MediaTek Inc. (C) 2010. All rights reserved.
+ *
+ * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
+ * THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
+ * RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO RECEIVER ON
+ * AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
+ * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
+ * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
+ * SUPPLIED WITH THE MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
+ * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
+ * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
+ * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
+ * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
+ * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
+ * CUMULATIVE LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
+ * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
+ * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
+ * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
+ *
+ * The following software/firmware and/or related documentation ("MediaTek Software")
+ * have been modified by MediaTek Inc. All revisions are subject to any receiver's
+ * applicable license agreements with MediaTek Inc.
+ */
+package com.oppo.wifidirect.util;
+import android.content.Context;
+import android.media.MediaScannerConnection;
+import android.media.MediaScannerConnection.MediaScannerConnectionClient;
+import android.net.Uri;
+import android.os.Handler;
+import android.os.Message;
+import android.util.Log;
+public class MediaScanner implements MediaScannerConnectionClient {
+    private static final String TAG = "MediaScanner";
+    public static final int MEDIA_SCANNED = 0;
+    public static final int MEDIA_SCAN_FAILED = 1;
+    private Context context;
+    private String path;
+    private String mimeType;
+    private Handler callback;
+    private int callbackId;
+    private MediaScannerConnection msc;
+    public MediaScanner( Context context, String path, String mimeType, Handler callback, int callbackId ) {
+        this.context = context;
+        this.path = path;
+        this.mimeType = mimeType;
+        this.callback = callback;
+        this.callbackId = callbackId;
+        this.msc = new MediaScannerConnection( this.context, this );
+        Log.d( TAG, "[BT][MMI][MediaScanner]: connecting to Media Scanner Service" );
+        this.msc.connect();
+    }
+    public void onMediaScannerConnected(){
+        try {
+            Log.d( TAG, "[BT][MMI][onMediaScannerConnected]: MediaScanner connected." );
+            this.msc.scanFile( this.path, this.mimeType );
+        }
+        catch( Exception ex ){
+            Log.i( TAG, "[BT][MMI][onMediaScannerConnected]: MediaScanner exception: " + ex );
+        }
+    }
+    public void onScanCompleted( String path, Uri uri ){
+        Log.d( TAG, "[BT][MMI][onScanCompleted]: path=" + path + ", uri=" + uri );
+        try {
+            if( this.callback != null ){
+                Message msg = Message.obtain( this.callback );
+                msg.arg1 = this.callbackId;
+                msg.obj = uri;
+                msg.what = ( uri != null ) ? MEDIA_SCANNED : MEDIA_SCAN_FAILED;
+                msg.sendToTarget();
+            }
+        }
+        catch( Exception ex ){
+            Log.i( TAG, "[BT][MMI][onScanCompleted]: MediaScanner exception: " + ex );
+        }
+        finally {
+            this.msc.disconnect();
+        }
+    }
+}
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/util/MimeType.java
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/util/MimeType.java	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/util/MimeType.java	(版本 25821)
+package com.oppo.wifidirect.util;
+import com.oppo.wifidirect.R;
+//import com.oppo.os.OppoEnvironment;
+import android.os.Environment;
+import com.oppo.os.OppoUsbEnvironment;
+import android.util.Log;
+import java.util.regex.Pattern;
+public class MimeType {
+    public static final String tag = "MimeType";
+    public static final String[] ACCEPTABLE_SHARE_OUTBOUND_TYPES = new String[] {
+        "image/*", "text/x-vcard",
+    };
+    public static final String[] UNACCEPTABLE_SHARE_OUTBOUND_TYPES = new String[] {
+        "virus/*",
+    };
+    public static final String[] ACCEPTABLE_SHARE_INBOUND_TYPES = new String[] {
+        "image/*",
+        "video/*",
+        "audio/*",
+        "text/x-vcard",
+        "text/plain",
+        "text/html",
+        "application/zip",
+        "application/vnd.ms-excel",
+        "application/msword",
+        "application/vnd.ms-powerpoint",
+        "application/pdf",
+    };
+    public static final String[] UNACCEPTABLE_SHARE_INBOUND_TYPES = new String[] {
+        "text/x-vcalendar",
+        "text/x-vcard",
+    };
+    public static final String[] ACCEPTABLE_SHARE_INBOUND_CALENDAR_TYPES = new String[] {
+        "vcs",
+        "ics",
+    };
+    public static final String[] ACCEPTABLE_SHARE_INBOUND_CONTACT_TYPES = new String[] {
+        "vcf",
+        "csv",
+    };
+    public static final String[] ACCEPTABLE_SHARE_INBOUND_MUSIC_TYPES = new String[] {
+        "mp3",
+        "midi",
+		"wma",
+		"lrc",
+		"wav",
+		"aac",
+		"awb",
+		"ape",
+		"ogg",
+		"flac",
+		"imy",
+		"m4a",
+		"lrc",
+		"mid",    
+    };
+    public static final String[] ACCEPTABLE_SHARE_INBOUND_IMAGE_TYPES = new String[] {
+        "jpg",
+        "jpeg",
+		"png",
+		"bmp",
+        "wbmp",
+		"gif",
+    };
+    public static final String[] ACCEPTABLE_SHARE_INBOUND_VEDIO_TYPES = new String[] {
+        "mp4",
+        "3gp",
+		"avi",
+		"rm",
+		"rmvb",
+		"flv",
+		"asf",
+		"wmv",
+		"srt",
+		"mov",
+		"mkv",		
+    };
+	public static final String[] ACCEPTABLE_SHARE_INBOUND_BOOK_TYPES = new String[] {
+        "txt",
+        "pdb",
+        "umd",
+    };
+    public static final String[] ACCEPTABLE_SHARE_INBOUND_THEME_TYPES = new String[] {
+        "theme",
+    };
+	public static final String[] ACCEPTABLE_SHARE_INBOUND_RECORDER_TYPES = new String[] {
+		"amr",
+    };
+	public static final String[] ACCEPTABLE_SHARE_INBOUND_OFFICE_TYPES = new String[] {
+        "doc",
+		"xls",
+		"ppt",
+		"pdf",
+		"docx",
+		"xlsx",
+		"pptx",
+    };
+    public static final int MUSIC_DEFAULT_STORE_SUBDIR = R.string.save_path_music;
+    public static final int IMAGE_DEFAULT_STORE_SUBDIR = R.string.save_path_image;
+    public static final int VEDIO_DEFAULT_STORE_SUBDIR = R.string.save_path_vedio;
+    public static final int BOOK_DEFAULT_STORE_SUBDIR  = R.string.save_path_book;
+    public static final int THEME_DEFAULT_STORE_SUBDIR = R.string.save_path_theme;
+    public static final int RECORDER_DEFAULT_STORE_SUBDIR = R.string.save_path_recorder;
+	public static final int OFFICE_DEFAULT_STORE_SUBDIR = R.string.save_path_office;
+    public static final int OTHER_DEFAULT_STORE_SUBDIR = R.string.save_path_other;
+    public static final int[] SavePathDirs = {MUSIC_DEFAULT_STORE_SUBDIR, IMAGE_DEFAULT_STORE_SUBDIR,
+                        VEDIO_DEFAULT_STORE_SUBDIR, OTHER_DEFAULT_STORE_SUBDIR};
+    public static final String PHONE_ROOT = OppoUsbEnvironment.getExternalStorageDirectory().getPath();
+    public static final String MEMORY_CARD_ROOT = OppoUsbEnvironment.getExternalStorageDirectory().getPath();
+    //file name has extension
+    public static String getExtensionFromFileName(String name) {
+        if(null == name) {
+            return null;
+        }
+        int dotIndex = name.lastIndexOf(".");
+        String extension = null;
+        if (dotIndex < 0) {
+            Log.i(tag, "no extension");
+        } else {
+            extension = name.substring(dotIndex + 1);
+        }
+        if (extension != null) {
+    		Log.i(tag, "getExtensionFromFileName extension = " + extension );
+		}
+        return extension;
+    }
+    //file name has no extension
+    public static String getNoExtensionFileName(String name) {
+        if(null == name)
+        {
+            return null;
+        }
+        int dotIndex = name.lastIndexOf(".");
+        String filename = name;
+        if (dotIndex < 0) {
+            Log.i(tag, "no extension");
+        } else {
+            filename = name.substring(0, dotIndex);
+        }
+        return filename;
+    }
+    public static int getDirTypeFromExtension(String extension)
+    {
+        int dirId = 0;
+        Log.i(tag, "extension:" + extension);
+        if(null == extension)
+        {
+            return MimeType.OTHER_DEFAULT_STORE_SUBDIR;
+        }
+        if(MimeType.mimeTypeMatches(extension.toLowerCase(), MimeType.ACCEPTABLE_SHARE_INBOUND_MUSIC_TYPES))
+        {
+            Log.i(tag, "music file");
+            dirId = MimeType.MUSIC_DEFAULT_STORE_SUBDIR;
+        }
+        else if(MimeType.mimeTypeMatches(extension.toLowerCase(), MimeType.ACCEPTABLE_SHARE_INBOUND_IMAGE_TYPES))
+        {
+            Log.i(tag, "image file");
+            dirId = MimeType.IMAGE_DEFAULT_STORE_SUBDIR;
+        }
+        else if(MimeType.mimeTypeMatches(extension.toLowerCase(), MimeType.ACCEPTABLE_SHARE_INBOUND_VEDIO_TYPES))
+        {
+            Log.i(tag, "vedio file");
+            dirId = MimeType.VEDIO_DEFAULT_STORE_SUBDIR;
+        }
+		else if(MimeType.mimeTypeMatches(extension.toLowerCase(), MimeType.ACCEPTABLE_SHARE_INBOUND_BOOK_TYPES))
+        {
+            Log.i(tag, "book file");
+            dirId = MimeType.BOOK_DEFAULT_STORE_SUBDIR;
+        }
+        else if(MimeType.mimeTypeMatches(extension.toLowerCase(), MimeType.ACCEPTABLE_SHARE_INBOUND_THEME_TYPES))
+        {
+            Log.i(tag, "theme file");
+            dirId = MimeType.THEME_DEFAULT_STORE_SUBDIR;
+        }
+        else if(MimeType.mimeTypeMatches(extension.toLowerCase(), MimeType.ACCEPTABLE_SHARE_INBOUND_RECORDER_TYPES))
+        {
+            Log.i(tag, "recorder file");
+            dirId = MimeType.RECORDER_DEFAULT_STORE_SUBDIR;
+        }
+		else if(MimeType.mimeTypeMatches(extension.toLowerCase(), MimeType.ACCEPTABLE_SHARE_INBOUND_OFFICE_TYPES))
+        {
+            Log.i(tag, "office file");
+            dirId = MimeType.OFFICE_DEFAULT_STORE_SUBDIR;
+        }
+        else
+        {
+            Log.i(tag, "other file");
+            dirId = MimeType.OTHER_DEFAULT_STORE_SUBDIR;
+        }
+        return dirId;
+    }
+    public static boolean mimeTypeMatches(String mimeType, String[] matchAgainst) {
+        if(null == mimeType)
+        {
+            return false;
+        }
+        for (String matchType : matchAgainst) {
+            if (mimeTypeMatches(mimeType, matchType)) {
+                return true;
+            }
+        }
+        return false;
+    }
+    public static boolean mimeTypeMatches(String mimeType, String matchAgainst) {
+        if(null == mimeType)
+        {
+            return false;
+        }
+        Pattern p = Pattern.compile(matchAgainst.replaceAll("\\*", "\\.\\*"),
+                Pattern.CASE_INSENSITIVE);
+        return p.matcher(mimeType).matches();
+    }
+}
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/util/CalculateFreeSpace.java
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/util/CalculateFreeSpace.java	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/util/CalculateFreeSpace.java	(版本 25821)
+package com.oppo.wifidirect.util;
+import java.io.File;
+import android.os.Environment;
+import android.os.StatFs;
+import android.util.Log;
+public class CalculateFreeSpace {
+    public static final String tag = "CalculateFreeSpace";
+    public static long readSDCard() { 
+    	String state = Environment.getExternalStorageState(); 
+    	if(Environment.MEDIA_MOUNTED.equals(state)) { 
+	    	File sdcardDir = Environment.getExternalStorageDirectory(); 
+	    	StatFs sf = new StatFs(sdcardDir.getPath()); 
+	    	long blockSize = sf.getBlockSize(); 
+	    	long blockCount = sf.getBlockCount(); 
+	    	long availCount = sf.getAvailableBlocks(); 
+	    	Log.d(tag, "block size:"+ blockSize+",block count:"+ blockCount+",total space:"+blockSize*blockCount/1024+"KB"); 
+	    	Log.d(tag, "free block count:"+ availCount+",free space:"+ availCount*blockSize/1024+"KB"); 
+            long freeBytes = availCount * blockSize / 1024;
+            return freeBytes;
+    	} else {
+            return -1;
+    	}
+    }  
+    public static long readSystem() { 
+    	File root = Environment.getRootDirectory(); 
+    	StatFs sf = new StatFs(root.getPath()); 
+    	long blockSize = sf.getBlockSize(); 
+    	long blockCount = sf.getBlockCount(); 
+    	long availCount = sf.getAvailableBlocks(); 
+    	Log.d(tag, "block size:"+ blockSize+",block count:"+ blockCount+",total space:"+blockSize*blockCount/1024+"KB"); 
+    	Log.d(tag, "free block count:"+ availCount+",free space:"+ availCount*blockSize/1024+"KB"); 
+        long freeBytes = availCount * blockSize / 1024;
+        return freeBytes;
+    } 
+}
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/util/WifiP2pFilePath.java
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/util/WifiP2pFilePath.java	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/src/com/oppo/wifidirect/util/WifiP2pFilePath.java	(版本 25821)
+package com.oppo.wifidirect.util;
+import android.os.Parcelable;
+import android.os.Parcel;
+public class WifiP2pFilePath implements Parcelable {+
+    public String filePath;
+    public WifiP2pFilePath(String path) {
+        filePath = path;
+    }
+    public String toString() {
+        StringBuffer sbuf = new StringBuffer();
+        sbuf.append("filepath: ").append(filePath);
+        return sbuf.toString();
+    }
+    /** Implement the Parcelable interface {@hide} */
+    public int describeContents() {
+        return 0;
+    }
+    /** Implement the Parcelable interface {@hide} */
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeString(filePath);
+    }
+    /** Implement the Parcelable interface {@hide} */
+    public static final Creator<WifiP2pFilePath> CREATOR =
+        new Creator<WifiP2pFilePath>() {
+            public WifiP2pFilePath createFromParcel(Parcel in) {
+                WifiP2pFilePath mfilePath = new WifiP2pFilePath(in.readString());
+                return mfilePath;
+            }
+            public WifiP2pFilePath[] newArray(int size) {
+                return new WifiP2pFilePath[size];
+            }
+        };
+}
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ma-rIN/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ma-rIN/strings.xml	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ma-rIN/strings.xml	(版本 25821)
+<?xml version="1.0" encoding="utf-8" ?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="upload_succ_ok">OK</string>
+    <string name="download_fail_ok">OK</string>
+    <string name="bt_opp_push_file_name">wifidirect_share.html</string>
+    <string name="bt_error_btn_ok">OK</string>
+    <string name="cancel_transfer_dialog_button_negative">मागे</string>
+    <string name="no">रद्द करा</string>
+    <string name="notification_progress_sign">%</string>
+    <string name="debug_btn_receive">Jump to Receive</string>
+    <string name="debug_btn_send">Jump to Send</string>
+    <string name="cancel">रद्द करा</string>
+</resources>
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-pt/arrays.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-pt/arrays.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-pt/arrays.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-pt/arrays.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-pt/strings.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-pt/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-pt/strings.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-pt/strings.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/status_bar_close.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/status_bar_close.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/status_bar_close.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/status_bar_close.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_upload_anim0.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_upload_anim0.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_upload_anim0.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_upload_anim0.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_upload_anim1.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_upload_anim1.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_upload_anim1.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_upload_anim1.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_upload_anim2.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_upload_anim2.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_upload_anim2.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_upload_anim2.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_upload_anim3.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_upload_anim3.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_upload_anim3.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_upload_anim3.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_upload_anim4.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_upload_anim4.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_upload_anim4.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_upload_anim4.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_upload_anim5.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_upload_anim5.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_upload_anim5.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_upload_anim5.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/wifi_signal.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/wifi_signal.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/wifi_signal.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/wifi_signal.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/oppo_stat_notify_error.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/oppo_stat_notify_error.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/oppo_stat_notify_error.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/oppo_stat_notify_error.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_download.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_download.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_download.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_download.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/progress.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/progress.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/progress.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/progress.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_download_anim0.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_download_anim0.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_download_anim0.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_download_anim0.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_download_anim1.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_download_anim1.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_download_anim1.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_download_anim1.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_download_anim2.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_download_anim2.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_download_anim2.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_download_anim2.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_download_anim3.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_download_anim3.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_download_anim3.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_download_anim3.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/wifi_signal_open.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/wifi_signal_open.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/wifi_signal_open.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/wifi_signal_open.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_download_anim4.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_download_anim4.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_download_anim4.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_download_anim4.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_download_anim5.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_download_anim5.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_download_anim5.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_download_anim5.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/ic_wifi_lock_signal_0.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/ic_wifi_lock_signal_0.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/ic_wifi_lock_signal_0.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/ic_wifi_lock_signal_0.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/oppo_stat_sys_upload_anim0.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/oppo_stat_sys_upload_anim0.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/oppo_stat_sys_upload_anim0.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/oppo_stat_sys_upload_anim0.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/ic_wifi_lock_signal_1.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/ic_wifi_lock_signal_1.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/ic_wifi_lock_signal_1.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/ic_wifi_lock_signal_1.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/ic_wifi_lock_signal_2.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/ic_wifi_lock_signal_2.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/ic_wifi_lock_signal_2.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/ic_wifi_lock_signal_2.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/ic_wifi_lock_signal_3.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/ic_wifi_lock_signal_3.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/ic_wifi_lock_signal_3.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/ic_wifi_lock_signal_3.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/ic_wifi_lock_signal_4.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/ic_wifi_lock_signal_4.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/ic_wifi_lock_signal_4.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/ic_wifi_lock_signal_4.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/big_upload.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/big_upload.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/big_upload.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/big_upload.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/ic_launcher.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/ic_launcher.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/ic_launcher.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/ic_launcher.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/wifi_signal_lock.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/wifi_signal_lock.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/wifi_signal_lock.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/wifi_signal_lock.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/oppo_stat_sys_download_anim0.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/oppo_stat_sys_download_anim0.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/oppo_stat_sys_download_anim0.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/oppo_stat_sys_download_anim0.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/ic_wifi_signal_0.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/ic_wifi_signal_0.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/ic_wifi_signal_0.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/ic_wifi_signal_0.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/ic_wifi_signal_1.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/ic_wifi_signal_1.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/ic_wifi_signal_1.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/ic_wifi_signal_1.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/ic_wifi_signal_2.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/ic_wifi_signal_2.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/ic_wifi_signal_2.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/ic_wifi_signal_2.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/big_download.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/big_download.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/big_download.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/big_download.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/ic_wifi_signal_3.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/ic_wifi_signal_3.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/ic_wifi_signal_3.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/ic_wifi_signal_3.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_upload.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_upload.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_upload.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/stat_sys_upload.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/ic_wifi_signal_4.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/ic_wifi_signal_4.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/ic_wifi_signal_4.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable/ic_wifi_signal_4.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-tr/arrays.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-tr/arrays.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-tr/arrays.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-tr/arrays.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-tr/strings.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-tr/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-tr/strings.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-tr/strings.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-af/arrays.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-af/arrays.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-af/arrays.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-af/arrays.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-af/strings.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-af/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-af/strings.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-af/strings.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ru/arrays.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ru/arrays.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ru/arrays.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ru/arrays.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ru/strings.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ru/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ru/strings.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ru/strings.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-es-rCO/arrays.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-es-rCO/arrays.xml	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-es-rCO/arrays.xml	(版本 25821)
+<?xml version="1.0" encoding="utf-8" ?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string-array name="wifi_p2p_status">
+        <item msgid="1701505390737218306">Conectado</item>
+        <item msgid="3189211552661432651">Invitado</item>
+        <item msgid="3206450250360237549">Con error</item>
+        <item msgid="7785896708926971207">Disponible</item>
+        <item msgid="2330782789550628803">Fuera del alcance</item>
+    </string-array>
+</resources>
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-es-rCO/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-es-rCO/strings.xml	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-es-rCO/strings.xml	(版本 25821)
+<?xml version="1.0" encoding="utf-8" ?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="wifi_menu_scan" msgid="192587958424295789">Buscando</string>
+    <string name="progress_scanning" msgid="192587958424295789">Buscando</string>
+    <string name="bt_toast_4">No se pudo enviar el archivo</string>
+    <string name="upload_fail_line1_2">Archivo: %1$s</string>
+    <string name="upload_fail_line1">A \u0022%1$s\u0022.</string>
+    <string name="download_fail_line3">Causas: %1$s</string>
+    <string name="download_fail_line1">No se recibió el archivo</string>
+    <string name="bt_sm_2_2">Espacio requerido por S: %1$s</string>
+    <string name="download_fail_line2">Archivo: %1$s</string>
+    <string name="bt_sm_2_1">Espacio Insuficiente en el teléfono para guardar el archivo de \'%1$s\'</string>
+    <string name="bt_sm_2_1_phone">Espacio en la tarjeta SD insuficiente, el archivo de \"%1$s\" no se puede guardar</string>
+    <string name="upload_succ_line5">Enviar archivo</string>
+    <string name="upload_line3">Tipo de archivo: %1$s (%2$s)</string>
+    <string name="upload_line1">A: \u0022%1$s\u0022</string>
+    <string name="download_succ_line5">Archivo recibido</string>
+    <string name="download_title">Transferir archivo</string>
+    <string name="download_line5">recibido\u2026</string>
+    <string name="download_line3">Tamaño del archivo: %1$s</string>
+    <string name="download_line2">Archivo: %1$s</string>
+    <string name="file_save_path">Guardar directorio: %1$s</string>
+    <string name="download_line1">De: \u0022%1$s\u0022</string>
+    <string name="upload_fail_cancel">Desactivado</string>
+    <string name="upload_fail_ok">Intente de nuevo</string>
+    <string name="upload_succ_ok">OK</string>
+    <string name="download_fail_ok">OK</string>
+    <string name="download_succ_ok">Abrir</string>
+    <string name="bt_opp_push_file_name">wifidirect_share.html</string>
+    <string name="unknown_file_desc">No existe una aplicación que pueda procesar este tipo de archivos. \n</string>
+    <string name="not_exist_file_desc">¡El archivo no existe!\n</string>
+    <string name="not_exist_file">El archivo no existe</string>
+    <string name="bt_error_btn_ok">OK</string>
+    <string name="notification_received_fail">WiFi Direct: no recibida %1$s</string>
+    <string name="notification_received">WiFi Direct: recibida %1$s</string>
+    <string name="notification_sent">WiFi Direct: enviada %1$s</string>
+    <string name="transfer_clear_dlg_title">Limpiar</string>
+    <string name="transfer_menu_clear">Borrar de la lista</string>
+    <string name="transfer_menu_open">Abrir</string>
+    <string name="transfer_menu_clear_all">Borrar lista</string>
+    <string name="clear_history">Borrar historial</string>
+    <string name="clearing_history">Borrando historial...</string>
+    <string name="no_transfers">El historial de transferencias está vacío</string>
+    <string name="transfer_clear_dlg_msg">Se borrarán todos los elementos de la lista.</string>
+    <string name="outbound_history_title">Historial de transferencias salientes</string>
+    <string name="inbound_history_title">Historial de transferencias entrantes</string>
+    <string name="status_unknown_error">Error desconocido</string>
+    <string name="status_protocol_error">La solicitud no se puede procesar correctamente</string>
+    <string name="status_sd_card_full">Espacio en la tarjeta SD insuficiente</string>
+    <string name="status_connection_error">"Error de conexión"</string>
+    <string name="status_no_sd_card">No hay ninguna tarjeta SD, inserte una tarjeta SD para guardar los archivos transferidos.</string>
+    <string name="status_file_error">Problema de almacenamiento</string>
+    <string name="status_canceled">Transferencia de archivos cancelada por el usuario</string>
+    <string name="status_forbidden">Transferencia prohibida por el dispositivo de destino</string>
+    <string name="status_not_accept">Este tipo de contenido no es compatible con su teléfono</string>
+    <string name="status_success">Transferencia de archivos completada con éxito</string>
+    <string name="status_running">Transferencia de archivos en curso</string>
+    <string name="status_pending">La transferencia de archivos no se ha iniciado aún</string>
+    <string name="upload_success">%1$s enviado.</string>
+    <string name="download_success">%1$s recibido.</string>
+    <string name="unknown_file">Archivo desconocido</string>
+    <string name="noti_caption">%1$s con éxito, %2$s con errores</string>
+    <string name="inbound_noti_title">WiFi Direct: recibe archivo</string>
+    <string name="outbound_noti_title">WiFi Direct: envía archivo</string>
+    <string name="cancel_transfer_dialog_button_negative">Atrás</string>
+    <string name="cancel_transfer_dialog_button_positive">Transferencia de archivos cancelada</string>
+    <string name="cancel_transfer_dialog_title">Transferencia cancelada</string>
+    <string name="accepted_comfirm_dialog_message">%1$s archivos guardados en la carpeta: %2$s</string>
+    <string name="accepted_file_statitic_dialog_button">Revisar Archivo</string>
+    <string name="accepted_file_statitic_dialog_title">Archivo Recibido</string>
+    <string name="accept_dialog_negative_button_text">Denegar</string>
+    <string name="accept_dialog_positive_button_text">Recibir</string>
+    <string name="accept_dialog_title">Transferir archivo</string>
+    <string name="Attention">Nota</string>
+    <string name="send">Enviar</string>
+    <string name="connect_break_title">"Error de conexión"</string>
+    <string name="connect_break">Desconectado, conecte de nuevo</string>
+    <string name="file_receive_interrupt">Transferencia de archivos detenida</string>
+    <string name="file_send_interrupt">Transferencia de archivos detenida</string>
+    <string name="file_receive_success">Archivo recibido con éxito</string>
+    <string name="file_send_success">Archivo enviado con éxito</string>
+    <string name="file_transfer_service_time_out">Se excedió el tiempo de espera para la transferencia de archivos</string>
+    <string name="connect_fail">Entorno inalámbrico ocupado, por favor, vuelva a conectar</string>
+    <string name="re_connect">Reconectando...</string>
+    <string name="wifi_not_available">La conexión Wi-Fi no está disponible, por favor compruebe que haya activado la conexión Wi-Fi</string>
+    <string name="transfer_complete_receive_side">Datos recibidos</string>
+    <string name="transfer_complete">Transferencia concluida</string>
+    <string name="transfer_fail">Error de transferencia de datos</string>
+    <string name="no">Cancelar</string>
+    <string name="yes">Aceptar</string>
+    <string name="force_exit">Al salir de la aplicación se detendrá la transferencia de datos</string>
+    <string name="notification_sent_fail">Fallo al enviar</string>
+    <string name="notification_progress_sign">%</string>
+    <string name="notification_receive_title">Recepción en curso</string>
+    <string name="notification_title">Envío en curso</string>
+    <string name="debug_btn_receive">Siga para Recibir</string>
+    <string name="debug_btn_send">Continúe para enviar</string>
+    <string name="receiving_data">Recibiendo datos...</string>
+    <string name="cancel">Cancelar</string>
+    <string name="connecting_txt">Preparando para Flash Transfer</string>
+    <string name="connecting_state">Conectando...</string>
+    <string name="send_notice">Enviando datos. Puede alejarse de su teléfono</string>
+    <string name="send_data">Enviando datos a través de OBeam</string>
+    <string name="receive_data">Recibiendo datos a través de OBeam</string>
+    <string name="sendTitle">(Modo de depuración) Avance:</string>
+    <string name="receive">(Modo de depuración) Avance:</string>
+    <string name="wifi_p2p_begin_to_receive_message">Recepción de archivo en curso</string>
+    <string name="wifi_p2p_begin_to_send_message">Transferencia de archivo en curso</string>
+    <string name="wifi_error" msgid="3207971103917128179">Error</string>
+    <string name="wifi_p2p_airplanemode_on_toast_message">Modo de avión activado, no puede activar WiFi Direct</string>
+    <string name="wifi_p2p_open_wifi_message">WiFi no disponible, ¿desea activar WiFi ahora?</string>
+    <string name="wifi_p2p_delete_group_message" msgid="834559380069647086">¿Olvidar este grupo?</string>
+    <string name="wifi_p2p_cancel_connect_message" msgid="7477756213423749402">¿Quiere cancelar la invitación para establecer conexión con <xliff:g id="PEER_NAME">%1$s</xliff:g>?</string>
+    <string name="wifi_p2p_cancel_connect_title" msgid="255267538099324413">¿Quiere cancelar la invitación?</string>
+    <string name="wifi_p2p_disconnect_multiple_message" msgid="3283805371034883105">Si desconecta el dispositivo, finalizará la conexión con <xliff:g id="PEER_NAME">%1$s</xliff:g> y con otros dispositivos de <xliff:g id="PEER_COUNT">%2$s</xliff:g>.</string>
+    <string name="wifi_p2p_disconnect_message" msgid="8227342771610125771">Si desconecta el dispositivo, finalizará la conexión con <xliff:g id="PEER_NAME">%1$s</xliff:g>.</string>
+    <string name="wifi_p2p_disconnect_title" msgid="3216846049677448420">¿Desconectar?</string>
+    <string name="wifi_p2p_failed_rename_message" msgid="2562182284946936380">Error al cambiar nombre del dispositivo</string>
+    <string name="wifi_p2p_failed_connect_message" msgid="8921447388048243547">No se ha podido conectar.</string>
+    <string name="wifi_p2p_remembered_groups" msgid="3847022927914068230">Recordar Grupo</string>
+    <string name="wifi_p2p_peer_devices" msgid="299526878463303432">Otros dispositivos</string>
+    <string name="wifi_p2p_menu_rename" msgid="8448896306960060415">Renombrar</string>
+    <string name="wifi_p2p_menu_searching" msgid="2396704492143633876">Buscando…</string>
+    <string name="wifi_p2p_menu_search" msgid="3436429984738771974">Buscar dispositivos</string>
+    <string name="wifi_p2p_persist_network" msgid="1646424791818168590">Recordar esta conexión</string>
+    <string name="wifi_p2p_device_info" msgid="3191876744469364173">Información del dispositivo</string>
+    <string name="wifi_p2p_settings_title" msgid="400503541488064638">Wi-Fi Directo</string>
+    <string name="dlg_cancel" msgid="1674753358972975911">Cancelar</string>
+    <string name="dlg_ok" msgid="2402639055725653590">Aceptar</string>
+    <string name="app_name">WiFi Direct</string>
+</resources>
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-km-rKH/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-km-rKH/strings.xml	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-km-rKH/strings.xml	(版本 25821)
+<?xml version="1.0" encoding="utf-8" ?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="upload_succ_ok">OK</string>
+    <string name="download_fail_ok">OK</string>
+    <string name="bt_opp_push_file_name">wifidirect_share.html</string>
+    <string name="bt_error_btn_ok">OK</string>
+    <string name="cancel_transfer_dialog_button_negative">ថយក្រោយ</string>
+    <string name="no">បោះបង់</string>
+    <string name="notification_progress_sign">%</string>
+    <string name="debug_btn_receive">Jump to Receive</string>
+    <string name="debug_btn_send">Jump to Send</string>
+    <string name="cancel">បោះបង់</string>
+</resources>
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-es-rAR/arrays.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-es-rAR/arrays.xml	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-es-rAR/arrays.xml	(版本 25821)
+<?xml version="1.0" encoding="utf-8" ?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string-array name="wifi_p2p_status">
+        <item msgid="1701505390737218306">Conectado</item>
+        <item msgid="3189211552661432651">Invitado</item>
+        <item msgid="3206450250360237549">Sin éxito</item>
+        <item msgid="7785896708926971207">Disponible</item>
+        <item msgid="2330782789550628803">Fuera de rango</item>
+    </string-array>
+</resources>
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-es-rAR/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-es-rAR/strings.xml	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-es-rAR/strings.xml	(版本 25821)
+<?xml version="1.0" encoding="utf-8" ?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="wifi_menu_scan" msgid="192587958424295789">Buscando</string>
+    <string name="progress_scanning" msgid="192587958424295789">Buscando</string>
+    <string name="bt_toast_4">No se pudo enviar el archivo</string>
+    <string name="upload_fail_line1_2">Archivo: %1$s</string>
+    <string name="upload_fail_line1">A \u0022%1$s\u0022.</string>
+    <string name="download_fail_line3">Causas: %1$s</string>
+    <string name="download_fail_line1">No se recibió el archivo</string>
+    <string name="bt_sm_2_2">Espacio requerido por S: %1$s</string>
+    <string name="download_fail_line2">Archivo: %1$s</string>
+    <string name="bt_sm_2_1">Almacenamiento insuficiente en el teléfono para guardar el archivo desde %1$s</string>
+    <string name="bt_sm_2_1_phone">Espacio en la tarjeta SD insuficiente, el archivo de \"%1$s\" no se puede guardar</string>
+    <string name="upload_succ_line5">Enviar archivo</string>
+    <string name="upload_line3">Tipo de archivo: %1$s (%2$s)</string>
+    <string name="upload_line1">A: \u0022%1$s\u0022</string>
+    <string name="download_succ_line5">Archivo recibido</string>
+    <string name="download_title">Transferir archivo</string>
+    <string name="download_line5">recibido \u2026</string>
+    <string name="download_line3">Tamaño del archivo: %1$s</string>
+    <string name="download_line2">Archivo: %1$s</string>
+    <string name="file_save_path">Guardar directorio: %1$s</string>
+    <string name="download_line1">De: \u0022%1$s\u0022</string>
+    <string name="upload_fail_cancel">Desactivado</string>
+    <string name="upload_fail_ok">Intente de nuevo</string>
+    <string name="upload_succ_ok">Aceptar</string>
+    <string name="download_fail_ok">Aceptar</string>
+    <string name="download_succ_ok">Abrir</string>
+    <string name="bt_opp_push_file_name">wifidirect_share.html</string>
+    <string name="unknown_file_desc">No existe una aplicación que pueda procesar este tipo de archivos. \n</string>
+    <string name="not_exist_file_desc">¡El archivo no existe!\n</string>
+    <string name="not_exist_file">El archivo no existe.</string>
+    <string name="bt_error_btn_ok">Aceptar</string>
+    <string name="notification_received_fail">WiFi Direct: no recibida %1$s</string>
+    <string name="notification_received">WiFi Direct: recibida %1$s</string>
+    <string name="notification_sent">WiFi Direct: enviada %1$s</string>
+    <string name="transfer_clear_dlg_title">Borrar</string>
+    <string name="transfer_menu_clear">Borrar de la lista</string>
+    <string name="transfer_menu_open">Abrir</string>
+    <string name="transfer_menu_clear_all">Borrar lista</string>
+    <string name="clear_history">Borrar historial</string>
+    <string name="clearing_history">Borrando historial...</string>
+    <string name="no_transfers">El historial de transferencias está vacío</string>
+    <string name="transfer_clear_dlg_msg">Se borrarán todos los elementos de la lista.</string>
+    <string name="outbound_history_title">Historial de transferencias salientes</string>
+    <string name="inbound_history_title">Historial de transferencias entrantes</string>
+    <string name="status_unknown_error">Error desconocido</string>
+    <string name="status_protocol_error">La solicitud no se puede procesar correctamente</string>
+    <string name="status_sd_card_full">Espacio en la tarjeta SD insuficiente</string>
+    <string name="status_connection_error">Error de conexión</string>
+    <string name="status_no_sd_card">No hay ninguna tarjeta SD, inserte una tarjeta SD para guardar los archivos transferidos.</string>
+    <string name="status_file_error">Problema de almacenamiento</string>
+    <string name="status_canceled">Transferencia de archivos cancelada por el usuario</string>
+    <string name="status_forbidden">Transferencia prohibida por el dispositivo de destino</string>
+    <string name="status_not_accept">Este tipo de contenido no es compatible con su teléfono</string>
+    <string name="status_success">Transferencia de archivos completada con éxito</string>
+    <string name="status_running">Transferencia de archivos en curso</string>
+    <string name="status_pending">La transferencia de archivos no se ha iniciado aún</string>
+    <string name="upload_success">%1$s enviado.</string>
+    <string name="download_success">%1$s recibido.</string>
+    <string name="unknown_file">Archivo desconocido</string>
+    <string name="noti_caption">%1$s con éxito, %2$s con errores</string>
+    <string name="inbound_noti_title">WiFi Direct: recibe archivo</string>
+    <string name="outbound_noti_title">WiFi Direct: envía archivo</string>
+    <string name="cancel_transfer_dialog_button_negative">Atrás</string>
+    <string name="cancel_transfer_dialog_button_positive">Transferencia de archivos cancelada</string>
+    <string name="cancel_transfer_dialog_title">Transferencia cancelada</string>
+    <string name="accepted_comfirm_dialog_message">%1$s archivos guardados en el directorio: %2$s</string>
+    <string name="accepted_file_statitic_dialog_button">Compruebe el archivo</string>
+    <string name="accepted_file_statitic_dialog_title">Archivo recibido</string>
+    <string name="accept_dialog_negative_button_text">Rechazar</string>
+    <string name="accept_dialog_positive_button_text">Recibir</string>
+    <string name="accept_dialog_title">Transferir archivo</string>
+    <string name="Attention">Nota</string>
+    <string name="send">Enviar</string>
+    <string name="connect_break_title">Error de conexión</string>
+    <string name="connect_break">Desconectado, conecte de nuevo</string>
+    <string name="file_receive_interrupt">Transferencia de archivos detenida</string>
+    <string name="file_send_interrupt">Transferencia de archivos detenida</string>
+    <string name="file_receive_success">Archivo recibido con éxito</string>
+    <string name="file_send_success">Archivo enviado con éxito</string>
+    <string name="file_transfer_service_time_out">Se excedió el tiempo de espera para la transferencia de archivos</string>
+    <string name="connect_fail">Entorno inalámbrico ocupado, por favor, vuelva a conectarse</string>
+    <string name="re_connect">Reconectando...</string>
+    <string name="wifi_not_available">Wi-Fi no disponible, compruebe si ha habilitado la conexión Wi-Fi</string>
+    <string name="transfer_complete_receive_side">Datos recibidos</string>
+    <string name="transfer_complete">Transferencia de datos finalizada</string>
+    <string name="transfer_fail">Error en la transferencia de datos</string>
+    <string name="no">Cancelar</string>
+    <string name="yes">Aceptar</string>
+    <string name="force_exit">Salir de la aplicación detendrá la transferencia de datos</string>
+    <string name="notification_sent_fail">Error de envío</string>
+    <string name="notification_progress_sign">%</string>
+    <string name="notification_receive_title">Recepción en curso</string>
+    <string name="notification_title">Envío en curso</string>
+    <string name="debug_btn_receive">Saltar a recibir</string>
+    <string name="debug_btn_send">Saltar a enviar</string>
+    <string name="receiving_data">Recibiendo datos...</string>
+    <string name="cancel">Cancelar</string>
+    <string name="connecting_txt">Trate de obtener los datos de la transmisión rápida</string>
+    <string name="connecting_state">Conectando...</string>
+    <string name="send_notice">Enviando datos. Puede alejar su teléfono</string>
+    <string name="send_data">Enviando datos a través OBeam</string>
+    <string name="receive_data">Recibiendo datos a través OBeam</string>
+    <string name="sendTitle">Progreso del (Modo de depuración):</string>
+    <string name="receive">Progreso del (Modo de depuración):</string>
+    <string name="wifi_p2p_begin_to_receive_message">Recepción de archivo en curso</string>
+    <string name="wifi_p2p_begin_to_send_message">Transferencia de archivo en curso</string>
+    <string name="wifi_error" msgid="3207971103917128179">Error</string>
+    <string name="wifi_p2p_airplanemode_on_toast_message">Modo de avión activado, no puede activar WiFi Direct</string>
+    <string name="wifi_p2p_open_wifi_message">Wi-Fi no disponible, ¿desea activar Wi-Fi ahora?</string>
+    <string name="wifi_p2p_delete_group_message" msgid="834559380069647086">¿Desea olvidarse de este grupo?</string>
+    <string name="wifi_p2p_cancel_connect_message" msgid="7477756213423749402">¿Desea cancelar la invitación a conectarse con <xliff:g id="PEER_NAME">%1$s</xliff:g>?</string>
+    <string name="wifi_p2p_cancel_connect_title" msgid="255267538099324413">¿Desea cancelar invitación?</string>
+    <string name="wifi_p2p_disconnect_multiple_message" msgid="3283805371034883105">Si se desconecta, finalizará su conexión con otros dispositivos <xliff:g id="PEER_NAME">%1$s</xliff:g> y <xliff:g id="PEER_COUNT">%2$s</xliff:g>.</string>
+    <string name="wifi_p2p_disconnect_message" msgid="8227342771610125771">Si se desconecta, finalizará su conexión con <xliff:g id="PEER_NAME">%1$s</xliff:g>.</string>
+    <string name="wifi_p2p_disconnect_title" msgid="3216846049677448420">¿Desea desconectarse?</string>
+    <string name="wifi_p2p_failed_rename_message" msgid="2562182284946936380">Error al cambiar el nombre del dispositivo.</string>
+    <string name="wifi_p2p_failed_connect_message" msgid="8921447388048243547">No se pudo conectar.</string>
+    <string name="wifi_p2p_remembered_groups" msgid="3847022927914068230">Grupos recordados</string>
+    <string name="wifi_p2p_peer_devices" msgid="299526878463303432">Dispositivos de pares</string>
+    <string name="wifi_p2p_menu_rename" msgid="8448896306960060415">Cambiar el nombre del dispositivo</string>
+    <string name="wifi_p2p_menu_searching" msgid="2396704492143633876">Buscando \u2026</string>
+    <string name="wifi_p2p_menu_search" msgid="3436429984738771974">Buscar dispositivos</string>
+    <string name="wifi_p2p_persist_network" msgid="1646424791818168590">Recordar esta conexión</string>
+    <string name="wifi_p2p_device_info" msgid="3191876744469364173">Información del dispositivo</string>
+    <string name="wifi_p2p_settings_title" msgid="400503541488064638">Wi-Fi Direct</string>
+    <string name="dlg_cancel" msgid="1674753358972975911">Cancelar</string>
+    <string name="dlg_ok" msgid="2402639055725653590">Aceptar</string>
+    <string name="app_name">WiFi Direct</string>
+</resources>
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-zu/arrays.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-zu/arrays.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-zu/arrays.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-zu/arrays.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-zu/strings.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-zu/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-zu/strings.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-zu/strings.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-el/arrays.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-el/arrays.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-el/arrays.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-el/arrays.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-el/strings.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-el/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-el/strings.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-el/strings.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-gu-rIN/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-gu-rIN/strings.xml	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-gu-rIN/strings.xml	(版本 25821)
+<?xml version="1.0" encoding="utf-8" ?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="upload_succ_ok">OK</string>
+    <string name="download_fail_ok">OK</string>
+    <string name="bt_opp_push_file_name">wifidirect_share.html</string>
+    <string name="bt_error_btn_ok">OK</string>
+    <string name="cancel_transfer_dialog_button_negative">પાછળ</string>
+    <string name="no">રદ કરો</string>
+    <string name="notification_progress_sign">%</string>
+    <string name="debug_btn_receive">Jump to Receive</string>
+    <string name="debug_btn_send">Jump to Send</string>
+    <string name="cancel">રદ કરો</string>
+</resources>
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ar/arrays.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ar/arrays.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ar/arrays.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ar/arrays.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ar/strings.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ar/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ar/strings.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ar/strings.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-zh-rHK/arrays.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-zh-rHK/arrays.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-zh-rHK/arrays.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-zh-rHK/arrays.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-zh-rHK/strings.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-zh-rHK/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-zh-rHK/strings.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-zh-rHK/strings.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-cs/arrays.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-cs/arrays.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-cs/arrays.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-cs/arrays.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-cs/strings.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-cs/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-cs/strings.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-cs/strings.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-pt-rBR/arrays.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-pt-rBR/arrays.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-pt-rBR/arrays.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-pt-rBR/arrays.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-pt-rBR/strings.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-pt-rBR/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-pt-rBR/strings.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-pt-rBR/strings.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-in/arrays.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-in/arrays.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-in/arrays.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-in/arrays.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-in/strings.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-in/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-in/strings.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-in/strings.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/menu/wifi_direct_option_menu.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/menu/wifi_direct_option_menu.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/menu/wifi_direct_option_menu.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/menu/wifi_direct_option_menu.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/menu/transferhistorycontextfinished.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/menu/transferhistorycontextfinished.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/menu/transferhistorycontextfinished.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/menu/transferhistorycontextfinished.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/menu/transferhistory.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/menu/transferhistory.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/menu/transferhistory.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/menu/transferhistory.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-es/arrays.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-es/arrays.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-es/arrays.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-es/arrays.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-es/strings.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-es/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-es/strings.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-es/strings.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ko/arrays.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ko/arrays.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ko/arrays.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ko/arrays.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ko/strings.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ko/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ko/strings.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ko/strings.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-es-rMX/arrays.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-es-rMX/arrays.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-es-rMX/arrays.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-es-rMX/arrays.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-es-rMX/strings.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-es-rMX/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-es-rMX/strings.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-es-rMX/strings.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-it/arrays.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-it/arrays.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-it/arrays.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-it/arrays.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-it/strings.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-it/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-it/strings.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-it/strings.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-es-rUS/arrays.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-es-rUS/arrays.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-es-rUS/arrays.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-es-rUS/arrays.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-es-rUS/strings.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-es-rUS/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-es-rUS/strings.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-es-rUS/strings.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-uk/arrays.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-uk/arrays.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-uk/arrays.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-uk/arrays.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-uk/strings.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-uk/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-uk/strings.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-uk/strings.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ms/arrays.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ms/arrays.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ms/arrays.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ms/arrays.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ms/strings.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ms/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ms/strings.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ms/strings.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/notification_remote.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/notification_remote.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/notification_remote.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/notification_remote.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/oppo_preference_list_fragment_wifi_direct_settings.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/oppo_preference_list_fragment_wifi_direct_settings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/oppo_preference_list_fragment_wifi_direct_settings.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/oppo_preference_list_fragment_wifi_direct_settings.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/file_transfer.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/file_transfer.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/file_transfer.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/file_transfer.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/no_transfers.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/no_transfers.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/no_transfers.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/no_transfers.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/receive_history.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/receive_history.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/receive_history.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/receive_history.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/bluetooth_transfer_item.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/bluetooth_transfer_item.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/bluetooth_transfer_item.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/bluetooth_transfer_item.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/preference_empty_list.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/preference_empty_list.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/preference_empty_list.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/preference_empty_list.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/bluetooth_transfers_page.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/bluetooth_transfers_page.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/bluetooth_transfers_page.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/bluetooth_transfers_page.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/opp_confirm_dialog.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/opp_confirm_dialog.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/opp_confirm_dialog.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/opp_confirm_dialog.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/confirm_dialog.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/confirm_dialog.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/confirm_dialog.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/confirm_dialog.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/preference_widget_wifi_signal.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/preference_widget_wifi_signal.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/preference_widget_wifi_signal.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/preference_widget_wifi_signal.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/preference_progress_category.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/preference_progress_category.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/preference_progress_category.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/layout/preference_progress_category.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-da/arrays.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-da/arrays.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-da/arrays.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-da/arrays.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-da/strings.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-da/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-da/strings.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-da/strings.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-my/arrays.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-my/arrays.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-my/arrays.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-my/arrays.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-my/strings.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-my/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-my/strings.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-my/strings.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-fa/arrays.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-fa/arrays.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-fa/arrays.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-fa/arrays.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-fa/strings.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-fa/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-fa/strings.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-fa/strings.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-de/arrays.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-de/arrays.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-de/arrays.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-de/arrays.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-de/strings.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-de/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-de/strings.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-de/strings.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-sv/arrays.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-sv/arrays.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-sv/arrays.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-sv/arrays.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-sv/strings.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-sv/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-sv/strings.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-sv/strings.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ja/arrays.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ja/arrays.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ja/arrays.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ja/arrays.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ja/strings.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ja/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ja/strings.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ja/strings.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ta-rIN/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ta-rIN/strings.xml	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ta-rIN/strings.xml	(版本 25821)
+<?xml version="1.0" encoding="utf-8" ?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="upload_succ_ok">OK</string>
+    <string name="download_fail_ok">OK</string>
+    <string name="bt_opp_push_file_name">wifidirect_share.html</string>
+    <string name="bt_error_btn_ok">OK</string>
+    <string name="cancel_transfer_dialog_button_negative">பின்செல்</string>
+    <string name="no">ரத்துசெய்</string>
+    <string name="notification_progress_sign">%</string>
+    <string name="debug_btn_receive">Jump to Receive</string>
+    <string name="debug_btn_send">Jump to Send</string>
+    <string name="cancel">ரத்துசெய்</string>
+</resources>
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-zh-rTW/arrays.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-zh-rTW/arrays.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-zh-rTW/arrays.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-zh-rTW/arrays.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-zh-rTW/strings.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-zh-rTW/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-zh-rTW/strings.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-zh-rTW/strings.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-en-rZA/arrays.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-en-rZA/arrays.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-en-rZA/arrays.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-en-rZA/arrays.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-en-rZA/strings.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-en-rZA/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-en-rZA/strings.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-en-rZA/strings.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/status_bar_close.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/status_bar_close.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/status_bar_close.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/status_bar_close.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_upload_anim0.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_upload_anim0.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_upload_anim0.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_upload_anim0.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_upload_anim1.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_upload_anim1.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_upload_anim1.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_upload_anim1.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_upload_anim2.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_upload_anim2.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_upload_anim2.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_upload_anim2.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_upload_anim3.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_upload_anim3.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_upload_anim3.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_upload_anim3.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_upload_anim4.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_upload_anim4.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_upload_anim4.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_upload_anim4.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_upload_anim5.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_upload_anim5.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_upload_anim5.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_upload_anim5.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/wifi_signal.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/wifi_signal.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/wifi_signal.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/wifi_signal.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/oppo_stat_notify_error.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/oppo_stat_notify_error.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/oppo_stat_notify_error.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/oppo_stat_notify_error.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_download.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_download.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_download.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_download.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/progress.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/progress.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/progress.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/progress.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_download_anim0.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_download_anim0.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_download_anim0.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_download_anim0.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_download_anim1.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_download_anim1.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_download_anim1.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_download_anim1.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_download_anim2.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_download_anim2.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_download_anim2.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_download_anim2.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_download_anim3.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_download_anim3.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_download_anim3.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_download_anim3.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/wifi_signal_open.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/wifi_signal_open.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/wifi_signal_open.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/wifi_signal_open.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_download_anim4.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_download_anim4.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_download_anim4.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_download_anim4.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_download_anim5.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_download_anim5.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_download_anim5.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_download_anim5.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/ic_wifi_lock_signal_0.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/ic_wifi_lock_signal_0.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/ic_wifi_lock_signal_0.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/ic_wifi_lock_signal_0.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/oppo_stat_sys_upload_anim0.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/oppo_stat_sys_upload_anim0.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/oppo_stat_sys_upload_anim0.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/oppo_stat_sys_upload_anim0.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/ic_wifi_lock_signal_1.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/ic_wifi_lock_signal_1.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/ic_wifi_lock_signal_1.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/ic_wifi_lock_signal_1.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/ic_wifi_lock_signal_2.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/ic_wifi_lock_signal_2.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/ic_wifi_lock_signal_2.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/ic_wifi_lock_signal_2.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/ic_wifi_lock_signal_3.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/ic_wifi_lock_signal_3.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/ic_wifi_lock_signal_3.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/ic_wifi_lock_signal_3.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/ic_wifi_lock_signal_4.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/ic_wifi_lock_signal_4.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/ic_wifi_lock_signal_4.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/ic_wifi_lock_signal_4.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/big_upload.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/big_upload.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/big_upload.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/big_upload.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/ic_launcher.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/ic_launcher.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/ic_launcher.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/ic_launcher.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/wifi_signal_lock.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/wifi_signal_lock.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/wifi_signal_lock.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/wifi_signal_lock.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/oppo_stat_sys_download_anim0.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/oppo_stat_sys_download_anim0.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/oppo_stat_sys_download_anim0.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/oppo_stat_sys_download_anim0.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/ic_wifi_signal_0.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/ic_wifi_signal_0.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/ic_wifi_signal_0.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/ic_wifi_signal_0.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/ic_wifi_signal_1.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/ic_wifi_signal_1.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/ic_wifi_signal_1.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/ic_wifi_signal_1.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/ic_wifi_signal_2.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/ic_wifi_signal_2.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/ic_wifi_signal_2.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/ic_wifi_signal_2.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/big_download.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/big_download.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/big_download.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/big_download.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/ic_wifi_signal_3.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/ic_wifi_signal_3.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/ic_wifi_signal_3.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/ic_wifi_signal_3.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_upload.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_upload.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_upload.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/stat_sys_upload.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/ic_wifi_signal_4.png
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/ic_wifi_signal_4.png
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/ic_wifi_signal_4.png	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/drawable-xhdpi/ic_wifi_signal_4.png	(版本 25821)
+application/octet-stream
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-nb/arrays.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-nb/arrays.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-nb/arrays.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-nb/arrays.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-nb/strings.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-nb/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-nb/strings.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-nb/strings.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-hi/arrays.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-hi/arrays.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-hi/arrays.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-hi/arrays.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-hi/strings.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-hi/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-hi/strings.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-hi/strings.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-zh-rCN/arrays.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-zh-rCN/arrays.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-zh-rCN/arrays.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-zh-rCN/arrays.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-zh-rCN/strings.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-zh-rCN/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-zh-rCN/strings.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-zh-rCN/strings.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values/arrays.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values/arrays.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values/arrays.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values/arrays.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values/colors.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values/colors.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values/colors.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values/colors.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values/configs.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values/configs.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values/configs.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values/configs.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values/strings.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values/strings.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values/strings.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values/attrs.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values/attrs.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values/attrs.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values/attrs.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/xml/wifi_p2p_settings.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/xml/wifi_p2p_settings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/xml/wifi_p2p_settings.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/xml/wifi_p2p_settings.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-bn-rBD/arrays.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-bn-rBD/arrays.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-bn-rBD/arrays.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-bn-rBD/arrays.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-bn-rBD/strings.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-bn-rBD/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-bn-rBD/strings.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-bn-rBD/strings.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-fr/arrays.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-fr/arrays.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-fr/arrays.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-fr/arrays.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-fr/strings.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-fr/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-fr/strings.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-fr/strings.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-la-rLA/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-la-rLA/strings.xml	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-la-rLA/strings.xml	(版本 25821)
+<?xml version="1.0" encoding="utf-8" ?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="upload_succ_ok">OK</string>
+    <string name="download_fail_ok">OK</string>
+    <string name="bt_opp_push_file_name">wifidirect_share.html</string>
+    <string name="bt_error_btn_ok">OK</string>
+    <string name="cancel_transfer_dialog_button_negative">ກັບຄືນ</string>
+    <string name="no">ຍົກເລີກ</string>
+    <string name="notification_progress_sign">%</string>
+    <string name="debug_btn_receive">Jump to Receive</string>
+    <string name="debug_btn_send">Jump to Send</string>
+    <string name="cancel">ຍົກເລີກ</string>
+</resources>
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-nl/arrays.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-nl/arrays.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-nl/arrays.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-nl/arrays.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-nl/strings.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-nl/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-nl/strings.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-nl/strings.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-en-rGB/arrays.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-en-rGB/arrays.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-en-rGB/arrays.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-en-rGB/arrays.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-en-rGB/strings.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-en-rGB/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-en-rGB/strings.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-en-rGB/strings.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-pl/arrays.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-pl/arrays.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-pl/arrays.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-pl/arrays.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-pl/strings.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-pl/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-pl/strings.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-pl/strings.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-th/arrays.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-th/arrays.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-th/arrays.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-th/arrays.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-th/strings.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-th/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-th/strings.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-th/strings.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-hu/arrays.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-hu/arrays.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-hu/arrays.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-hu/arrays.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-hu/strings.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-hu/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-hu/strings.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-hu/strings.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-es-rAG/arrays.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-es-rAG/arrays.xml	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-es-rAG/arrays.xml	(版本 25821)
+<?xml version="1.0" encoding="utf-8" ?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string-array name="wifi_p2p_status">
+        <item msgid="1701505390737218306">Conectado</item>
+        <item msgid="3189211552661432651">Invitado</item>
+        <item msgid="3206450250360237549">Sin éxito</item>
+        <item msgid="7785896708926971207">Disponible</item>
+        <item msgid="2330782789550628803">Fuera de rango</item>
+    </string-array>
+</resources>
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-es-rAG/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-es-rAG/strings.xml	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-es-rAG/strings.xml	(版本 25821)
+<?xml version="1.0" encoding="utf-8" ?>
+<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
+    <string name="wifi_menu_scan" msgid="192587958424295789">Buscando</string>
+    <string name="progress_scanning" msgid="192587958424295789">Buscando</string>
+    <string name="bt_toast_4">No se pudo enviar el archivo</string>
+    <string name="upload_fail_line1_2">Archivo: %1$s</string>
+    <string name="upload_fail_line1">A \u0022%1$s\u0022.</string>
+    <string name="download_fail_line3">Causas: %1$s</string>
+    <string name="download_fail_line1">No se recibió el archivo</string>
+    <string name="bt_sm_2_2">Espacio requerido por S: %1$s</string>
+    <string name="download_fail_line2">Archivo: %1$s</string>
+    <string name="bt_sm_2_1">Almacenamiento insuficiente en el teléfono para guardar el archivo desde %1$s</string>
+    <string name="bt_sm_2_1_phone">Espacio en la tarjeta SD insuficiente, el archivo de \"%1$s\" no se puede guardar</string>
+    <string name="upload_succ_line5">Enviar archivo</string>
+    <string name="upload_line3">Tipo de archivo: %1$s (%2$s)</string>
+    <string name="upload_line1">A: \u0022%1$s\u0022</string>
+    <string name="download_succ_line5">Archivo recibido</string>
+    <string name="download_title">Transferir archivo</string>
+    <string name="download_line5">recibido \u2026</string>
+    <string name="download_line3">Tamaño del archivo: %1$s</string>
+    <string name="download_line2">Archivo: %1$s</string>
+    <string name="file_save_path">Guardar directorio: %1$s</string>
+    <string name="download_line1">De: \u0022%1$s\u0022</string>
+    <string name="upload_fail_cancel">Desactivado</string>
+    <string name="upload_fail_ok">Intente de nuevo</string>
+    <string name="upload_succ_ok">Aceptar</string>
+    <string name="download_fail_ok">Aceptar</string>
+    <string name="download_succ_ok">Abrir</string>
+    <string name="bt_opp_push_file_name">wifidirect_share.html</string>
+    <string name="unknown_file_desc">No existe una aplicación que pueda procesar este tipo de archivos. \n</string>
+    <string name="not_exist_file_desc">¡El archivo no existe!\n</string>
+    <string name="not_exist_file">El archivo no existe.</string>
+    <string name="bt_error_btn_ok">Aceptar</string>
+    <string name="notification_received_fail">WiFi Direct: no recibida %1$s</string>
+    <string name="notification_received">WiFi Direct: recibida %1$s</string>
+    <string name="notification_sent">WiFi Direct: enviada %1$s</string>
+    <string name="transfer_clear_dlg_title">Borrar</string>
+    <string name="transfer_menu_clear">Borrar de la lista</string>
+    <string name="transfer_menu_open">Abrir</string>
+    <string name="transfer_menu_clear_all">Borrar lista</string>
+    <string name="clear_history">Borrar historial</string>
+    <string name="clearing_history">Borrando historial...</string>
+    <string name="no_transfers">El historial de transferencias está vacío</string>
+    <string name="transfer_clear_dlg_msg">Se borrarán todos los elementos de la lista.</string>
+    <string name="outbound_history_title">Historial de transferencias salientes</string>
+    <string name="inbound_history_title">Historial de transferencias entrantes</string>
+    <string name="status_unknown_error">Error desconocido</string>
+    <string name="status_protocol_error">La solicitud no se puede procesar correctamente</string>
+    <string name="status_sd_card_full">Espacio en la tarjeta SD insuficiente</string>
+    <string name="status_connection_error">Error de conexión</string>
+    <string name="status_no_sd_card">No hay ninguna tarjeta SD, inserte una tarjeta SD para guardar los archivos transferidos.</string>
+    <string name="status_file_error">Problema de almacenamiento</string>
+    <string name="status_canceled">Transferencia de archivos cancelada por el usuario</string>
+    <string name="status_forbidden">Transferencia prohibida por el dispositivo de destino</string>
+    <string name="status_not_accept">Este tipo de contenido no es compatible con su teléfono</string>
+    <string name="status_success">Transferencia de archivos completada con éxito</string>
+    <string name="status_running">Transferencia de archivos en curso</string>
+    <string name="status_pending">La transferencia de archivos no se ha iniciado aún</string>
+    <string name="upload_success">%1$s enviado.</string>
+    <string name="download_success">%1$s recibido.</string>
+    <string name="unknown_file">Archivo desconocido</string>
+    <string name="noti_caption">%1$s con éxito, %2$s con errores</string>
+    <string name="inbound_noti_title">WiFi Direct: recibe archivo</string>
+    <string name="outbound_noti_title">WiFi Direct: envía archivo</string>
+    <string name="cancel_transfer_dialog_button_negative">Atrás</string>
+    <string name="cancel_transfer_dialog_button_positive">Transferencia de archivos cancelada</string>
+    <string name="cancel_transfer_dialog_title">Transferencia cancelada</string>
+    <string name="accepted_comfirm_dialog_message">%1$s archivos guardados en el directorio: %2$s</string>
+    <string name="accepted_file_statitic_dialog_button">Compruebe el archivo</string>
+    <string name="accepted_file_statitic_dialog_title">Archivo recibido</string>
+    <string name="accept_dialog_negative_button_text">Rechazar</string>
+    <string name="accept_dialog_positive_button_text">Recibir</string>
+    <string name="accept_dialog_title">Transferir archivo</string>
+    <string name="Attention">Nota</string>
+    <string name="send">Enviar</string>
+    <string name="connect_break_title">Error de conexión</string>
+    <string name="connect_break">Desconectado, conecte de nuevo</string>
+    <string name="file_receive_interrupt">Transferencia de archivos detenida</string>
+    <string name="file_send_interrupt">Transferencia de archivos detenida</string>
+    <string name="file_receive_success">Archivo recibido con éxito</string>
+    <string name="file_send_success">Archivo enviado con éxito</string>
+    <string name="file_transfer_service_time_out">Se excedió el tiempo de espera para la transferencia de archivos</string>
+    <string name="connect_fail">Entorno inalámbrico ocupado, por favor, vuelva a conectarse</string>
+    <string name="re_connect">Reconectando...</string>
+    <string name="wifi_not_available">Wi-Fi no disponible, compruebe si ha habilitado la conexión Wi-Fi</string>
+    <string name="transfer_complete_receive_side">Datos recibidos</string>
+    <string name="transfer_complete">Transferencia de datos finalizada</string>
+    <string name="transfer_fail">Error en la transferencia de datos</string>
+    <string name="no">Cancelar</string>
+    <string name="yes">Aceptar</string>
+    <string name="force_exit">Salir de la aplicación detendrá la transferencia de datos</string>
+    <string name="notification_sent_fail">Error de envío</string>
+    <string name="notification_progress_sign">%</string>
+    <string name="notification_receive_title">Recepción en curso</string>
+    <string name="notification_title">Envío en curso</string>
+    <string name="debug_btn_receive">Saltar a recibir</string>
+    <string name="debug_btn_send">Saltar a enviar</string>
+    <string name="receiving_data">Recibiendo datos...</string>
+    <string name="cancel">Cancelar</string>
+    <string name="connecting_txt">Trate de obtener los datos de la transmisión rápida</string>
+    <string name="connecting_state">Conectando...</string>
+    <string name="send_notice">Enviando datos. Puede alejar su teléfono</string>
+    <string name="send_data">Enviando datos a través OBeam</string>
+    <string name="receive_data">Recibiendo datos a través OBeam</string>
+    <string name="sendTitle">Progreso del (Modo de depuración):</string>
+    <string name="receive">Progreso del (Modo de depuración):</string>
+    <string name="wifi_p2p_begin_to_receive_message">Recepción de archivo en curso</string>
+    <string name="wifi_p2p_begin_to_send_message">Transferencia de archivo en curso</string>
+    <string name="wifi_error" msgid="3207971103917128179">Error</string>
+    <string name="wifi_p2p_airplanemode_on_toast_message">Modo de avión activado, no puede activar WiFi Direct</string>
+    <string name="wifi_p2p_open_wifi_message">Wi-Fi no disponible, ¿desea activar Wi-Fi ahora?</string>
+    <string name="wifi_p2p_delete_group_message" msgid="834559380069647086">¿Desea olvidarse de este grupo?</string>
+    <string name="wifi_p2p_cancel_connect_message" msgid="7477756213423749402">¿Desea cancelar la invitación a conectarse con <xliff:g id="PEER_NAME">%1$s</xliff:g>?</string>
+    <string name="wifi_p2p_cancel_connect_title" msgid="255267538099324413">¿Desea cancelar invitación?</string>
+    <string name="wifi_p2p_disconnect_multiple_message" msgid="3283805371034883105">Si se desconecta, finalizará su conexión con otros dispositivos <xliff:g id="PEER_NAME">%1$s</xliff:g> y <xliff:g id="PEER_COUNT">%2$s</xliff:g>.</string>
+    <string name="wifi_p2p_disconnect_message" msgid="8227342771610125771">Si se desconecta, finalizará su conexión con <xliff:g id="PEER_NAME">%1$s</xliff:g>.</string>
+    <string name="wifi_p2p_disconnect_title" msgid="3216846049677448420">¿Desea desconectarse?</string>
+    <string name="wifi_p2p_failed_rename_message" msgid="2562182284946936380">Error al cambiar el nombre del dispositivo.</string>
+    <string name="wifi_p2p_failed_connect_message" msgid="8921447388048243547">No se pudo conectar.</string>
+    <string name="wifi_p2p_remembered_groups" msgid="3847022927914068230">Grupos recordados</string>
+    <string name="wifi_p2p_peer_devices" msgid="299526878463303432">Dispositivos de pares</string>
+    <string name="wifi_p2p_menu_rename" msgid="8448896306960060415">Cambiar el nombre del dispositivo</string>
+    <string name="wifi_p2p_menu_searching" msgid="2396704492143633876">Buscando \u2026</string>
+    <string name="wifi_p2p_menu_search" msgid="3436429984738771974">Buscar dispositivos</string>
+    <string name="wifi_p2p_persist_network" msgid="1646424791818168590">Recordar esta conexión</string>
+    <string name="wifi_p2p_device_info" msgid="3191876744469364173">Información del dispositivo</string>
+    <string name="wifi_p2p_settings_title" msgid="400503541488064638">Wi-Fi Direct</string>
+    <string name="dlg_cancel" msgid="1674753358972975911">Cancelar</string>
+    <string name="dlg_ok" msgid="2402639055725653590">Aceptar</string>
+    <string name="app_name">WiFi Direct</string>
+</resources>
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-vi/arrays.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-vi/arrays.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-vi/arrays.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-vi/arrays.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-vi/strings.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-vi/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-vi/strings.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-vi/strings.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-tl/arrays.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-tl/arrays.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-tl/arrays.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-tl/arrays.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-tl/strings.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-tl/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-tl/strings.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-tl/strings.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ro/arrays.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ro/arrays.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ro/arrays.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ro/arrays.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ro/strings.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ro/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ro/strings.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ro/strings.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ur-rPK/arrays.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ur-rPK/arrays.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ur-rPK/arrays.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ur-rPK/arrays.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ur-rPK/strings.xml
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ur-rPK/strings.xml
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ur-rPK/strings.xml	(版本 25822)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/res/values-ur-rPK/strings.xml	(版本 25821)
+application/xml
+*
Index: Tag/NearMePVT2.0/WifiDirectFileTransfer/.settings/org.eclipse.jdt.core.prefs
--- Tag/NearMePVT2.0/WifiDirectFileTransfer/.settings/org.eclipse.jdt.core.prefs	(版本 0)
+++ Tag/NearMePVT2.0/WifiDirectFileTransfer/.settings/org.eclipse.jdt.core.prefs	(版本 25821)
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.6
+org.eclipse.jdt.core.compiler.compliance=1.6
+org.eclipse.jdt.core.compiler.source=1.6
+*
